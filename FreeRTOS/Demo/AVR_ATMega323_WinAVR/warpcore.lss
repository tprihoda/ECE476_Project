
warpcore.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000134  00800100  00005a98  00005b2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005a98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004bf  00800234  00800234  00005c60  2**0
                  ALLOC
  3 .stab         0000f834  00000000  00000000  00005c60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006dad  00000000  00000000  00015494  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001c241  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0001c254  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0001c294  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0001c888  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0001ce2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0001ce44  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__ctors_end>
       4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      10:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      14:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      18:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      1c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      20:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      24:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      28:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      2c:	0c 94 8f 17 	jmp	0x2f1e	; 0x2f1e <__vector_11>
      30:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      34:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      38:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      3c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      40:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      44:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      48:	0c 94 53 01 	jmp	0x2a6	; 0x2a6 <__vector_18>
      4c:	0c 94 93 01 	jmp	0x326	; 0x326 <__vector_19>
      50:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      54:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      58:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      5c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      60:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      64:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      68:	33 22       	and	r3, r19
      6a:	5a 22       	and	r5, r26
      6c:	65 22       	and	r6, r21
      6e:	77 22       	and	r7, r23
      70:	7e 22       	and	r7, r30
      72:	88 22       	and	r8, r24
      74:	8f 22       	and	r8, r31
      76:	9f 22       	and	r9, r31
      78:	d9 22       	and	r13, r25
      7a:	dc 22       	and	r13, r28
      7c:	df 22       	and	r13, r31
      7e:	ee 22       	and	r14, r30
      80:	f9 22       	and	r15, r25
      82:	08 23       	and	r16, r24
      84:	45 23       	and	r20, r21
      86:	85 23       	and	r24, r21
      88:	97 23       	and	r25, r23
      8a:	9e 23       	and	r25, r30
      8c:	ab 23       	and	r26, r27
      8e:	c0 23       	and	r28, r16
      90:	cf 23       	and	r28, r31
      92:	5a 24       	eor	r5, r10
      94:	f3 23       	and	r31, r19
      96:	13 24       	eor	r1, r3
      98:	30 24       	eor	r3, r0
      9a:	17 24       	eor	r1, r7
      9c:	1e 24       	eor	r1, r14
      9e:	3f 24       	eor	r3, r15
      a0:	0a 27       	eor	r16, r26
      a2:	0d 27       	eor	r16, r29
      a4:	1f 27       	eor	r17, r31
      a6:	1a 27       	eor	r17, r26
      a8:	22 27       	eor	r18, r18
      aa:	28 27       	eor	r18, r24
      ac:	2d 27       	eor	r18, r29
      ae:	3c 27       	eor	r19, r28
      b0:	52 27       	eor	r21, r18
      b2:	63 27       	eor	r22, r19
      b4:	66 27       	eor	r22, r22
      b6:	6a 27       	eor	r22, r26
      b8:	26 27       	eor	r18, r22
      ba:	6e 27       	eor	r22, r30
      bc:	74 27       	eor	r23, r20
      be:	77 27       	eor	r23, r23

000000c0 <__ctors_end>:
      c0:	11 24       	eor	r1, r1
      c2:	1f be       	out	0x3f, r1	; 63
      c4:	cf ef       	ldi	r28, 0xFF	; 255
      c6:	d8 e0       	ldi	r29, 0x08	; 8
      c8:	de bf       	out	0x3e, r29	; 62
      ca:	cd bf       	out	0x3d, r28	; 61

000000cc <__do_copy_data>:
      cc:	12 e0       	ldi	r17, 0x02	; 2
      ce:	a0 e0       	ldi	r26, 0x00	; 0
      d0:	b1 e0       	ldi	r27, 0x01	; 1
      d2:	e8 e9       	ldi	r30, 0x98	; 152
      d4:	fa e5       	ldi	r31, 0x5A	; 90
      d6:	02 c0       	rjmp	.+4      	; 0xdc <__do_copy_data+0x10>
      d8:	05 90       	lpm	r0, Z+
      da:	0d 92       	st	X+, r0
      dc:	a4 33       	cpi	r26, 0x34	; 52
      de:	b1 07       	cpc	r27, r17
      e0:	d9 f7       	brne	.-10     	; 0xd8 <__do_copy_data+0xc>

000000e2 <__do_clear_bss>:
      e2:	26 e0       	ldi	r18, 0x06	; 6
      e4:	a4 e3       	ldi	r26, 0x34	; 52
      e6:	b2 e0       	ldi	r27, 0x02	; 2
      e8:	01 c0       	rjmp	.+2      	; 0xec <.do_clear_bss_start>

000000ea <.do_clear_bss_loop>:
      ea:	1d 92       	st	X+, r1

000000ec <.do_clear_bss_start>:
      ec:	a3 3f       	cpi	r26, 0xF3	; 243
      ee:	b2 07       	cpc	r27, r18
      f0:	e1 f7       	brne	.-8      	; 0xea <.do_clear_bss_loop>
      f2:	0e 94 7a 2c 	call	0x58f4	; 0x58f4 <main>
      f6:	0c 94 4a 2d 	jmp	0x5a94	; 0x5a94 <_exit>

000000fa <__bad_interrupt>:
      fa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fe <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
    //PORTB ^= 0x20;
    //_delay_ms(200);
	writeString("Idle");
      fe:	84 e4       	ldi	r24, 0x44	; 68
     100:	91 e0       	ldi	r25, 0x01	; 1
     102:	0c 94 28 07 	jmp	0xe50	; 0xe50 <writeString>

00000106 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     106:	8f ef       	ldi	r24, 0xFF	; 255
     108:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     10c:	84 b9       	out	0x04, r24	; 4
	PORTB = ucCurrentOutputValue;
     10e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     112:	85 b9       	out	0x05, r24	; 5
     114:	08 95       	ret

00000116 <vParTestSetLED>:
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     116:	1f 93       	push	r17
     118:	cf 93       	push	r28
     11a:	df 93       	push	r29
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     11c:	88 30       	cpi	r24, 0x08	; 8
     11e:	d8 f4       	brcc	.+54     	; 0x156 <vParTestSetLED+0x40>
     120:	16 2f       	mov	r17, r22
	{
		ucBit <<= uxLED;	
     122:	c1 e0       	ldi	r28, 0x01	; 1
     124:	d0 e0       	ldi	r29, 0x00	; 0
     126:	01 c0       	rjmp	.+2      	; 0x12a <vParTestSetLED+0x14>
     128:	cc 0f       	add	r28, r28
     12a:	8a 95       	dec	r24
     12c:	ea f7       	brpl	.-6      	; 0x128 <vParTestSetLED+0x12>

		vTaskSuspendAll();
     12e:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     132:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
	{
		ucBit <<= uxLED;	

		vTaskSuspendAll();
		{
			if( xValue == pdTRUE )
     136:	11 30       	cpi	r17, 0x01	; 1
     138:	19 f4       	brne	.+6      	; 0x140 <vParTestSetLED+0x2a>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     13a:	c0 95       	com	r28
     13c:	c8 23       	and	r28, r24
     13e:	01 c0       	rjmp	.+2      	; 0x142 <vParTestSetLED+0x2c>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     140:	c8 2b       	or	r28, r24
     142:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__data_start>
			}

			PORTB = ucCurrentOutputValue;
     146:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     14a:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
	}
}
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	1f 91       	pop	r17
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();
     152:	0c 94 9a 0a 	jmp	0x1534	; 0x1534 <xTaskResumeAll>
	}
}
     156:	df 91       	pop	r29
     158:	cf 91       	pop	r28
     15a:	1f 91       	pop	r17
     15c:	08 95       	ret

0000015e <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     15e:	cf 93       	push	r28
     160:	df 93       	push	r29
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     162:	88 30       	cpi	r24, 0x08	; 8
     164:	e8 f4       	brcc	.+58     	; 0x1a0 <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     166:	c1 e0       	ldi	r28, 0x01	; 1
     168:	d0 e0       	ldi	r29, 0x00	; 0
     16a:	01 c0       	rjmp	.+2      	; 0x16e <vParTestToggleLED+0x10>
     16c:	cc 0f       	add	r28, r28
     16e:	8a 95       	dec	r24
     170:	ea f7       	brpl	.-6      	; 0x16c <vParTestToggleLED+0xe>

		vTaskSuspendAll();
     172:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     176:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     17a:	8c 23       	and	r24, r28
     17c:	29 f0       	breq	.+10     	; 0x188 <vParTestToggleLED+0x2a>
			{
				ucCurrentOutputValue &= ~ucBit;
     17e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     182:	c0 95       	com	r28
     184:	c8 23       	and	r28, r24
     186:	03 c0       	rjmp	.+6      	; 0x18e <vParTestToggleLED+0x30>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     188:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     18c:	c8 2b       	or	r28, r24
     18e:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__data_start>
			}

			PORTB = ucCurrentOutputValue;
     192:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     196:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
	}
}
     198:	df 91       	pop	r29
     19a:	cf 91       	pop	r28
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();			
     19c:	0c 94 9a 0a 	jmp	0x1534	; 0x1534 <xTaskResumeAll>
	}
}
     1a0:	df 91       	pop	r29
     1a2:	cf 91       	pop	r28
     1a4:	08 95       	ret

000001a6 <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     1a6:	cf 92       	push	r12
     1a8:	df 92       	push	r13
     1aa:	ef 92       	push	r14
     1ac:	ff 92       	push	r15
     1ae:	cf 93       	push	r28
     1b0:	6b 01       	movw	r12, r22
     1b2:	7c 01       	movw	r14, r24
     1b4:	c4 2f       	mov	r28, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     1b6:	0f b6       	in	r0, 0x3f	; 63
     1b8:	f8 94       	cli
     1ba:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     1bc:	40 e0       	ldi	r20, 0x00	; 0
     1be:	61 e0       	ldi	r22, 0x01	; 1
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <xQueueGenericCreate>
     1c6:	90 93 37 02 	sts	0x0237, r25	; 0x800237 <xRxedChars+0x1>
     1ca:	80 93 36 02 	sts	0x0236, r24	; 0x800236 <xRxedChars>
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     1ce:	40 e0       	ldi	r20, 0x00	; 0
     1d0:	61 e0       	ldi	r22, 0x01	; 1
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <xQueueGenericCreate>
     1d8:	90 93 35 02 	sts	0x0235, r25	; 0x800235 <__data_end+0x1>
     1dc:	80 93 34 02 	sts	0x0234, r24	; 0x800234 <__data_end>

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     1e0:	a7 01       	movw	r20, r14
     1e2:	96 01       	movw	r18, r12
     1e4:	84 e0       	ldi	r24, 0x04	; 4
     1e6:	22 0f       	add	r18, r18
     1e8:	33 1f       	adc	r19, r19
     1ea:	44 1f       	adc	r20, r20
     1ec:	55 1f       	adc	r21, r21
     1ee:	8a 95       	dec	r24
     1f0:	d1 f7       	brne	.-12     	; 0x1e6 <xSerialPortInitMinimal+0x40>
     1f2:	60 e0       	ldi	r22, 0x00	; 0
     1f4:	74 e2       	ldi	r23, 0x24	; 36
     1f6:	84 ef       	ldi	r24, 0xF4	; 244
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	0e 94 98 2c 	call	0x5930	; 0x5930 <__udivmodsi4>
     1fe:	da 01       	movw	r26, r20
     200:	c9 01       	movw	r24, r18
     202:	01 97       	sbiw	r24, 0x01	; 1
     204:	a1 09       	sbc	r26, r1
     206:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
     208:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     20c:	89 2f       	mov	r24, r25
     20e:	9a 2f       	mov	r25, r26
     210:	ab 2f       	mov	r26, r27
     212:	bb 27       	eor	r27, r27
		UBRR0H = ucByte;
     214:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     218:	88 e9       	ldi	r24, 0x98	; 152
     21a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     21e:	86 e8       	ldi	r24, 0x86	; 134
     220:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	}
	portEXIT_CRITICAL();
     224:	0f 90       	pop	r0
     226:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     228:	80 e0       	ldi	r24, 0x00	; 0
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	cf 91       	pop	r28
     22e:	ff 90       	pop	r15
     230:	ef 90       	pop	r14
     232:	df 90       	pop	r13
     234:	cf 90       	pop	r12
     236:	08 95       	ret

00000238 <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     238:	80 91 36 02 	lds	r24, 0x0236	; 0x800236 <xRxedChars>
     23c:	90 91 37 02 	lds	r25, 0x0237	; 0x800237 <xRxedChars+0x1>
     240:	0e 94 aa 10 	call	0x2154	; 0x2154 <xQueueReceive>
     244:	91 e0       	ldi	r25, 0x01	; 1
     246:	81 11       	cpse	r24, r1
     248:	01 c0       	rjmp	.+2      	; 0x24c <xSerialGetChar+0x14>
     24a:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return pdFALSE;
	}
}
     24c:	89 2f       	mov	r24, r25
     24e:	08 95       	ret

00000250 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	1f 92       	push	r1
     256:	cd b7       	in	r28, 0x3d	; 61
     258:	de b7       	in	r29, 0x3e	; 62
     25a:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     25c:	20 e0       	ldi	r18, 0x00	; 0
     25e:	be 01       	movw	r22, r28
     260:	6f 5f       	subi	r22, 0xFF	; 255
     262:	7f 4f       	sbci	r23, 0xFF	; 255
     264:	80 91 34 02 	lds	r24, 0x0234	; 0x800234 <__data_end>
     268:	90 91 35 02 	lds	r25, 0x0235	; 0x800235 <__data_end+0x1>
     26c:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <xQueueGenericSend>
     270:	81 30       	cpi	r24, 0x01	; 1
     272:	31 f4       	brne	.+12     	; 0x280 <xSerialPutChar+0x30>
	{
		return pdFAIL;
	}

	vInterruptOn();
     274:	90 91 c1 00 	lds	r25, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     278:	90 62       	ori	r25, 0x20	; 32
     27a:	90 93 c1 00 	sts	0x00C1, r25	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

	return pdPASS;
     27e:	01 c0       	rjmp	.+2      	; 0x282 <xSerialPutChar+0x32>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
     280:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
     282:	0f 90       	pop	r0
     284:	df 91       	pop	r29
     286:	cf 91       	pop	r28
     288:	08 95       	ret

0000028a <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     28a:	0f b6       	in	r0, 0x3f	; 63
     28c:	f8 94       	cli
     28e:	0f 92       	push	r0
	{
		vInterruptOff();
     290:	e1 ec       	ldi	r30, 0xC1	; 193
     292:	f0 e0       	ldi	r31, 0x00	; 0
     294:	80 81       	ld	r24, Z
     296:	8f 7d       	andi	r24, 0xDF	; 223
     298:	80 83       	st	Z, r24
		ucByte = UCSR0B;
     29a:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     29c:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
     29e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     2a0:	0f 90       	pop	r0
     2a2:	0f be       	out	0x3f, r0	; 63
     2a4:	08 95       	ret

000002a6 <__vector_18>:
}
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_RECV )
SIGNAL( USART_RX_vect )
{
     2a6:	1f 92       	push	r1
     2a8:	0f 92       	push	r0
     2aa:	0f b6       	in	r0, 0x3f	; 63
     2ac:	0f 92       	push	r0
     2ae:	11 24       	eor	r1, r1
     2b0:	2f 93       	push	r18
     2b2:	3f 93       	push	r19
     2b4:	4f 93       	push	r20
     2b6:	5f 93       	push	r21
     2b8:	6f 93       	push	r22
     2ba:	7f 93       	push	r23
     2bc:	8f 93       	push	r24
     2be:	9f 93       	push	r25
     2c0:	af 93       	push	r26
     2c2:	bf 93       	push	r27
     2c4:	ef 93       	push	r30
     2c6:	ff 93       	push	r31
     2c8:	cf 93       	push	r28
     2ca:	df 93       	push	r29
     2cc:	00 d0       	rcall	.+0      	; 0x2ce <__vector_18+0x28>
     2ce:	cd b7       	in	r28, 0x3d	; 61
     2d0:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     2d2:	19 82       	std	Y+1, r1	; 0x01

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     2d4:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     2d8:	8a 83       	std	Y+2, r24	; 0x02

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     2da:	20 e0       	ldi	r18, 0x00	; 0
     2dc:	ae 01       	movw	r20, r28
     2de:	4f 5f       	subi	r20, 0xFF	; 255
     2e0:	5f 4f       	sbci	r21, 0xFF	; 255
     2e2:	be 01       	movw	r22, r28
     2e4:	6e 5f       	subi	r22, 0xFE	; 254
     2e6:	7f 4f       	sbci	r23, 0xFF	; 255
     2e8:	80 91 36 02 	lds	r24, 0x0236	; 0x800236 <xRxedChars>
     2ec:	90 91 37 02 	lds	r25, 0x0237	; 0x800237 <xRxedChars+0x1>
     2f0:	0e 94 58 10 	call	0x20b0	; 0x20b0 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     2f4:	89 81       	ldd	r24, Y+1	; 0x01
     2f6:	81 11       	cpse	r24, r1
	{
		taskYIELD();
     2f8:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
	}
}
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	df 91       	pop	r29
     302:	cf 91       	pop	r28
     304:	ff 91       	pop	r31
     306:	ef 91       	pop	r30
     308:	bf 91       	pop	r27
     30a:	af 91       	pop	r26
     30c:	9f 91       	pop	r25
     30e:	8f 91       	pop	r24
     310:	7f 91       	pop	r23
     312:	6f 91       	pop	r22
     314:	5f 91       	pop	r21
     316:	4f 91       	pop	r20
     318:	3f 91       	pop	r19
     31a:	2f 91       	pop	r18
     31c:	0f 90       	pop	r0
     31e:	0f be       	out	0x3f, r0	; 63
     320:	0f 90       	pop	r0
     322:	1f 90       	pop	r1
     324:	18 95       	reti

00000326 <__vector_19>:
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_DATA )
SIGNAL( USART_UDRE_vect )
{
     326:	1f 92       	push	r1
     328:	0f 92       	push	r0
     32a:	0f b6       	in	r0, 0x3f	; 63
     32c:	0f 92       	push	r0
     32e:	11 24       	eor	r1, r1
     330:	2f 93       	push	r18
     332:	3f 93       	push	r19
     334:	4f 93       	push	r20
     336:	5f 93       	push	r21
     338:	6f 93       	push	r22
     33a:	7f 93       	push	r23
     33c:	8f 93       	push	r24
     33e:	9f 93       	push	r25
     340:	af 93       	push	r26
     342:	bf 93       	push	r27
     344:	ef 93       	push	r30
     346:	ff 93       	push	r31
     348:	cf 93       	push	r28
     34a:	df 93       	push	r29
     34c:	00 d0       	rcall	.+0      	; 0x34e <__vector_19+0x28>
     34e:	cd b7       	in	r28, 0x3d	; 61
     350:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     352:	ae 01       	movw	r20, r28
     354:	4f 5f       	subi	r20, 0xFF	; 255
     356:	5f 4f       	sbci	r21, 0xFF	; 255
     358:	be 01       	movw	r22, r28
     35a:	6e 5f       	subi	r22, 0xFE	; 254
     35c:	7f 4f       	sbci	r23, 0xFF	; 255
     35e:	80 91 34 02 	lds	r24, 0x0234	; 0x800234 <__data_end>
     362:	90 91 35 02 	lds	r25, 0x0235	; 0x800235 <__data_end+0x1>
     366:	0e 94 54 12 	call	0x24a8	; 0x24a8 <xQueueReceiveFromISR>
     36a:	81 30       	cpi	r24, 0x01	; 1
     36c:	21 f4       	brne	.+8      	; 0x376 <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     36e:	8a 81       	ldd	r24, Y+2	; 0x02
     370:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     374:	05 c0       	rjmp	.+10     	; 0x380 <__vector_19+0x5a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     376:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     37a:	8f 7d       	andi	r24, 0xDF	; 223
     37c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	}
}
     380:	0f 90       	pop	r0
     382:	0f 90       	pop	r0
     384:	df 91       	pop	r29
     386:	cf 91       	pop	r28
     388:	ff 91       	pop	r31
     38a:	ef 91       	pop	r30
     38c:	bf 91       	pop	r27
     38e:	af 91       	pop	r26
     390:	9f 91       	pop	r25
     392:	8f 91       	pop	r24
     394:	7f 91       	pop	r23
     396:	6f 91       	pop	r22
     398:	5f 91       	pop	r21
     39a:	4f 91       	pop	r20
     39c:	3f 91       	pop	r19
     39e:	2f 91       	pop	r18
     3a0:	0f 90       	pop	r0
     3a2:	0f be       	out	0x3f, r0	; 63
     3a4:	0f 90       	pop	r0
     3a6:	1f 90       	pop	r1
     3a8:	18 95       	reti

000003aa <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     3aa:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     3ac:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     3ae:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     3b0:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     3b2:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     3b4:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     3b6:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     3b8:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     3ba:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     3bc:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     3be:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     3c0:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     3c2:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     3c4:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     3c6:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     3c8:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     3ca:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     3cc:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     3ce:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     3d0:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     3d2:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     3d4:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     3d6:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     3d8:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     3da:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     3dc:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     3de:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     3e0:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     3e2:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     3e4:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     3e6:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     3e8:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     3ea:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     3ec:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     3ee:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     3f0:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     3f2:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     3f4:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     3f6:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     3f8:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     3fa:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     3fc:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     3fe:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     400:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     402:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     404:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     406:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     408:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     40c:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     40e:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     410:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     414:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     416:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     418:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     41c:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     41e:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     420:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     424:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     426:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     428:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     42c:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     42e:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     430:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     434:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     436:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     438:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     43c:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     43e:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     440:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     444:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     446:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     448:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     44c:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     44e:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     450:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     454:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     456:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     458:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     45c:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     45e:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     460:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     464:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     466:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     468:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     46c:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     46e:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     470:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     474:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     476:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     478:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     47c:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     47e:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     480:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     484:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     486:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     488:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     48c:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     48e:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     490:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     494:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     496:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     498:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     49c:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     49e:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     4a0:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     4a4:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     4a6:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     4a8:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     4ac:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     4ae:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     4b0:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     4b4:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     4b6:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     4b8:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     4bc:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     4be:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     4c0:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     4c4:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     4c6:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     4c8:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	30"			);
     4cc:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     4ce:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     4d0:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	31"			);
     4d4:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     4d6:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     4d8:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	32"			);
     4dc:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     4de:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     4e0:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	33"			);
     4e4:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     4e6:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     4e8:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
     4ec:	5e cf       	rjmp	.-324    	; 0x3aa <prvRegisterCheck1>

000004ee <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     4ee:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     4f0:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     4f2:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     4f4:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     4f6:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     4f8:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     4fa:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     4fc:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     4fe:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     500:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     502:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     504:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     506:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     508:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     50a:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     50c:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     50e:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     510:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     512:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     514:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     516:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     518:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     51a:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     51c:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     51e:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     520:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     522:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     524:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     526:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     528:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     52a:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     52c:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     52e:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     530:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     532:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     534:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     536:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     538:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     53a:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     53c:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     53e:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     540:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     542:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     544:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     546:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     548:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     54a:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     54c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	2"			);
     550:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     552:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     554:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	3"			);
     558:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     55a:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     55c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	4"			);
     560:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     562:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     564:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	5"			);
     568:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     56a:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     56c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     570:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     572:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     574:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     578:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     57a:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     57c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     580:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     582:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     584:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     588:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     58a:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     58c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     590:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     592:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     594:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     598:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     59a:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     59c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     5a0:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     5a2:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     5a4:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     5a8:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     5aa:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     5ac:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     5b0:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     5b2:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     5b4:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     5b8:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     5ba:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     5bc:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     5c0:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     5c2:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     5c4:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     5c8:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     5ca:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     5cc:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     5d0:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     5d2:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     5d4:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     5d8:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     5da:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     5dc:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     5e0:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     5e2:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     5e4:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     5e8:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     5ea:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     5ec:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     5f0:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     5f2:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     5f4:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     5f8:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     5fa:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     5fc:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     600:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     602:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     604:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     608:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     60a:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     60c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     610:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     612:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     614:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     618:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     61a:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     61c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     620:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     622:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     624:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     628:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     62a:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     62c:	00 92 38 02 	sts	0x0238, r0	; 0x800238 <xRegTestError>
     630:	5e cf       	rjmp	.-324    	; 0x4ee <prvRegisterCheck2>

00000632 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     632:	ef 92       	push	r14
     634:	ff 92       	push	r15
     636:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     638:	e1 2c       	mov	r14, r1
     63a:	f1 2c       	mov	r15, r1
     63c:	00 e0       	ldi	r16, 0x00	; 0
     63e:	20 e0       	ldi	r18, 0x00	; 0
     640:	30 e0       	ldi	r19, 0x00	; 0
     642:	45 e5       	ldi	r20, 0x55	; 85
     644:	50 e0       	ldi	r21, 0x00	; 0
     646:	69 e4       	ldi	r22, 0x49	; 73
     648:	71 e0       	ldi	r23, 0x01	; 1
     64a:	85 ed       	ldi	r24, 0xD5	; 213
     64c:	91 e0       	ldi	r25, 0x01	; 1
     64e:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     652:	20 e0       	ldi	r18, 0x00	; 0
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	45 e5       	ldi	r20, 0x55	; 85
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	6e e4       	ldi	r22, 0x4E	; 78
     65c:	71 e0       	ldi	r23, 0x01	; 1
     65e:	87 e7       	ldi	r24, 0x77	; 119
     660:	92 e0       	ldi	r25, 0x02	; 2
     662:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
}
     666:	0f 91       	pop	r16
     668:	ff 90       	pop	r15
     66a:	ef 90       	pop	r14
     66c:	08 95       	ret

0000066e <xAreRegTestTasksStillRunning>:
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <xRegTestError>
     674:	91 11       	cpse	r25, r1
     676:	80 e0       	ldi	r24, 0x00	; 0
}
     678:	08 95       	ret

0000067a <jsmn_parse>:

/**
 * Parse JSON string and fill tokens.
 */
JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
                        jsmntok_t *tokens, const unsigned int num_tokens) {
     67a:	2f 92       	push	r2
     67c:	3f 92       	push	r3
     67e:	4f 92       	push	r4
     680:	5f 92       	push	r5
     682:	6f 92       	push	r6
     684:	7f 92       	push	r7
     686:	8f 92       	push	r8
     688:	9f 92       	push	r9
     68a:	bf 92       	push	r11
     68c:	cf 92       	push	r12
     68e:	df 92       	push	r13
     690:	ef 92       	push	r14
     692:	ff 92       	push	r15
     694:	0f 93       	push	r16
     696:	1f 93       	push	r17
     698:	cf 93       	push	r28
     69a:	df 93       	push	r29
     69c:	00 d0       	rcall	.+0      	; 0x69e <jsmn_parse+0x24>
     69e:	00 d0       	rcall	.+0      	; 0x6a0 <jsmn_parse+0x26>
     6a0:	cd b7       	in	r28, 0x3d	; 61
     6a2:	de b7       	in	r29, 0x3e	; 62
     6a4:	fc 01       	movw	r30, r24
     6a6:	1a 01       	movw	r2, r20
     6a8:	38 01       	movw	r6, r16
  int r;
  int i;
  jsmntok_t *token;
  int count = parser->toknext;
     6aa:	02 81       	ldd	r16, Z+2	; 0x02
     6ac:	13 81       	ldd	r17, Z+3	; 0x03
     6ae:	1c 83       	std	Y+4, r17	; 0x04
     6b0:	0b 83       	std	Y+3, r16	; 0x03
    case ':':
      parser->toksuper = parser->toknext - 1;
      break;
    case ',':
      if (tokens != NULL && parser->toksuper != -1 &&
          tokens[parser->toksuper].type != JSMN_ARRAY &&
     6b2:	87 e0       	ldi	r24, 0x07	; 7
     6b4:	b8 2e       	mov	r11, r24
  jsmntok_t *tok;
  if (parser->toknext >= num_tokens) {
    return NULL;
  }
  tok = &tokens[parser->toknext++];
  tok->start = tok->end = -1;
     6b6:	ee 24       	eor	r14, r14
     6b8:	ea 94       	dec	r14
     6ba:	fe 2c       	mov	r15, r14
/**
 * Fills token type and boundaries.
 */
static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
                            const int start, const int end) {
  token->type = type;
     6bc:	44 e0       	ldi	r20, 0x04	; 4
     6be:	44 2e       	mov	r4, r20
     6c0:	53 e0       	ldi	r21, 0x03	; 3
     6c2:	55 2e       	mov	r5, r21
  int r;
  int i;
  jsmntok_t *token;
  int count = parser->toknext;

  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
     6c4:	80 81       	ld	r24, Z
     6c6:	91 81       	ldd	r25, Z+1	; 0x01
     6c8:	82 15       	cp	r24, r2
     6ca:	93 05       	cpc	r25, r3
     6cc:	08 f0       	brcs	.+2      	; 0x6d0 <jsmn_parse+0x56>
     6ce:	3e c2       	rjmp	.+1148   	; 0xb4c <__stack+0x24d>
     6d0:	db 01       	movw	r26, r22
     6d2:	a8 0f       	add	r26, r24
     6d4:	b9 1f       	adc	r27, r25
     6d6:	4c 91       	ld	r20, X
     6d8:	44 23       	and	r20, r20
     6da:	09 f4       	brne	.+2      	; 0x6de <jsmn_parse+0x64>
     6dc:	37 c2       	rjmp	.+1134   	; 0xb4c <__stack+0x24d>
    char c;
    jsmntype_t type;

    c = js[parser->pos];
    switch (c) {
     6de:	4c 32       	cpi	r20, 0x2C	; 44
     6e0:	09 f4       	brne	.+2      	; 0x6e4 <jsmn_parse+0x6a>
     6e2:	73 c1       	rjmp	.+742    	; 0x9ca <__stack+0xcb>
     6e4:	bc f4       	brge	.+46     	; 0x714 <jsmn_parse+0x9a>
     6e6:	4d 30       	cpi	r20, 0x0D	; 13
     6e8:	09 f4       	brne	.+2      	; 0x6ec <jsmn_parse+0x72>
     6ea:	2a c2       	rjmp	.+1108   	; 0xb40 <__stack+0x241>
     6ec:	34 f4       	brge	.+12     	; 0x6fa <jsmn_parse+0x80>
     6ee:	a7 ef       	ldi	r26, 0xF7	; 247
     6f0:	a4 0f       	add	r26, r20
     6f2:	a2 30       	cpi	r26, 0x02	; 2
     6f4:	08 f4       	brcc	.+2      	; 0x6f8 <jsmn_parse+0x7e>
     6f6:	24 c2       	rjmp	.+1096   	; 0xb40 <__stack+0x241>
     6f8:	bc c1       	rjmp	.+888    	; 0xa72 <__stack+0x173>
     6fa:	40 32       	cpi	r20, 0x20	; 32
     6fc:	09 f4       	brne	.+2      	; 0x700 <jsmn_parse+0x86>
     6fe:	20 c2       	rjmp	.+1088   	; 0xb40 <__stack+0x241>
     700:	42 32       	cpi	r20, 0x22	; 34
     702:	09 f0       	breq	.+2      	; 0x706 <jsmn_parse+0x8c>
     704:	b6 c1       	rjmp	.+876    	; 0xa72 <__stack+0x173>
                             const size_t num_tokens) {
  jsmntok_t *token;

  int start = parser->pos;

  parser->pos++;
     706:	4c 01       	movw	r8, r24
     708:	af ef       	ldi	r26, 0xFF	; 255
     70a:	8a 1a       	sub	r8, r26
     70c:	9a 0a       	sbc	r9, r26
     70e:	91 82       	std	Z+1, r9	; 0x01
     710:	80 82       	st	Z, r8
     712:	cd c0       	rjmp	.+410    	; 0x8ae <jsmn_parse+0x234>
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
    char c;
    jsmntype_t type;

    c = js[parser->pos];
    switch (c) {
     714:	4d 35       	cpi	r20, 0x5D	; 93
     716:	09 f4       	brne	.+2      	; 0x71a <jsmn_parse+0xa0>
     718:	61 c0       	rjmp	.+194    	; 0x7dc <jsmn_parse+0x162>
     71a:	34 f4       	brge	.+12     	; 0x728 <jsmn_parse+0xae>
     71c:	4a 33       	cpi	r20, 0x3A	; 58
     71e:	09 f4       	brne	.+2      	; 0x722 <jsmn_parse+0xa8>
     720:	50 c1       	rjmp	.+672    	; 0x9c2 <__stack+0xc3>
     722:	4b 35       	cpi	r20, 0x5B	; 91
     724:	39 f0       	breq	.+14     	; 0x734 <jsmn_parse+0xba>
     726:	a5 c1       	rjmp	.+842    	; 0xa72 <__stack+0x173>
     728:	4b 37       	cpi	r20, 0x7B	; 123
     72a:	21 f0       	breq	.+8      	; 0x734 <jsmn_parse+0xba>
     72c:	4d 37       	cpi	r20, 0x7D	; 125
     72e:	09 f4       	brne	.+2      	; 0x732 <jsmn_parse+0xb8>
     730:	55 c0       	rjmp	.+170    	; 0x7dc <jsmn_parse+0x162>
     732:	9f c1       	rjmp	.+830    	; 0xa72 <__stack+0x173>
    case '{':
    case '[':
      count++;
     734:	ab 81       	ldd	r26, Y+3	; 0x03
     736:	bc 81       	ldd	r27, Y+4	; 0x04
     738:	11 96       	adiw	r26, 0x01	; 1
     73a:	bc 83       	std	Y+4, r27	; 0x04
     73c:	ab 83       	std	Y+3, r26	; 0x03
      if (tokens == NULL) {
     73e:	21 15       	cp	r18, r1
     740:	31 05       	cpc	r19, r1
     742:	09 f4       	brne	.+2      	; 0x746 <jsmn_parse+0xcc>
     744:	fd c1       	rjmp	.+1018   	; 0xb40 <__stack+0x241>
 * Allocates a fresh unused token from the token pool.
 */
static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
                                   const size_t num_tokens) {
  jsmntok_t *tok;
  if (parser->toknext >= num_tokens) {
     746:	82 80       	ldd	r8, Z+2	; 0x02
     748:	93 80       	ldd	r9, Z+3	; 0x03
     74a:	86 14       	cp	r8, r6
     74c:	97 04       	cpc	r9, r7
     74e:	08 f0       	brcs	.+2      	; 0x752 <jsmn_parse+0xd8>
     750:	af c1       	rjmp	.+862    	; 0xab0 <__stack+0x1b1>
    return NULL;
  }
  tok = &tokens[parser->toknext++];
     752:	d4 01       	movw	r26, r8
     754:	11 96       	adiw	r26, 0x01	; 1
     756:	b3 83       	std	Z+3, r27	; 0x03
     758:	a2 83       	std	Z+2, r26	; 0x02
     75a:	b8 9c       	mul	r11, r8
     75c:	d0 01       	movw	r26, r0
     75e:	b9 9c       	mul	r11, r9
     760:	b0 0d       	add	r27, r0
     762:	11 24       	eor	r1, r1
     764:	8d 01       	movw	r16, r26
     766:	02 0f       	add	r16, r18
     768:	13 1f       	adc	r17, r19
     76a:	1a 83       	std	Y+2, r17	; 0x02
     76c:	09 83       	std	Y+1, r16	; 0x01
  tok->start = tok->end = -1;
     76e:	d8 01       	movw	r26, r16
     770:	14 96       	adiw	r26, 0x04	; 4
     772:	fc 92       	st	X, r15
     774:	ee 92       	st	-X, r14
     776:	13 97       	sbiw	r26, 0x03	; 3
     778:	12 96       	adiw	r26, 0x02	; 2
     77a:	fc 92       	st	X, r15
     77c:	ee 92       	st	-X, r14
     77e:	11 97       	sbiw	r26, 0x01	; 1
  tok->size = 0;
     780:	16 96       	adiw	r26, 0x06	; 6
     782:	1c 92       	st	X, r1
     784:	1e 92       	st	-X, r1
     786:	15 97       	sbiw	r26, 0x05	; 5
      count++;
      if (tokens == NULL) {
        break;
      }
      token = jsmn_alloc_token(parser, tokens, num_tokens);
      if (token == NULL) {
     788:	ab 2b       	or	r26, r27
     78a:	09 f4       	brne	.+2      	; 0x78e <jsmn_parse+0x114>
     78c:	91 c1       	rjmp	.+802    	; 0xab0 <__stack+0x1b1>
        return JSMN_ERROR_NOMEM;
      }
      if (parser->toksuper != -1) {
     78e:	04 81       	ldd	r16, Z+4	; 0x04
     790:	15 81       	ldd	r17, Z+5	; 0x05
     792:	0f 3f       	cpi	r16, 0xFF	; 255
     794:	bf ef       	ldi	r27, 0xFF	; 255
     796:	1b 07       	cpc	r17, r27
     798:	91 f0       	breq	.+36     	; 0x7be <jsmn_parse+0x144>
        jsmntok_t *t = &tokens[parser->toksuper];
     79a:	b0 9e       	mul	r11, r16
     79c:	60 01       	movw	r12, r0
     79e:	b1 9e       	mul	r11, r17
     7a0:	d0 0c       	add	r13, r0
     7a2:	11 24       	eor	r1, r1
     7a4:	c2 0e       	add	r12, r18
     7a6:	d3 1e       	adc	r13, r19
        /* In strict mode an object or array can't become a key */
        if (t->type == JSMN_OBJECT) {
          return JSMN_ERROR_INVAL;
        }
#endif
        t->size++;
     7a8:	d6 01       	movw	r26, r12
     7aa:	15 96       	adiw	r26, 0x05	; 5
     7ac:	0d 91       	ld	r16, X+
     7ae:	1c 91       	ld	r17, X
     7b0:	16 97       	sbiw	r26, 0x06	; 6
     7b2:	0f 5f       	subi	r16, 0xFF	; 255
     7b4:	1f 4f       	sbci	r17, 0xFF	; 255
     7b6:	16 96       	adiw	r26, 0x06	; 6
     7b8:	1c 93       	st	X, r17
     7ba:	0e 93       	st	-X, r16
     7bc:	15 97       	sbiw	r26, 0x05	; 5
#ifdef JSMN_PARENT_LINKS
        token->parent = parser->toksuper;
#endif
      }
      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
     7be:	4b 37       	cpi	r20, 0x7B	; 123
     7c0:	11 f4       	brne	.+4      	; 0x7c6 <jsmn_parse+0x14c>
     7c2:	11 e0       	ldi	r17, 0x01	; 1
     7c4:	01 c0       	rjmp	.+2      	; 0x7c8 <jsmn_parse+0x14e>
     7c6:	12 e0       	ldi	r17, 0x02	; 2
     7c8:	a9 81       	ldd	r26, Y+1	; 0x01
     7ca:	ba 81       	ldd	r27, Y+2	; 0x02
     7cc:	1c 93       	st	X, r17
      token->start = parser->pos;
     7ce:	12 96       	adiw	r26, 0x02	; 2
     7d0:	9c 93       	st	X, r25
     7d2:	8e 93       	st	-X, r24
     7d4:	11 97       	sbiw	r26, 0x01	; 1
      parser->toksuper = parser->toknext - 1;
     7d6:	95 82       	std	Z+5, r9	; 0x05
     7d8:	84 82       	std	Z+4, r8	; 0x04
      break;
     7da:	b2 c1       	rjmp	.+868    	; 0xb40 <__stack+0x241>
    case '}':
    case ']':
      if (tokens == NULL) {
     7dc:	21 15       	cp	r18, r1
     7de:	31 05       	cpc	r19, r1
     7e0:	09 f4       	brne	.+2      	; 0x7e4 <jsmn_parse+0x16a>
     7e2:	ae c1       	rjmp	.+860    	; 0xb40 <__stack+0x241>
        break;
      }
      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
     7e4:	4d 37       	cpi	r20, 0x7D	; 125
     7e6:	11 f4       	brne	.+4      	; 0x7ec <jsmn_parse+0x172>
     7e8:	41 e0       	ldi	r20, 0x01	; 1
     7ea:	01 c0       	rjmp	.+2      	; 0x7ee <jsmn_parse+0x174>
     7ec:	42 e0       	ldi	r20, 0x02	; 2
          break;
        }
        token = &tokens[token->parent];
      }
#else
      for (i = parser->toknext - 1; i >= 0; i--) {
     7ee:	c2 80       	ldd	r12, Z+2	; 0x02
     7f0:	d3 80       	ldd	r13, Z+3	; 0x03
     7f2:	86 01       	movw	r16, r12
     7f4:	01 50       	subi	r16, 0x01	; 1
     7f6:	11 09       	sbc	r17, r1
     7f8:	bc 9c       	mul	r11, r12
     7fa:	d0 01       	movw	r26, r0
     7fc:	bd 9c       	mul	r11, r13
     7fe:	b0 0d       	add	r27, r0
     800:	11 24       	eor	r1, r1
     802:	17 97       	sbiw	r26, 0x07	; 7
     804:	a2 0f       	add	r26, r18
     806:	b3 1f       	adc	r27, r19
     808:	17 fd       	sbrc	r17, 7
     80a:	25 c0       	rjmp	.+74     	; 0x856 <jsmn_parse+0x1dc>
        token = &tokens[i];
        if (token->start != -1 && token->end == -1) {
     80c:	11 96       	adiw	r26, 0x01	; 1
     80e:	cd 90       	ld	r12, X+
     810:	dc 90       	ld	r13, X
     812:	12 97       	sbiw	r26, 0x02	; 2
     814:	cd 20       	and	r12, r13
     816:	c0 94       	com	r12
     818:	d1 f0       	breq	.+52     	; 0x84e <jsmn_parse+0x1d4>
     81a:	13 96       	adiw	r26, 0x03	; 3
     81c:	cd 90       	ld	r12, X+
     81e:	dc 90       	ld	r13, X
     820:	14 97       	sbiw	r26, 0x04	; 4
     822:	5f ef       	ldi	r21, 0xFF	; 255
     824:	c5 16       	cp	r12, r21
     826:	d5 06       	cpc	r13, r21
     828:	91 f4       	brne	.+36     	; 0x84e <jsmn_parse+0x1d4>
          if (token->type != type) {
     82a:	9c 90       	ld	r9, X
     82c:	49 11       	cpse	r20, r9
     82e:	ad c1       	rjmp	.+858    	; 0xb8a <__stack+0x28b>
            return JSMN_ERROR_INVAL;
          }
          parser->toksuper = -1;
     830:	d5 82       	std	Z+5, r13	; 0x05
     832:	c4 82       	std	Z+4, r12	; 0x04
          token->end = parser->pos + 1;
     834:	01 96       	adiw	r24, 0x01	; 1
     836:	14 96       	adiw	r26, 0x04	; 4
     838:	9c 93       	st	X, r25
     83a:	8e 93       	st	-X, r24
     83c:	13 97       	sbiw	r26, 0x03	; 3
     83e:	b0 9e       	mul	r11, r16
     840:	d0 01       	movw	r26, r0
     842:	b1 9e       	mul	r11, r17
     844:	b0 0d       	add	r27, r0
     846:	11 24       	eor	r1, r1
     848:	a2 0f       	add	r26, r18
     84a:	b3 1f       	adc	r27, r19
     84c:	11 c0       	rjmp	.+34     	; 0x870 <jsmn_parse+0x1f6>
          break;
        }
        token = &tokens[token->parent];
      }
#else
      for (i = parser->toknext - 1; i >= 0; i--) {
     84e:	01 50       	subi	r16, 0x01	; 1
     850:	11 09       	sbc	r17, r1
     852:	17 97       	sbiw	r26, 0x07	; 7
     854:	d9 cf       	rjmp	.-78     	; 0x808 <jsmn_parse+0x18e>
          token->end = parser->pos + 1;
          break;
        }
      }
      /* Error if unmatched closing bracket */
      if (i == -1) {
     856:	0f 3f       	cpi	r16, 0xFF	; 255
     858:	1f 4f       	sbci	r17, 0xFF	; 255
     85a:	09 f0       	breq	.+2      	; 0x85e <jsmn_parse+0x1e4>
     85c:	71 c1       	rjmp	.+738    	; 0xb40 <__stack+0x241>
     85e:	95 c1       	rjmp	.+810    	; 0xb8a <__stack+0x28b>
        return JSMN_ERROR_INVAL;
      }
      for (; i >= 0; i--) {
     860:	01 50       	subi	r16, 0x01	; 1
     862:	11 09       	sbc	r17, r1
     864:	17 97       	sbiw	r26, 0x07	; 7
     866:	0f 3f       	cpi	r16, 0xFF	; 255
     868:	8f ef       	ldi	r24, 0xFF	; 255
     86a:	18 07       	cpc	r17, r24
     86c:	09 f4       	brne	.+2      	; 0x870 <jsmn_parse+0x1f6>
     86e:	68 c1       	rjmp	.+720    	; 0xb40 <__stack+0x241>
        token = &tokens[i];
        if (token->start != -1 && token->end == -1) {
     870:	11 96       	adiw	r26, 0x01	; 1
     872:	8d 91       	ld	r24, X+
     874:	9c 91       	ld	r25, X
     876:	12 97       	sbiw	r26, 0x02	; 2
     878:	01 96       	adiw	r24, 0x01	; 1
     87a:	91 f3       	breq	.-28     	; 0x860 <jsmn_parse+0x1e6>
     87c:	13 96       	adiw	r26, 0x03	; 3
     87e:	8d 91       	ld	r24, X+
     880:	9c 91       	ld	r25, X
     882:	14 97       	sbiw	r26, 0x04	; 4
     884:	01 96       	adiw	r24, 0x01	; 1
     886:	61 f7       	brne	.-40     	; 0x860 <jsmn_parse+0x1e6>
          parser->toksuper = i;
     888:	15 83       	std	Z+5, r17	; 0x05
     88a:	04 83       	std	Z+4, r16	; 0x04
          break;
     88c:	59 c1       	rjmp	.+690    	; 0xb40 <__stack+0x241>
  int start = parser->pos;

  parser->pos++;

  /* Skip starting quote */
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
     88e:	db 01       	movw	r26, r22
     890:	a0 0f       	add	r26, r16
     892:	b1 1f       	adc	r27, r17
     894:	ac 91       	ld	r26, X
     896:	aa 23       	and	r26, r26
     898:	09 f4       	brne	.+2      	; 0x89c <jsmn_parse+0x222>
     89a:	90 c0       	rjmp	.+288    	; 0x9bc <__stack+0xbd>
    char c = js[parser->pos];

    /* Quote: end of string */
    if (c == '\"') {
     89c:	a2 32       	cpi	r26, 0x22	; 34
     89e:	69 f0       	breq	.+26     	; 0x8ba <jsmn_parse+0x240>
#endif
      return 0;
    }

    /* Backslash: Quoted symbol expected */
    if (c == '\\' && parser->pos + 1 < len) {
     8a0:	ac 35       	cpi	r26, 0x5C	; 92
     8a2:	c9 f1       	breq	.+114    	; 0x916 <__stack+0x17>
  int start = parser->pos;

  parser->pos++;

  /* Skip starting quote */
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
     8a4:	a0 81       	ld	r26, Z
     8a6:	b1 81       	ldd	r27, Z+1	; 0x01
     8a8:	11 96       	adiw	r26, 0x01	; 1
     8aa:	b1 83       	std	Z+1, r27	; 0x01
     8ac:	a0 83       	st	Z, r26
     8ae:	00 81       	ld	r16, Z
     8b0:	11 81       	ldd	r17, Z+1	; 0x01
     8b2:	02 15       	cp	r16, r2
     8b4:	13 05       	cpc	r17, r3
     8b6:	58 f3       	brcs	.-42     	; 0x88e <jsmn_parse+0x214>
     8b8:	81 c0       	rjmp	.+258    	; 0x9bc <__stack+0xbd>
    char c = js[parser->pos];

    /* Quote: end of string */
    if (c == '\"') {
      if (tokens == NULL) {
     8ba:	21 15       	cp	r18, r1
     8bc:	31 05       	cpc	r19, r1
     8be:	09 f4       	brne	.+2      	; 0x8c2 <jsmn_parse+0x248>
     8c0:	6c c1       	rjmp	.+728    	; 0xb9a <__stack+0x29b>
 * Allocates a fresh unused token from the token pool.
 */
static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
                                   const size_t num_tokens) {
  jsmntok_t *tok;
  if (parser->toknext >= num_tokens) {
     8c2:	c2 80       	ldd	r12, Z+2	; 0x02
     8c4:	d3 80       	ldd	r13, Z+3	; 0x03
     8c6:	c6 14       	cp	r12, r6
     8c8:	d7 04       	cpc	r13, r7
     8ca:	08 f0       	brcs	.+2      	; 0x8ce <jsmn_parse+0x254>
     8cc:	ef c0       	rjmp	.+478    	; 0xaac <__stack+0x1ad>
    return NULL;
  }
  tok = &tokens[parser->toknext++];
     8ce:	d6 01       	movw	r26, r12
     8d0:	11 96       	adiw	r26, 0x01	; 1
     8d2:	b3 83       	std	Z+3, r27	; 0x03
     8d4:	a2 83       	std	Z+2, r26	; 0x02
     8d6:	bc 9c       	mul	r11, r12
     8d8:	d0 01       	movw	r26, r0
     8da:	bd 9c       	mul	r11, r13
     8dc:	b0 0d       	add	r27, r0
     8de:	11 24       	eor	r1, r1
     8e0:	a2 0f       	add	r26, r18
     8e2:	b3 1f       	adc	r27, r19
  tok->start = tok->end = -1;
     8e4:	14 96       	adiw	r26, 0x04	; 4
     8e6:	fc 92       	st	X, r15
     8e8:	ee 92       	st	-X, r14
     8ea:	13 97       	sbiw	r26, 0x03	; 3
     8ec:	12 96       	adiw	r26, 0x02	; 2
     8ee:	fc 92       	st	X, r15
     8f0:	ee 92       	st	-X, r14
     8f2:	11 97       	sbiw	r26, 0x01	; 1
  tok->size = 0;
     8f4:	16 96       	adiw	r26, 0x06	; 6
     8f6:	1c 92       	st	X, r1
     8f8:	1e 92       	st	-X, r1
     8fa:	15 97       	sbiw	r26, 0x05	; 5
    if (c == '\"') {
      if (tokens == NULL) {
        return 0;
      }
      token = jsmn_alloc_token(parser, tokens, num_tokens);
      if (token == NULL) {
     8fc:	10 97       	sbiw	r26, 0x00	; 0
     8fe:	09 f4       	brne	.+2      	; 0x902 <__stack+0x3>
     900:	d5 c0       	rjmp	.+426    	; 0xaac <__stack+0x1ad>
/**
 * Fills token type and boundaries.
 */
static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
                            const int start, const int end) {
  token->type = type;
     902:	5c 92       	st	X, r5
  token->start = start;
     904:	12 96       	adiw	r26, 0x02	; 2
     906:	9c 92       	st	X, r9
     908:	8e 92       	st	-X, r8
     90a:	11 97       	sbiw	r26, 0x01	; 1
  token->end = end;
     90c:	14 96       	adiw	r26, 0x04	; 4
     90e:	1c 93       	st	X, r17
     910:	0e 93       	st	-X, r16
     912:	13 97       	sbiw	r26, 0x03	; 3
     914:	42 c1       	rjmp	.+644    	; 0xb9a <__stack+0x29b>
#endif
      return 0;
    }

    /* Backslash: Quoted symbol expected */
    if (c == '\\' && parser->pos + 1 < len) {
     916:	d8 01       	movw	r26, r16
     918:	11 96       	adiw	r26, 0x01	; 1
     91a:	a2 15       	cp	r26, r2
     91c:	b3 05       	cpc	r27, r3
     91e:	10 f6       	brcc	.-124    	; 0x8a4 <jsmn_parse+0x22a>
      int i;
      parser->pos++;
     920:	b1 83       	std	Z+1, r27	; 0x01
     922:	a0 83       	st	Z, r26
      switch (js[parser->pos]) {
     924:	a6 0f       	add	r26, r22
     926:	b7 1f       	adc	r27, r23
     928:	ac 91       	ld	r26, X
     92a:	a6 36       	cpi	r26, 0x66	; 102
     92c:	09 f4       	brne	.+2      	; 0x930 <__stack+0x31>
     92e:	ba cf       	rjmp	.-140    	; 0x8a4 <jsmn_parse+0x22a>
     930:	7c f4       	brge	.+30     	; 0x950 <__stack+0x51>
     932:	af 32       	cpi	r26, 0x2F	; 47
     934:	09 f4       	brne	.+2      	; 0x938 <__stack+0x39>
     936:	b6 cf       	rjmp	.-148    	; 0x8a4 <jsmn_parse+0x22a>
     938:	24 f4       	brge	.+8      	; 0x942 <__stack+0x43>
     93a:	a2 32       	cpi	r26, 0x22	; 34
     93c:	09 f0       	breq	.+2      	; 0x940 <__stack+0x41>
     93e:	83 c0       	rjmp	.+262    	; 0xa46 <__stack+0x147>
     940:	b1 cf       	rjmp	.-158    	; 0x8a4 <jsmn_parse+0x22a>
     942:	ac 35       	cpi	r26, 0x5C	; 92
     944:	09 f4       	brne	.+2      	; 0x948 <__stack+0x49>
     946:	ae cf       	rjmp	.-164    	; 0x8a4 <jsmn_parse+0x22a>
     948:	a2 36       	cpi	r26, 0x62	; 98
     94a:	09 f0       	breq	.+2      	; 0x94e <__stack+0x4f>
     94c:	7c c0       	rjmp	.+248    	; 0xa46 <__stack+0x147>
     94e:	aa cf       	rjmp	.-172    	; 0x8a4 <jsmn_parse+0x22a>
     950:	a2 37       	cpi	r26, 0x72	; 114
     952:	09 f4       	brne	.+2      	; 0x956 <__stack+0x57>
     954:	a7 cf       	rjmp	.-178    	; 0x8a4 <jsmn_parse+0x22a>
     956:	24 f4       	brge	.+8      	; 0x960 <__stack+0x61>
     958:	ae 36       	cpi	r26, 0x6E	; 110
     95a:	09 f0       	breq	.+2      	; 0x95e <__stack+0x5f>
     95c:	74 c0       	rjmp	.+232    	; 0xa46 <__stack+0x147>
     95e:	a2 cf       	rjmp	.-188    	; 0x8a4 <jsmn_parse+0x22a>
     960:	a4 37       	cpi	r26, 0x74	; 116
     962:	09 f4       	brne	.+2      	; 0x966 <__stack+0x67>
     964:	9f cf       	rjmp	.-194    	; 0x8a4 <jsmn_parse+0x22a>
     966:	a5 37       	cpi	r26, 0x75	; 117
     968:	09 f0       	breq	.+2      	; 0x96c <__stack+0x6d>
     96a:	6d c0       	rjmp	.+218    	; 0xa46 <__stack+0x147>
      case 'n':
      case 't':
        break;
      /* Allows escaped symbol \uXXXX */
      case 'u':
        parser->pos++;
     96c:	0e 5f       	subi	r16, 0xFE	; 254
     96e:	1f 4f       	sbci	r17, 0xFF	; 255
     970:	11 83       	std	Z+1, r17	; 0x01
     972:	00 83       	st	Z, r16
     974:	04 e0       	ldi	r16, 0x04	; 4
     976:	10 e0       	ldi	r17, 0x00	; 0
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
     978:	c0 80       	ld	r12, Z
     97a:	d1 80       	ldd	r13, Z+1	; 0x01
     97c:	c2 14       	cp	r12, r2
     97e:	d3 04       	cpc	r13, r3
     980:	30 f0       	brcs	.+12     	; 0x98e <__stack+0x8f>
            parser->pos = start;
            return JSMN_ERROR_INVAL;
          }
          parser->pos++;
        }
        parser->pos--;
     982:	a0 81       	ld	r26, Z
     984:	b1 81       	ldd	r27, Z+1	; 0x01
     986:	11 97       	sbiw	r26, 0x01	; 1
     988:	b1 83       	std	Z+1, r27	; 0x01
     98a:	a0 83       	st	Z, r26
     98c:	8b cf       	rjmp	.-234    	; 0x8a4 <jsmn_parse+0x22a>
      case 't':
        break;
      /* Allows escaped symbol \uXXXX */
      case 'u':
        parser->pos++;
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
     98e:	db 01       	movw	r26, r22
     990:	ac 0d       	add	r26, r12
     992:	bd 1d       	adc	r27, r13
     994:	ac 91       	ld	r26, X
     996:	aa 23       	and	r26, r26
     998:	a1 f3       	breq	.-24     	; 0x982 <__stack+0x83>
             i++) {
          /* If it isn't a hex character we have an error */
          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
     99a:	b0 ed       	ldi	r27, 0xD0	; 208
     99c:	ba 0f       	add	r27, r26
     99e:	ba 30       	cpi	r27, 0x0A	; 10
     9a0:	28 f0       	brcs	.+10     	; 0x9ac <__stack+0xad>
     9a2:	af 7d       	andi	r26, 0xDF	; 223
     9a4:	a1 54       	subi	r26, 0x41	; 65
     9a6:	a6 30       	cpi	r26, 0x06	; 6
     9a8:	08 f0       	brcs	.+2      	; 0x9ac <__stack+0xad>
     9aa:	4d c0       	rjmp	.+154    	; 0xa46 <__stack+0x147>
                (js[parser->pos] >= 65 && js[parser->pos] <= 70) ||   /* A-F */
                (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
            parser->pos = start;
            return JSMN_ERROR_INVAL;
          }
          parser->pos++;
     9ac:	d6 01       	movw	r26, r12
     9ae:	11 96       	adiw	r26, 0x01	; 1
     9b0:	b1 83       	std	Z+1, r27	; 0x01
     9b2:	a0 83       	st	Z, r26
     9b4:	01 50       	subi	r16, 0x01	; 1
     9b6:	11 09       	sbc	r17, r1
      case 't':
        break;
      /* Allows escaped symbol \uXXXX */
      case 'u':
        parser->pos++;
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
     9b8:	f9 f6       	brne	.-66     	; 0x978 <__stack+0x79>
     9ba:	e3 cf       	rjmp	.-58     	; 0x982 <__stack+0x83>
        parser->pos = start;
        return JSMN_ERROR_INVAL;
      }
    }
  }
  parser->pos = start;
     9bc:	91 83       	std	Z+1, r25	; 0x01
     9be:	80 83       	st	Z, r24
     9c0:	e9 c0       	rjmp	.+466    	; 0xb94 <__stack+0x295>
    case '\r':
    case '\n':
    case ' ':
      break;
    case ':':
      parser->toksuper = parser->toknext - 1;
     9c2:	82 81       	ldd	r24, Z+2	; 0x02
     9c4:	93 81       	ldd	r25, Z+3	; 0x03
     9c6:	01 97       	sbiw	r24, 0x01	; 1
     9c8:	3b c0       	rjmp	.+118    	; 0xa40 <__stack+0x141>
      break;
    case ',':
      if (tokens != NULL && parser->toksuper != -1 &&
     9ca:	21 15       	cp	r18, r1
     9cc:	31 05       	cpc	r19, r1
     9ce:	09 f4       	brne	.+2      	; 0x9d2 <__stack+0xd3>
     9d0:	b7 c0       	rjmp	.+366    	; 0xb40 <__stack+0x241>
     9d2:	a4 81       	ldd	r26, Z+4	; 0x04
     9d4:	b5 81       	ldd	r27, Z+5	; 0x05
     9d6:	af 3f       	cpi	r26, 0xFF	; 255
     9d8:	0f ef       	ldi	r16, 0xFF	; 255
     9da:	b0 07       	cpc	r27, r16
     9dc:	09 f4       	brne	.+2      	; 0x9e0 <__stack+0xe1>
     9de:	b0 c0       	rjmp	.+352    	; 0xb40 <__stack+0x241>
          tokens[parser->toksuper].type != JSMN_ARRAY &&
     9e0:	ba 9e       	mul	r11, r26
     9e2:	c0 01       	movw	r24, r0
     9e4:	bb 9e       	mul	r11, r27
     9e6:	90 0d       	add	r25, r0
     9e8:	11 24       	eor	r1, r1
     9ea:	d9 01       	movw	r26, r18
     9ec:	a8 0f       	add	r26, r24
     9ee:	b9 1f       	adc	r27, r25
     9f0:	8c 91       	ld	r24, X
     9f2:	81 50       	subi	r24, 0x01	; 1
     9f4:	82 30       	cpi	r24, 0x02	; 2
     9f6:	08 f4       	brcc	.+2      	; 0x9fa <__stack+0xfb>
     9f8:	a3 c0       	rjmp	.+326    	; 0xb40 <__stack+0x241>
          tokens[parser->toksuper].type != JSMN_OBJECT) {
#ifdef JSMN_PARENT_LINKS
        parser->toksuper = tokens[parser->toksuper].parent;
#else
        for (i = parser->toknext - 1; i >= 0; i--) {
     9fa:	02 81       	ldd	r16, Z+2	; 0x02
     9fc:	13 81       	ldd	r17, Z+3	; 0x03
     9fe:	c8 01       	movw	r24, r16
     a00:	01 97       	sbiw	r24, 0x01	; 1
     a02:	b0 9e       	mul	r11, r16
     a04:	d0 01       	movw	r26, r0
     a06:	b1 9e       	mul	r11, r17
     a08:	b0 0d       	add	r27, r0
     a0a:	11 24       	eor	r1, r1
     a0c:	17 97       	sbiw	r26, 0x07	; 7
     a0e:	a2 0f       	add	r26, r18
     a10:	b3 1f       	adc	r27, r19
     a12:	02 c0       	rjmp	.+4      	; 0xa18 <__stack+0x119>
     a14:	01 97       	sbiw	r24, 0x01	; 1
     a16:	17 97       	sbiw	r26, 0x07	; 7
     a18:	97 fd       	sbrc	r25, 7
     a1a:	92 c0       	rjmp	.+292    	; 0xb40 <__stack+0x241>
          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
     a1c:	1c 91       	ld	r17, X
     a1e:	11 50       	subi	r17, 0x01	; 1
     a20:	12 30       	cpi	r17, 0x02	; 2
     a22:	c0 f7       	brcc	.-16     	; 0xa14 <__stack+0x115>
            if (tokens[i].start != -1 && tokens[i].end == -1) {
     a24:	11 96       	adiw	r26, 0x01	; 1
     a26:	0d 91       	ld	r16, X+
     a28:	1c 91       	ld	r17, X
     a2a:	12 97       	sbiw	r26, 0x02	; 2
     a2c:	0f 3f       	cpi	r16, 0xFF	; 255
     a2e:	1f 4f       	sbci	r17, 0xFF	; 255
     a30:	89 f3       	breq	.-30     	; 0xa14 <__stack+0x115>
     a32:	13 96       	adiw	r26, 0x03	; 3
     a34:	0d 91       	ld	r16, X+
     a36:	1c 91       	ld	r17, X
     a38:	14 97       	sbiw	r26, 0x04	; 4
     a3a:	0f 3f       	cpi	r16, 0xFF	; 255
     a3c:	1f 4f       	sbci	r17, 0xFF	; 255
     a3e:	51 f7       	brne	.-44     	; 0xa14 <__stack+0x115>
              parser->toksuper = i;
     a40:	95 83       	std	Z+5, r25	; 0x05
     a42:	84 83       	std	Z+4, r24	; 0x04
              break;
     a44:	7d c0       	rjmp	.+250    	; 0xb40 <__stack+0x241>
    default:
                   /* to quiet a warning from gcc*/
      break;
    }
    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
      parser->pos = start;
     a46:	91 83       	std	Z+1, r25	; 0x01
     a48:	80 83       	st	Z, r24
     a4a:	9f c0       	rjmp	.+318    	; 0xb8a <__stack+0x28b>
  jsmntok_t *token;
  int start;

  start = parser->pos;

  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
     a4c:	8b 01       	movw	r16, r22
     a4e:	04 0f       	add	r16, r20
     a50:	15 1f       	adc	r17, r21
     a52:	d8 01       	movw	r26, r16
     a54:	1c 91       	ld	r17, X
     a56:	11 23       	and	r17, r17
     a58:	09 f1       	breq	.+66     	; 0xa9c <__stack+0x19d>
    switch (js[parser->pos]) {
     a5a:	10 32       	cpi	r17, 0x20	; 32
     a5c:	f9 f0       	breq	.+62     	; 0xa9c <__stack+0x19d>
     a5e:	a4 f4       	brge	.+40     	; 0xa88 <__stack+0x189>
     a60:	19 30       	cpi	r17, 0x09	; 9
     a62:	6c f4       	brge	.+26     	; 0xa7e <__stack+0x17f>
      goto found;
    default:
                   /* to quiet a warning from gcc*/
      break;
    }
    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
     a64:	10 52       	subi	r17, 0x20	; 32
     a66:	1f 35       	cpi	r17, 0x5F	; 95
     a68:	70 f7       	brcc	.-36     	; 0xa46 <__stack+0x147>
  jsmntok_t *token;
  int start;

  start = parser->pos;

  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
     a6a:	da 01       	movw	r26, r20
     a6c:	11 96       	adiw	r26, 0x01	; 1
     a6e:	b1 83       	std	Z+1, r27	; 0x01
     a70:	a0 83       	st	Z, r26
     a72:	40 81       	ld	r20, Z
     a74:	51 81       	ldd	r21, Z+1	; 0x01
     a76:	42 15       	cp	r20, r2
     a78:	53 05       	cpc	r21, r3
     a7a:	40 f3       	brcs	.-48     	; 0xa4c <__stack+0x14d>
     a7c:	0f c0       	rjmp	.+30     	; 0xa9c <__stack+0x19d>
    switch (js[parser->pos]) {
     a7e:	1b 30       	cpi	r17, 0x0B	; 11
     a80:	6c f0       	brlt	.+26     	; 0xa9c <__stack+0x19d>
     a82:	1d 30       	cpi	r17, 0x0D	; 13
     a84:	79 f7       	brne	.-34     	; 0xa64 <__stack+0x165>
     a86:	0a c0       	rjmp	.+20     	; 0xa9c <__stack+0x19d>
     a88:	1a 33       	cpi	r17, 0x3A	; 58
     a8a:	41 f0       	breq	.+16     	; 0xa9c <__stack+0x19d>
     a8c:	1c f4       	brge	.+6      	; 0xa94 <__stack+0x195>
     a8e:	1c 32       	cpi	r17, 0x2C	; 44
     a90:	49 f7       	brne	.-46     	; 0xa64 <__stack+0x165>
     a92:	04 c0       	rjmp	.+8      	; 0xa9c <__stack+0x19d>
     a94:	1d 35       	cpi	r17, 0x5D	; 93
     a96:	11 f0       	breq	.+4      	; 0xa9c <__stack+0x19d>
     a98:	1d 37       	cpi	r17, 0x7D	; 125
     a9a:	21 f7       	brne	.-56     	; 0xa64 <__stack+0x165>
  parser->pos = start;
  return JSMN_ERROR_PART;
#endif

found:
  if (tokens == NULL) {
     a9c:	21 15       	cp	r18, r1
     a9e:	31 05       	cpc	r19, r1
     aa0:	69 f1       	breq	.+90     	; 0xafc <__stack+0x1fd>
 * Allocates a fresh unused token from the token pool.
 */
static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
                                   const size_t num_tokens) {
  jsmntok_t *tok;
  if (parser->toknext >= num_tokens) {
     aa2:	c2 80       	ldd	r12, Z+2	; 0x02
     aa4:	d3 80       	ldd	r13, Z+3	; 0x03
     aa6:	c6 14       	cp	r12, r6
     aa8:	d7 04       	cpc	r13, r7
     aaa:	20 f0       	brcs	.+8      	; 0xab4 <__stack+0x1b5>
    parser->pos--;
    return 0;
  }
  token = jsmn_alloc_token(parser, tokens, num_tokens);
  if (token == NULL) {
    parser->pos = start;
     aac:	91 83       	std	Z+1, r25	; 0x01
     aae:	80 83       	st	Z, r24
    return JSMN_ERROR_NOMEM;
     ab0:	8f ef       	ldi	r24, 0xFF	; 255
     ab2:	71 c0       	rjmp	.+226    	; 0xb96 <__stack+0x297>
                                   const size_t num_tokens) {
  jsmntok_t *tok;
  if (parser->toknext >= num_tokens) {
    return NULL;
  }
  tok = &tokens[parser->toknext++];
     ab4:	86 01       	movw	r16, r12
     ab6:	0f 5f       	subi	r16, 0xFF	; 255
     ab8:	1f 4f       	sbci	r17, 0xFF	; 255
     aba:	13 83       	std	Z+3, r17	; 0x03
     abc:	02 83       	std	Z+2, r16	; 0x02
     abe:	bc 9c       	mul	r11, r12
     ac0:	80 01       	movw	r16, r0
     ac2:	bd 9c       	mul	r11, r13
     ac4:	10 0d       	add	r17, r0
     ac6:	11 24       	eor	r1, r1
     ac8:	02 0f       	add	r16, r18
     aca:	13 1f       	adc	r17, r19
  tok->start = tok->end = -1;
     acc:	d8 01       	movw	r26, r16
     ace:	14 96       	adiw	r26, 0x04	; 4
     ad0:	fc 92       	st	X, r15
     ad2:	ee 92       	st	-X, r14
     ad4:	13 97       	sbiw	r26, 0x03	; 3
     ad6:	12 96       	adiw	r26, 0x02	; 2
     ad8:	fc 92       	st	X, r15
     ada:	ee 92       	st	-X, r14
     adc:	11 97       	sbiw	r26, 0x01	; 1
  tok->size = 0;
     ade:	16 96       	adiw	r26, 0x06	; 6
     ae0:	1c 92       	st	X, r1
     ae2:	1e 92       	st	-X, r1
     ae4:	15 97       	sbiw	r26, 0x05	; 5
  if (tokens == NULL) {
    parser->pos--;
    return 0;
  }
  token = jsmn_alloc_token(parser, tokens, num_tokens);
  if (token == NULL) {
     ae6:	01 2b       	or	r16, r17
     ae8:	09 f3       	breq	.-62     	; 0xaac <__stack+0x1ad>
/**
 * Fills token type and boundaries.
 */
static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
                            const int start, const int end) {
  token->type = type;
     aea:	4c 92       	st	X, r4
  token->start = start;
     aec:	12 96       	adiw	r26, 0x02	; 2
     aee:	9c 93       	st	X, r25
     af0:	8e 93       	st	-X, r24
     af2:	11 97       	sbiw	r26, 0x01	; 1
  token->end = end;
     af4:	14 96       	adiw	r26, 0x04	; 4
     af6:	5c 93       	st	X, r21
     af8:	4e 93       	st	-X, r20
     afa:	13 97       	sbiw	r26, 0x03	; 3
  }
  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
#ifdef JSMN_PARENT_LINKS
  token->parent = parser->toksuper;
#endif
  parser->pos--;
     afc:	da 01       	movw	r26, r20
     afe:	11 97       	sbiw	r26, 0x01	; 1
     b00:	b1 83       	std	Z+1, r27	; 0x01
     b02:	a0 83       	st	Z, r26
#endif
      r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
      if (r < 0) {
        return r;
      }
      count++;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	9c 81       	ldd	r25, Y+4	; 0x04
     b08:	01 96       	adiw	r24, 0x01	; 1
     b0a:	9c 83       	std	Y+4, r25	; 0x04
     b0c:	8b 83       	std	Y+3, r24	; 0x03
      if (parser->toksuper != -1 && tokens != NULL) {
     b0e:	84 81       	ldd	r24, Z+4	; 0x04
     b10:	95 81       	ldd	r25, Z+5	; 0x05
     b12:	8f 3f       	cpi	r24, 0xFF	; 255
     b14:	af ef       	ldi	r26, 0xFF	; 255
     b16:	9a 07       	cpc	r25, r26
     b18:	99 f0       	breq	.+38     	; 0xb40 <__stack+0x241>
     b1a:	21 15       	cp	r18, r1
     b1c:	31 05       	cpc	r19, r1
     b1e:	81 f0       	breq	.+32     	; 0xb40 <__stack+0x241>
        tokens[parser->toksuper].size++;
     b20:	b8 9e       	mul	r11, r24
     b22:	d0 01       	movw	r26, r0
     b24:	b9 9e       	mul	r11, r25
     b26:	b0 0d       	add	r27, r0
     b28:	11 24       	eor	r1, r1
     b2a:	a2 0f       	add	r26, r18
     b2c:	b3 1f       	adc	r27, r19
     b2e:	15 96       	adiw	r26, 0x05	; 5
     b30:	8d 91       	ld	r24, X+
     b32:	9c 91       	ld	r25, X
     b34:	16 97       	sbiw	r26, 0x06	; 6
     b36:	01 96       	adiw	r24, 0x01	; 1
     b38:	16 96       	adiw	r26, 0x06	; 6
     b3a:	9c 93       	st	X, r25
     b3c:	8e 93       	st	-X, r24
     b3e:	15 97       	sbiw	r26, 0x05	; 5
  int r;
  int i;
  jsmntok_t *token;
  int count = parser->toknext;

  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
     b40:	80 81       	ld	r24, Z
     b42:	91 81       	ldd	r25, Z+1	; 0x01
     b44:	01 96       	adiw	r24, 0x01	; 1
     b46:	91 83       	std	Z+1, r25	; 0x01
     b48:	80 83       	st	Z, r24
     b4a:	bc cd       	rjmp	.-1160   	; 0x6c4 <jsmn_parse+0x4a>
      return JSMN_ERROR_INVAL;
#endif
    }
  }

  if (tokens != NULL) {
     b4c:	21 15       	cp	r18, r1
     b4e:	31 05       	cpc	r19, r1
     b50:	f1 f0       	breq	.+60     	; 0xb8e <__stack+0x28f>
    for (i = parser->toknext - 1; i >= 0; i--) {
     b52:	42 81       	ldd	r20, Z+2	; 0x02
     b54:	53 81       	ldd	r21, Z+3	; 0x03
     b56:	ca 01       	movw	r24, r20
     b58:	01 97       	sbiw	r24, 0x01	; 1
     b5a:	67 e0       	ldi	r22, 0x07	; 7
     b5c:	64 9f       	mul	r22, r20
     b5e:	f0 01       	movw	r30, r0
     b60:	65 9f       	mul	r22, r21
     b62:	f0 0d       	add	r31, r0
     b64:	11 24       	eor	r1, r1
     b66:	36 97       	sbiw	r30, 0x06	; 6
     b68:	e2 0f       	add	r30, r18
     b6a:	f3 1f       	adc	r31, r19
     b6c:	97 fd       	sbrc	r25, 7
     b6e:	0f c0       	rjmp	.+30     	; 0xb8e <__stack+0x28f>
      /* Unmatched opened object or array */
      if (tokens[i].start != -1 && tokens[i].end == -1) {
     b70:	20 81       	ld	r18, Z
     b72:	31 81       	ldd	r19, Z+1	; 0x01
     b74:	2f 3f       	cpi	r18, 0xFF	; 255
     b76:	3f 4f       	sbci	r19, 0xFF	; 255
     b78:	29 f0       	breq	.+10     	; 0xb84 <__stack+0x285>
     b7a:	22 81       	ldd	r18, Z+2	; 0x02
     b7c:	33 81       	ldd	r19, Z+3	; 0x03
     b7e:	2f 3f       	cpi	r18, 0xFF	; 255
     b80:	3f 4f       	sbci	r19, 0xFF	; 255
     b82:	41 f0       	breq	.+16     	; 0xb94 <__stack+0x295>
#endif
    }
  }

  if (tokens != NULL) {
    for (i = parser->toknext - 1; i >= 0; i--) {
     b84:	01 97       	sbiw	r24, 0x01	; 1
     b86:	37 97       	sbiw	r30, 0x07	; 7
     b88:	f1 cf       	rjmp	.-30     	; 0xb6c <__stack+0x26d>
#else
      for (i = parser->toknext - 1; i >= 0; i--) {
        token = &tokens[i];
        if (token->start != -1 && token->end == -1) {
          if (token->type != type) {
            return JSMN_ERROR_INVAL;
     b8a:	8e ef       	ldi	r24, 0xFE	; 254
     b8c:	04 c0       	rjmp	.+8      	; 0xb96 <__stack+0x297>
     b8e:	8b 81       	ldd	r24, Y+3	; 0x03
     b90:	9c 81       	ldd	r25, Y+4	; 0x04
     b92:	11 c0       	rjmp	.+34     	; 0xbb6 <__stack+0x2b7>

  if (tokens != NULL) {
    for (i = parser->toknext - 1; i >= 0; i--) {
      /* Unmatched opened object or array */
      if (tokens[i].start != -1 && tokens[i].end == -1) {
        return JSMN_ERROR_PART;
     b94:	8d ef       	ldi	r24, 0xFD	; 253
     b96:	9f ef       	ldi	r25, 0xFF	; 255
     b98:	0e c0       	rjmp	.+28     	; 0xbb6 <__stack+0x2b7>
    case '\"':
      r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
      if (r < 0) {
        return r;
      }
      count++;
     b9a:	4b 81       	ldd	r20, Y+3	; 0x03
     b9c:	5c 81       	ldd	r21, Y+4	; 0x04
     b9e:	4f 5f       	subi	r20, 0xFF	; 255
     ba0:	5f 4f       	sbci	r21, 0xFF	; 255
     ba2:	5c 83       	std	Y+4, r21	; 0x04
     ba4:	4b 83       	std	Y+3, r20	; 0x03
      if (parser->toksuper != -1 && tokens != NULL) {
     ba6:	84 81       	ldd	r24, Z+4	; 0x04
     ba8:	95 81       	ldd	r25, Z+5	; 0x05
     baa:	8f 3f       	cpi	r24, 0xFF	; 255
     bac:	5f ef       	ldi	r21, 0xFF	; 255
     bae:	95 07       	cpc	r25, r21
     bb0:	09 f0       	breq	.+2      	; 0xbb4 <__stack+0x2b5>
     bb2:	b3 cf       	rjmp	.-154    	; 0xb1a <__stack+0x21b>
     bb4:	c5 cf       	rjmp	.-118    	; 0xb40 <__stack+0x241>
      }
    }
  }

  return count;
}
     bb6:	0f 90       	pop	r0
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	1f 91       	pop	r17
     bc4:	0f 91       	pop	r16
     bc6:	ff 90       	pop	r15
     bc8:	ef 90       	pop	r14
     bca:	df 90       	pop	r13
     bcc:	cf 90       	pop	r12
     bce:	bf 90       	pop	r11
     bd0:	9f 90       	pop	r9
     bd2:	8f 90       	pop	r8
     bd4:	7f 90       	pop	r7
     bd6:	6f 90       	pop	r6
     bd8:	5f 90       	pop	r5
     bda:	4f 90       	pop	r4
     bdc:	3f 90       	pop	r3
     bde:	2f 90       	pop	r2
     be0:	08 95       	ret

00000be2 <vTCPServerTask>:
    }
    return 1;
} 

portTASK_FUNCTION( vTCPServerTask, pvParameters )
{
     be2:	cf 93       	push	r28
     be4:	df 93       	push	r29
     be6:	cd b7       	in	r28, 0x3d	; 61
     be8:	de b7       	in	r29, 0x3e	; 62
     bea:	c3 57       	subi	r28, 0x73	; 115
     bec:	d1 09       	sbc	r29, r1
     bee:	0f b6       	in	r0, 0x3f	; 63
     bf0:	f8 94       	cli
     bf2:	de bf       	out	0x3e, r29	; 62
     bf4:	0f be       	out	0x3f, r0	; 63
     bf6:	cd bf       	out	0x3d, r28	; 61
/**
 * Creates a new parser based over a given buffer with an array of tokens
 * available.
 */
JSMN_API void jsmn_init(jsmn_parser *parser) {
  parser->pos = 0;
     bf8:	ae 96       	adiw	r28, 0x2e	; 46
     bfa:	1f ae       	std	Y+63, r1	; 0x3f
     bfc:	1e ae       	std	Y+62, r1	; 0x3e
     bfe:	ae 97       	sbiw	r28, 0x2e	; 46
  parser->toknext = 0;
     c00:	e0 96       	adiw	r28, 0x30	; 48
     c02:	1f ae       	std	Y+63, r1	; 0x3f
     c04:	1e ae       	std	Y+62, r1	; 0x3e
     c06:	e0 97       	sbiw	r28, 0x30	; 48
  parser->toksuper = -1;
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	9f ef       	ldi	r25, 0xFF	; 255
     c0c:	e2 96       	adiw	r28, 0x32	; 50
     c0e:	9f af       	std	Y+63, r25	; 0x3f
     c10:	8e af       	std	Y+62, r24	; 0x3e
     c12:	e2 97       	sbiw	r28, 0x32	; 50
jsmntok_t t;

TickType_t xLastWaitTime;

    jsmn_init(&p);
    xLastWaitTime = xTaskGetTickCount();
     c14:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <xTaskGetTickCount>
     c18:	e4 96       	adiw	r28, 0x34	; 52
     c1a:	9f af       	std	Y+63, r25	; 0x3f
     c1c:	8e af       	std	Y+62, r24	; 0x3e
     c1e:	e4 97       	sbiw	r28, 0x34	; 52
            if( getSn_IR( sn ) & Sn_IR_CON )
            {
                /* Clear CON interrupt bit issued from successful connection */
                setSn_IR( sn, Sn_IR_CON );
            }
            xServerConnEstablished = pdTRUE;
     c20:	ff 24       	eor	r15, r15
     c22:	f3 94       	inc	r15

static portBASE_TYPE xServerStatus( eSocketNum sn, TickType_t *xLastWaitTime )
{
int8_t ret;

    switch( getSn_SR( sn ) )
     c24:	68 e0       	ldi	r22, 0x08	; 8
     c26:	73 e0       	ldi	r23, 0x03	; 3
     c28:	80 e0       	ldi	r24, 0x00	; 0
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
     c30:	83 31       	cpi	r24, 0x13	; 19
     c32:	39 f1       	breq	.+78     	; 0xc82 <vTCPServerTask+0xa0>
     c34:	18 f4       	brcc	.+6      	; 0xc3c <vTCPServerTask+0x5a>
     c36:	88 23       	and	r24, r24
     c38:	61 f1       	breq	.+88     	; 0xc92 <vTCPServerTask+0xb0>
     c3a:	38 c0       	rjmp	.+112    	; 0xcac <vTCPServerTask+0xca>
     c3c:	87 31       	cpi	r24, 0x17	; 23
     c3e:	19 f0       	breq	.+6      	; 0xc46 <vTCPServerTask+0x64>
     c40:	8c 31       	cpi	r24, 0x1C	; 28
     c42:	a9 f0       	breq	.+42     	; 0xc6e <vTCPServerTask+0x8c>
     c44:	33 c0       	rjmp	.+102    	; 0xcac <vTCPServerTask+0xca>
    {
        /* Socket connection established with peer - SYN packet received */
        case SOCK_ESTABLISHED:
            if( getSn_IR( sn ) & Sn_IR_CON )
     c46:	68 e0       	ldi	r22, 0x08	; 8
     c48:	72 e0       	ldi	r23, 0x02	; 2
     c4a:	80 e0       	ldi	r24, 0x00	; 0
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
     c52:	80 ff       	sbrs	r24, 0
     c54:	07 c0       	rjmp	.+14     	; 0xc64 <vTCPServerTask+0x82>
            {
                /* Clear CON interrupt bit issued from successful connection */
                setSn_IR( sn, Sn_IR_CON );
     c56:	41 e0       	ldi	r20, 0x01	; 1
     c58:	68 e0       	ldi	r22, 0x08	; 8
     c5a:	72 e0       	ldi	r23, 0x02	; 2
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
            }
            xServerConnEstablished = pdTRUE;
     c64:	f0 92 39 02 	sts	0x0239, r15	; 0x800239 <xServerConnEstablished>
            writeString("Socket established on port 8080\n");
     c68:	83 e5       	ldi	r24, 0x53	; 83
     c6a:	91 e0       	ldi	r25, 0x01	; 1
     c6c:	1d c0       	rjmp	.+58     	; 0xca8 <vTCPServerTask+0xc6>
            break;

        /* Socket n received disconnect-request (FIN packet) from connected peer */
        case SOCK_CLOSE_WAIT:
            if( ( ret = disconnect( sn ) ) != SOCK_OK ) return ret;
     c6e:	80 e0       	ldi	r24, 0x00	; 0
     c70:	0e 94 b5 1c 	call	0x396a	; 0x396a <disconnect>
     c74:	81 30       	cpi	r24, 0x01	; 1
     c76:	d1 f4       	brne	.+52     	; 0xcac <vTCPServerTask+0xca>
            xServerConnEstablished = pdFALSE;
     c78:	10 92 39 02 	sts	0x0239, r1	; 0x800239 <xServerConnEstablished>
            writeString("Closing socket...\n");
     c7c:	84 e7       	ldi	r24, 0x74	; 116
     c7e:	91 e0       	ldi	r25, 0x01	; 1
     c80:	13 c0       	rjmp	.+38     	; 0xca8 <vTCPServerTask+0xc6>
            break;

        /* Socket n is opened with TCP mode, start listening for peer */
        case SOCK_INIT:
            if( ( ret = listen( sn ) ) != SOCK_OK ) return ret;
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <listen>
     c88:	81 30       	cpi	r24, 0x01	; 1
     c8a:	81 f4       	brne	.+32     	; 0xcac <vTCPServerTask+0xca>
            writeString("Socket initialized... listening for connection\n");
     c8c:	87 e8       	ldi	r24, 0x87	; 135
     c8e:	91 e0       	ldi	r25, 0x01	; 1
     c90:	0b c0       	rjmp	.+22     	; 0xca8 <vTCPServerTask+0xc6>
            break;

         /* Socket n is closed, configure TCP server for socket n on port 8080 */
        case SOCK_CLOSED:
            if( ( ret = socket( sn, Sn_MR_TCP, 8080, 0x00 ) ) != sn ) return ret;
     c92:	20 e0       	ldi	r18, 0x00	; 0
     c94:	40 e9       	ldi	r20, 0x90	; 144
     c96:	5f e1       	ldi	r21, 0x1F	; 31
     c98:	61 e0       	ldi	r22, 0x01	; 1
     c9a:	80 e0       	ldi	r24, 0x00	; 0
     c9c:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <socket>
     ca0:	81 11       	cpse	r24, r1
     ca2:	04 c0       	rjmp	.+8      	; 0xcac <vTCPServerTask+0xca>
            writeString("Socket closed... opening\n");
     ca4:	87 eb       	ldi	r24, 0xB7	; 183
     ca6:	91 e0       	ldi	r25, 0x01	; 1
     ca8:	0e 94 28 07 	call	0xe50	; 0xe50 <writeString>

    for( ;; )
    {
        status = xServerStatus( 0, &xLastWaitTime );

        if( xServerConnEstablished == pdTRUE )
     cac:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <xServerConnEstablished>
     cb0:	81 30       	cpi	r24, 0x01	; 1
     cb2:	09 f0       	breq	.+2      	; 0xcb6 <vTCPServerTask+0xd4>
     cb4:	b7 cf       	rjmp	.-146    	; 0xc24 <vTCPServerTask+0x42>
        {
            /* Check if a recv has occured otherwise block */
            if( ( getSn_IR(0) & Sn_IR_RECV ) ) 
     cb6:	68 e0       	ldi	r22, 0x08	; 8
     cb8:	72 e0       	ldi	r23, 0x02	; 2
     cba:	80 e0       	ldi	r24, 0x00	; 0
     cbc:	90 e0       	ldi	r25, 0x00	; 0
     cbe:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
     cc2:	82 ff       	sbrs	r24, 2
     cc4:	2d c0       	rjmp	.+90     	; 0xd20 <vTCPServerTask+0x13e>
            {
                /* Read in wiz rx buffer and process commands */
                writeString("Received some data!\n");
     cc6:	81 ed       	ldi	r24, 0xD1	; 209
     cc8:	91 e0       	ldi	r25, 0x01	; 1
     cca:	0e 94 28 07 	call	0xe50	; 0xe50 <writeString>

                if( (size = getSn_RX_RSR(0)) > 0) // Don't need to check SOCKERR_BUSY because it doesn't not occur.
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	0e 94 b6 2a 	call	0x556c	; 0x556c <getSn_RX_RSR>
     cd4:	00 97       	sbiw	r24, 0x00	; 0
     cd6:	09 f4       	brne	.+2      	; 0xcda <vTCPServerTask+0xf8>
     cd8:	a5 cf       	rjmp	.-182    	; 0xc24 <vTCPServerTask+0x42>
                {
                    if(size > DATA_BUF_SIZE) size = DATA_BUF_SIZE; // clips size if larger that data buffer
                    ret = recv( 0, buf, size);
     cda:	ac 01       	movw	r20, r24
     cdc:	41 30       	cpi	r20, 0x01	; 1
     cde:	84 e0       	ldi	r24, 0x04	; 4
     ce0:	58 07       	cpc	r21, r24
     ce2:	10 f0       	brcs	.+4      	; 0xce8 <vTCPServerTask+0x106>
     ce4:	40 e0       	ldi	r20, 0x00	; 0
     ce6:	54 e0       	ldi	r21, 0x04	; 4
     ce8:	be 01       	movw	r22, r28
     cea:	6f 5f       	subi	r22, 0xFF	; 255
     cec:	7f 4f       	sbci	r23, 0xFF	; 255
     cee:	80 e0       	ldi	r24, 0x00	; 0
     cf0:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <recv>

                    if(ret <= 0) continue;  // check SOCKERR_BUSY & SOCKERR_XXX. For showing the occurrence of SOCKERR_BUSY.
     cf4:	16 16       	cp	r1, r22
     cf6:	17 06       	cpc	r1, r23
     cf8:	18 06       	cpc	r1, r24
     cfa:	19 06       	cpc	r1, r25
     cfc:	0c f0       	brlt	.+2      	; 0xd00 <vTCPServerTask+0x11e>
     cfe:	92 cf       	rjmp	.-220    	; 0xc24 <vTCPServerTask+0x42>

                    r = jsmn_parse(&p, (const char *)buf, sizeof(buf), &t, sizeof(t));
     d00:	07 e0       	ldi	r16, 0x07	; 7
     d02:	10 e0       	ldi	r17, 0x00	; 0
     d04:	9e 01       	movw	r18, r28
     d06:	2b 59       	subi	r18, 0x9B	; 155
     d08:	3f 4f       	sbci	r19, 0xFF	; 255
     d0a:	44 e6       	ldi	r20, 0x64	; 100
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	be 01       	movw	r22, r28
     d10:	6f 5f       	subi	r22, 0xFF	; 255
     d12:	7f 4f       	sbci	r23, 0xFF	; 255
     d14:	ce 01       	movw	r24, r28
     d16:	84 59       	subi	r24, 0x94	; 148
     d18:	9f 4f       	sbci	r25, 0xFF	; 255
     d1a:	0e 94 3d 03 	call	0x67a	; 0x67a <jsmn_parse>
     d1e:	82 cf       	rjmp	.-252    	; 0xc24 <vTCPServerTask+0x42>
                }
            }
            else
            {
                writeString("Delaying 20 ticks -> no receive\n");
     d20:	86 ee       	ldi	r24, 0xE6	; 230
     d22:	91 e0       	ldi	r25, 0x01	; 1
     d24:	0e 94 28 07 	call	0xe50	; 0xe50 <writeString>
                vTaskDelayUntil( &xLastWaitTime, tcpDELAY_TIME );
     d28:	64 e6       	ldi	r22, 0x64	; 100
     d2a:	70 e0       	ldi	r23, 0x00	; 0
     d2c:	ce 01       	movw	r24, r28
     d2e:	8e 58       	subi	r24, 0x8E	; 142
     d30:	9f 4f       	sbci	r25, 0xFF	; 255
     d32:	0e 94 09 0b 	call	0x1612	; 0x1612 <vTaskDelayUntil>
     d36:	76 cf       	rjmp	.-276    	; 0xc24 <vTCPServerTask+0x42>

00000d38 <jsmn_init>:

/**
 * Creates a new parser based over a given buffer with an array of tokens
 * available.
 */
JSMN_API void jsmn_init(jsmn_parser *parser) {
     d38:	fc 01       	movw	r30, r24
  parser->pos = 0;
     d3a:	11 82       	std	Z+1, r1	; 0x01
     d3c:	10 82       	st	Z, r1
  parser->toknext = 0;
     d3e:	13 82       	std	Z+3, r1	; 0x03
     d40:	12 82       	std	Z+2, r1	; 0x02
  parser->toksuper = -1;
     d42:	8f ef       	ldi	r24, 0xFF	; 255
     d44:	9f ef       	ldi	r25, 0xFF	; 255
     d46:	95 83       	std	Z+5, r25	; 0x05
     d48:	84 83       	std	Z+4, r24	; 0x04
     d4a:	08 95       	ret

00000d4c <vStartTCPServerTask>:
/* Static prototypes for methods in this file. */
static void vTCPServerInit( void );
static portBASE_TYPE xServerStatus( eSocketNum sn, TickType_t *xLastWaitTime );

void vStartTCPServerTask( void )
{
     d4c:	ef 92       	push	r14
     d4e:	ff 92       	push	r15
     d50:	0f 93       	push	r16
     d52:	1f 93       	push	r17
     d54:	cf 93       	push	r28
     d56:	df 93       	push	r29
     d58:	cd b7       	in	r28, 0x3d	; 61
     d5a:	de b7       	in	r29, 0x3e	; 62
     d5c:	a7 97       	sbiw	r28, 0x27	; 39
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	de bf       	out	0x3e, r29	; 62
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	cd bf       	out	0x3d, r28	; 61
    xTaskCreate( vTCPServerTask, "TCP", 1024, NULL, tcpTCP_SERVER_TASK_PRIORITY, NULL );
}

static void vTCPServerInit( void )
{
    portENTER_CRITICAL();
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	0f 92       	push	r0
    {
        vInitSPI();
     d6e:	84 b1       	in	r24, 0x04	; 4
     d70:	8c 62       	ori	r24, 0x2C	; 44
     d72:	84 b9       	out	0x04, r24	; 4
     d74:	8c b5       	in	r24, 0x2c	; 44
     d76:	80 65       	ori	r24, 0x50	; 80
     d78:	8c bd       	out	0x2c, r24	; 44
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d7a:	2f ef       	ldi	r18, 0xFF	; 255
     d7c:	87 ea       	ldi	r24, 0xA7	; 167
     d7e:	91 e6       	ldi	r25, 0x61	; 97
     d80:	21 50       	subi	r18, 0x01	; 1
     d82:	80 40       	sbci	r24, 0x00	; 0
     d84:	90 40       	sbci	r25, 0x00	; 0
     d86:	e1 f7       	brne	.-8      	; 0xd80 <vStartTCPServerTask+0x34>
     d88:	00 c0       	rjmp	.+0      	; 0xd8a <vStartTCPServerTask+0x3e>
     d8a:	00 00       	nop

        /* Wiznet chip setup time. */
        _delay_ms(2000);
        
        struct wiz_NetInfo_t network_config = 
     d8c:	87 e1       	ldi	r24, 0x17	; 23
     d8e:	ed e1       	ldi	r30, 0x1D	; 29
     d90:	f1 e0       	ldi	r31, 0x01	; 1
     d92:	de 01       	movw	r26, r28
     d94:	11 96       	adiw	r26, 0x01	; 1
     d96:	01 90       	ld	r0, Z+
     d98:	0d 92       	st	X+, r0
     d9a:	8a 95       	dec	r24
     d9c:	e1 f7       	brne	.-8      	; 0xd96 <vStartTCPServerTask+0x4a>
            { tcpDNS },
            2
        };

        /* Allocate 1KB for tx and rx buffer for socket 0 */
        uint8_t txsize[8] = { 1, 0, 0, 0, 0, 0, 0, 0 };
     d9e:	98 e0       	ldi	r25, 0x08	; 8
     da0:	8e 01       	movw	r16, r28
     da2:	00 5e       	subi	r16, 0xE0	; 224
     da4:	1f 4f       	sbci	r17, 0xFF	; 255
     da6:	f8 01       	movw	r30, r16
     da8:	29 2f       	mov	r18, r25
     daa:	11 92       	st	Z+, r1
     dac:	2a 95       	dec	r18
     dae:	e9 f7       	brne	.-6      	; 0xdaa <vStartTCPServerTask+0x5e>
     db0:	81 e0       	ldi	r24, 0x01	; 1
     db2:	88 a3       	std	Y+32, r24	; 0x20
        uint8_t rxsize[8] = { 1, 0, 0, 0, 0, 0, 0, 0 };
     db4:	7e 01       	movw	r14, r28
     db6:	e8 e1       	ldi	r30, 0x18	; 24
     db8:	ee 0e       	add	r14, r30
     dba:	f1 1c       	adc	r15, r1
     dbc:	f7 01       	movw	r30, r14
     dbe:	11 92       	st	Z+, r1
     dc0:	9a 95       	dec	r25
     dc2:	e9 f7       	brne	.-6      	; 0xdbe <vStartTCPServerTask+0x72>
     dc4:	88 8f       	std	Y+24, r24	; 0x18
        
        /* Initialize network configuration and buffer size. */
        wizchip_setnetinfo( &network_config );
     dc6:	ce 01       	movw	r24, r28
     dc8:	01 96       	adiw	r24, 0x01	; 1
     dca:	0e 94 82 27 	call	0x4f04	; 0x4f04 <wizchip_setnetinfo>
        wizchip_init( txsize, rxsize );
     dce:	b7 01       	movw	r22, r14
     dd0:	c8 01       	movw	r24, r16
     dd2:	0e 94 93 25 	call	0x4b26	; 0x4b26 <wizchip_init>
    }
    portEXIT_CRITICAL();
     dd6:	0f 90       	pop	r0
     dd8:	0f be       	out	0x3f, r0	; 63
static portBASE_TYPE xServerStatus( eSocketNum sn, TickType_t *xLastWaitTime );

void vStartTCPServerTask( void )
{
    vTCPServerInit();
    xTaskCreate( vTCPServerTask, "TCP", 1024, NULL, tcpTCP_SERVER_TASK_PRIORITY, NULL );
     dda:	e1 2c       	mov	r14, r1
     ddc:	f1 2c       	mov	r15, r1
     dde:	02 e0       	ldi	r16, 0x02	; 2
     de0:	20 e0       	ldi	r18, 0x00	; 0
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	40 e0       	ldi	r20, 0x00	; 0
     de6:	54 e0       	ldi	r21, 0x04	; 4
     de8:	67 e0       	ldi	r22, 0x07	; 7
     dea:	72 e0       	ldi	r23, 0x02	; 2
     dec:	81 ef       	ldi	r24, 0xF1	; 241
     dee:	95 e0       	ldi	r25, 0x05	; 5
     df0:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
}
     df4:	a7 96       	adiw	r28, 0x27	; 39
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	0f be       	out	0x3f, r0	; 63
     dfe:	cd bf       	out	0x3d, r28	; 61
     e00:	df 91       	pop	r29
     e02:	cf 91       	pop	r28
     e04:	1f 91       	pop	r17
     e06:	0f 91       	pop	r16
     e08:	ff 90       	pop	r15
     e0a:	ef 90       	pop	r14
     e0c:	08 95       	ret

00000e0e <initUART>:

/*! \brief Configures baud rate (refer datasheet) */
void initUART(void)
{
    // Not necessary; initialize anyway
    DDRD |= _BV(PD1);
     e0e:	51 9a       	sbi	0x0a, 1	; 10
    DDRD &= ~_BV(PD0);
     e10:	50 98       	cbi	0x0a, 0	; 10

    // Set baud rate; lower byte and top nibble
    UBRR0H = ((_UBRR) & 0xF00);
     e12:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    UBRR0L = (uint8_t) ((_UBRR) & 0xFF);
     e16:	87 e6       	ldi	r24, 0x67	; 103
     e18:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>

    TX_START();
     e1c:	e1 ec       	ldi	r30, 0xC1	; 193
     e1e:	f0 e0       	ldi	r31, 0x00	; 0
     e20:	80 81       	ld	r24, Z
     e22:	88 60       	ori	r24, 0x08	; 8
     e24:	80 83       	st	Z, r24
    RX_START();
     e26:	80 81       	ld	r24, Z
     e28:	80 61       	ori	r24, 0x10	; 16
     e2a:	80 83       	st	Z, r24

    // Set frame format = 8-N-1
    UCSR0C = (_DATA << UCSZ00);
     e2c:	86 e0       	ldi	r24, 0x06	; 6
     e2e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     e32:	08 95       	ret

00000e34 <getByte>:
 * 	Returns 0 on empty buffer
 */
uint8_t getByte(void)
{
    // Check to see if something was received
    while (!(UCSR0A & _BV(RXC0)));
     e34:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     e38:	87 ff       	sbrs	r24, 7
     e3a:	fc cf       	rjmp	.-8      	; 0xe34 <getByte>
    return (uint8_t) UDR0;
     e3c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
     e40:	08 95       	ret

00000e42 <putByte>:
 * 	Blocks the serial port while TX completes
 */
void putByte(unsigned char data)
{
    // Stay here until data buffer is empty
    while (!(UCSR0A & _BV(UDRE0)));
     e42:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     e46:	95 ff       	sbrs	r25, 5
     e48:	fc cf       	rjmp	.-8      	; 0xe42 <putByte>
    UDR0 = (unsigned char) data;
     e4a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     e4e:	08 95       	ret

00000e50 <writeString>:
}

/*! \brief Writes an ASCII string to the TX buffer */
void writeString(char *str)
{
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	ec 01       	movw	r28, r24
    while (*str != '\0')
     e56:	89 91       	ld	r24, Y+
     e58:	88 23       	and	r24, r24
     e5a:	19 f0       	breq	.+6      	; 0xe62 <writeString+0x12>
    {
        putByte(*str);
     e5c:	0e 94 21 07 	call	0xe42	; 0xe42 <putByte>
     e60:	fa cf       	rjmp	.-12     	; 0xe56 <writeString+0x6>
        ++str;
    }
}
     e62:	df 91       	pop	r29
     e64:	cf 91       	pop	r28
     e66:	08 95       	ret

00000e68 <writeNumChar>:

//Convert unsigned 8-bit num to str with given base
void writeNumChar(char* id, uint8_t num, uint8_t base)
{
     e68:	0f 93       	push	r16
     e6a:	1f 93       	push	r17
     e6c:	cf 93       	push	r28
     e6e:	df 93       	push	r29
     e70:	cd b7       	in	r28, 0x3d	; 61
     e72:	de b7       	in	r29, 0x3e	; 62
     e74:	2a 97       	sbiw	r28, 0x0a	; 10
     e76:	0f b6       	in	r0, 0x3f	; 63
     e78:	f8 94       	cli
     e7a:	de bf       	out	0x3e, r29	; 62
     e7c:	0f be       	out	0x3f, r0	; 63
     e7e:	cd bf       	out	0x3d, r28	; 61
     e80:	8c 01       	movw	r16, r24
     e82:	86 2f       	mov	r24, r22
extern __inline__ __ATTR_GNU_INLINE__
char *itoa (int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__itoa (int, char *, int);
	return __itoa (__val, __s, __radix);
     e84:	50 e0       	ldi	r21, 0x00	; 0
     e86:	be 01       	movw	r22, r28
     e88:	6f 5f       	subi	r22, 0xFF	; 255
     e8a:	7f 4f       	sbci	r23, 0xFF	; 255
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <itoa>
    uint8_t i = 0;
    char str[10];
    itoa(num, str, base);

    if(id)
     e92:	01 15       	cp	r16, r1
     e94:	11 05       	cpc	r17, r1
     e96:	19 f0       	breq	.+6      	; 0xe9e <writeNumChar+0x36>
    {
        writeString(id);
     e98:	c8 01       	movw	r24, r16
     e9a:	0e 94 28 07 	call	0xe50	; 0xe50 <writeString>
    }
}

//Convert unsigned 8-bit num to str with given base
void writeNumChar(char* id, uint8_t num, uint8_t base)
{
     e9e:	10 e0       	ldi	r17, 0x00	; 0
    if(id)
    {
        writeString(id);
    }

    while (str[i] != '\0')
     ea0:	e1 e0       	ldi	r30, 0x01	; 1
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	ec 0f       	add	r30, r28
     ea6:	fd 1f       	adc	r31, r29
     ea8:	e1 0f       	add	r30, r17
     eaa:	f1 1d       	adc	r31, r1
     eac:	80 81       	ld	r24, Z
     eae:	88 23       	and	r24, r24
     eb0:	21 f0       	breq	.+8      	; 0xeba <writeNumChar+0x52>
    {
        putByte(str[i]);
     eb2:	0e 94 21 07 	call	0xe42	; 0xe42 <putByte>
        ++i;
     eb6:	1f 5f       	subi	r17, 0xFF	; 255
     eb8:	f3 cf       	rjmp	.-26     	; 0xea0 <writeNumChar+0x38>
    }
    putByte('\r');
     eba:	8d e0       	ldi	r24, 0x0D	; 13
     ebc:	0e 94 21 07 	call	0xe42	; 0xe42 <putByte>
    putByte('\n');
     ec0:	8a e0       	ldi	r24, 0x0A	; 10
     ec2:	0e 94 21 07 	call	0xe42	; 0xe42 <putByte>
}
     ec6:	2a 96       	adiw	r28, 0x0a	; 10
     ec8:	0f b6       	in	r0, 0x3f	; 63
     eca:	f8 94       	cli
     ecc:	de bf       	out	0x3e, r29	; 62
     ece:	0f be       	out	0x3f, r0	; 63
     ed0:	cd bf       	out	0x3d, r28	; 61
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	1f 91       	pop	r17
     ed8:	0f 91       	pop	r16
     eda:	08 95       	ret

00000edc <writeNumShort>:

//Convert unsigned 16-bit num to str with given base
void writeNumShort(char* id, uint16_t num, uint8_t base)
{
     edc:	0f 93       	push	r16
     ede:	1f 93       	push	r17
     ee0:	cf 93       	push	r28
     ee2:	df 93       	push	r29
     ee4:	cd b7       	in	r28, 0x3d	; 61
     ee6:	de b7       	in	r29, 0x3e	; 62
     ee8:	2a 97       	sbiw	r28, 0x0a	; 10
     eea:	0f b6       	in	r0, 0x3f	; 63
     eec:	f8 94       	cli
     eee:	de bf       	out	0x3e, r29	; 62
     ef0:	0f be       	out	0x3f, r0	; 63
     ef2:	cd bf       	out	0x3d, r28	; 61
     ef4:	8c 01       	movw	r16, r24
     ef6:	cb 01       	movw	r24, r22
     ef8:	50 e0       	ldi	r21, 0x00	; 0
     efa:	be 01       	movw	r22, r28
     efc:	6f 5f       	subi	r22, 0xFF	; 255
     efe:	7f 4f       	sbci	r23, 0xFF	; 255
     f00:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <itoa>
    uint8_t i = 0;
    char str[10];
    itoa(num, str, base);

    if(id)
     f04:	01 15       	cp	r16, r1
     f06:	11 05       	cpc	r17, r1
     f08:	19 f0       	breq	.+6      	; 0xf10 <writeNumShort+0x34>
    {
        writeString(id);
     f0a:	c8 01       	movw	r24, r16
     f0c:	0e 94 28 07 	call	0xe50	; 0xe50 <writeString>
    putByte('\n');
}

//Convert unsigned 16-bit num to str with given base
void writeNumShort(char* id, uint16_t num, uint8_t base)
{
     f10:	10 e0       	ldi	r17, 0x00	; 0
    if(id)
    {
        writeString(id);
    }

    while (str[i] != '\0')
     f12:	e1 e0       	ldi	r30, 0x01	; 1
     f14:	f0 e0       	ldi	r31, 0x00	; 0
     f16:	ec 0f       	add	r30, r28
     f18:	fd 1f       	adc	r31, r29
     f1a:	e1 0f       	add	r30, r17
     f1c:	f1 1d       	adc	r31, r1
     f1e:	80 81       	ld	r24, Z
     f20:	88 23       	and	r24, r24
     f22:	21 f0       	breq	.+8      	; 0xf2c <writeNumShort+0x50>
    {
        putByte(str[i]);
     f24:	0e 94 21 07 	call	0xe42	; 0xe42 <putByte>
        ++i;
     f28:	1f 5f       	subi	r17, 0xFF	; 255
     f2a:	f3 cf       	rjmp	.-26     	; 0xf12 <writeNumShort+0x36>
    }
    putByte('\r');
     f2c:	8d e0       	ldi	r24, 0x0D	; 13
     f2e:	0e 94 21 07 	call	0xe42	; 0xe42 <putByte>
    putByte('\n');
     f32:	8a e0       	ldi	r24, 0x0A	; 10
     f34:	0e 94 21 07 	call	0xe42	; 0xe42 <putByte>
}
     f38:	2a 96       	adiw	r28, 0x0a	; 10
     f3a:	0f b6       	in	r0, 0x3f	; 63
     f3c:	f8 94       	cli
     f3e:	de bf       	out	0x3e, r29	; 62
     f40:	0f be       	out	0x3f, r0	; 63
     f42:	cd bf       	out	0x3d, r28	; 61
     f44:	df 91       	pop	r29
     f46:	cf 91       	pop	r28
     f48:	1f 91       	pop	r17
     f4a:	0f 91       	pop	r16
     f4c:	08 95       	ret

00000f4e <readString>:

const char* readString(void)
{
     f4e:	cf 93       	push	r28
     f50:	df 93       	push	r29
    static char rxstr[RX_BUFF];
    static char* temp;
    temp = rxstr;
     f52:	8a e3       	ldi	r24, 0x3A	; 58
     f54:	92 e0       	ldi	r25, 0x02	; 2
     f56:	90 93 45 02 	sts	0x0245, r25	; 0x800245 <temp.1823+0x1>
     f5a:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <temp.1823>

    while((*temp = getByte()) != '\n')
     f5e:	c0 91 44 02 	lds	r28, 0x0244	; 0x800244 <temp.1823>
     f62:	d0 91 45 02 	lds	r29, 0x0245	; 0x800245 <temp.1823+0x1>
     f66:	0e 94 1a 07 	call	0xe34	; 0xe34 <getByte>
     f6a:	88 83       	st	Y, r24
     f6c:	8a 30       	cpi	r24, 0x0A	; 10
     f6e:	31 f0       	breq	.+12     	; 0xf7c <readString+0x2e>
    {
        ++temp;
     f70:	21 96       	adiw	r28, 0x01	; 1
     f72:	d0 93 45 02 	sts	0x0245, r29	; 0x800245 <temp.1823+0x1>
     f76:	c0 93 44 02 	sts	0x0244, r28	; 0x800244 <temp.1823>
     f7a:	f1 cf       	rjmp	.-30     	; 0xf5e <readString+0x10>
    }

    return rxstr;
}
     f7c:	8a e3       	ldi	r24, 0x3A	; 58
     f7e:	92 e0       	ldi	r25, 0x02	; 2
     f80:	df 91       	pop	r29
     f82:	cf 91       	pop	r28
     f84:	08 95       	ret

00000f86 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     f86:	e0 91 6b 02 	lds	r30, 0x026B	; 0x80026b <pxDelayedTaskList>
     f8a:	f0 91 6c 02 	lds	r31, 0x026C	; 0x80026c <pxDelayedTaskList+0x1>
     f8e:	80 81       	ld	r24, Z
     f90:	81 11       	cpse	r24, r1
     f92:	03 c0       	rjmp	.+6      	; 0xf9a <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     f94:	8f ef       	ldi	r24, 0xFF	; 255
     f96:	9f ef       	ldi	r25, 0xFF	; 255
     f98:	0c c0       	rjmp	.+24     	; 0xfb2 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     f9a:	e0 91 6b 02 	lds	r30, 0x026B	; 0x80026b <pxDelayedTaskList>
     f9e:	f0 91 6c 02 	lds	r31, 0x026C	; 0x80026c <pxDelayedTaskList+0x1>
     fa2:	05 80       	ldd	r0, Z+5	; 0x05
     fa4:	f6 81       	ldd	r31, Z+6	; 0x06
     fa6:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     fa8:	06 80       	ldd	r0, Z+6	; 0x06
     faa:	f7 81       	ldd	r31, Z+7	; 0x07
     fac:	e0 2d       	mov	r30, r0
     fae:	82 81       	ldd	r24, Z+2	; 0x02
     fb0:	93 81       	ldd	r25, Z+3	; 0x03
     fb2:	90 93 4c 02 	sts	0x024C, r25	; 0x80024c <xNextTaskUnblockTime+0x1>
     fb6:	80 93 4b 02 	sts	0x024B, r24	; 0x80024b <xNextTaskUnblockTime>
     fba:	08 95       	ret

00000fbc <prvAddCurrentTaskToDelayedList.isra.2>:
		return xIdleTaskHandle->ulRunTimeCounter;
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
     fbc:	0f 93       	push	r16
     fbe:	1f 93       	push	r17
     fc0:	cf 93       	push	r28
     fc2:	df 93       	push	r29
     fc4:	ec 01       	movw	r28, r24
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     fc6:	00 91 53 02 	lds	r16, 0x0253	; 0x800253 <xTickCount>
     fca:	10 91 54 02 	lds	r17, 0x0254	; 0x800254 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     fce:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <pxCurrentTCB>
     fd2:	90 91 47 02 	lds	r25, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
     fd6:	02 96       	adiw	r24, 0x02	; 2
     fd8:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     fdc:	c0 0f       	add	r28, r16
     fde:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     fe0:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
     fe4:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
     fe8:	d3 83       	std	Z+3, r29	; 0x03
     fea:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     fec:	60 91 46 02 	lds	r22, 0x0246	; 0x800246 <pxCurrentTCB>
     ff0:	70 91 47 02 	lds	r23, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
		xTimeToWake = xConstTickCount + xTicksToWait;

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
     ff4:	c0 17       	cp	r28, r16
     ff6:	d1 07       	cpc	r29, r17
     ff8:	60 f4       	brcc	.+24     	; 0x1012 <prvAddCurrentTaskToDelayedList.isra.2+0x56>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     ffa:	80 91 69 02 	lds	r24, 0x0269	; 0x800269 <pxOverflowDelayedTaskList>
     ffe:	90 91 6a 02 	lds	r25, 0x026A	; 0x80026a <pxOverflowDelayedTaskList+0x1>
    1002:	6e 5f       	subi	r22, 0xFE	; 254
    1004:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1006:	df 91       	pop	r29
    1008:	cf 91       	pop	r28
    100a:	1f 91       	pop	r17
    100c:	0f 91       	pop	r16
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    100e:	0c 94 cf 13 	jmp	0x279e	; 0x279e <vListInsert>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1012:	80 91 6b 02 	lds	r24, 0x026B	; 0x80026b <pxDelayedTaskList>
    1016:	90 91 6c 02 	lds	r25, 0x026C	; 0x80026c <pxDelayedTaskList+0x1>
    101a:	6e 5f       	subi	r22, 0xFE	; 254
    101c:	7f 4f       	sbci	r23, 0xFF	; 255
    101e:	0e 94 cf 13 	call	0x279e	; 0x279e <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    1022:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <xNextTaskUnblockTime>
    1026:	90 91 4c 02 	lds	r25, 0x024C	; 0x80024c <xNextTaskUnblockTime+0x1>
    102a:	c8 17       	cp	r28, r24
    102c:	d9 07       	cpc	r29, r25
    102e:	20 f4       	brcc	.+8      	; 0x1038 <prvAddCurrentTaskToDelayedList.isra.2+0x7c>
			{
				xNextTaskUnblockTime = xTimeToWake;
    1030:	d0 93 4c 02 	sts	0x024C, r29	; 0x80024c <xNextTaskUnblockTime+0x1>
    1034:	c0 93 4b 02 	sts	0x024B, r28	; 0x80024b <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1038:	df 91       	pop	r29
    103a:	cf 91       	pop	r28
    103c:	1f 91       	pop	r17
    103e:	0f 91       	pop	r16
    1040:	08 95       	ret

00001042 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1042:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <uxDeletedTasksWaitingCleanUp>
    1046:	88 23       	and	r24, r24
    1048:	09 f1       	breq	.+66     	; 0x108c <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
    104a:	0f b6       	in	r0, 0x3f	; 63
    104c:	f8 94       	cli
    104e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1050:	e0 91 5c 02 	lds	r30, 0x025C	; 0x80025c <xTasksWaitingTermination+0x5>
    1054:	f0 91 5d 02 	lds	r31, 0x025D	; 0x80025d <xTasksWaitingTermination+0x6>
    1058:	c6 81       	ldd	r28, Z+6	; 0x06
    105a:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    105c:	ce 01       	movw	r24, r28
    105e:	02 96       	adiw	r24, 0x02	; 2
    1060:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
				--uxCurrentNumberOfTasks;
    1064:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <uxCurrentNumberOfTasks>
    1068:	81 50       	subi	r24, 0x01	; 1
    106a:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
    106e:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <uxDeletedTasksWaitingCleanUp>
    1072:	81 50       	subi	r24, 0x01	; 1
    1074:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    107c:	8f 89       	ldd	r24, Y+23	; 0x17
    107e:	98 8d       	ldd	r25, Y+24	; 0x18
    1080:	0e 94 23 16 	call	0x2c46	; 0x2c46 <vPortFree>
			vPortFree( pxTCB );
    1084:	ce 01       	movw	r24, r28
    1086:	0e 94 23 16 	call	0x2c46	; 0x2c46 <vPortFree>
    108a:	db cf       	rjmp	.-74     	; 0x1042 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    108c:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <pxReadyTasksLists>
    1090:	82 30       	cpi	r24, 0x02	; 2
    1092:	10 f0       	brcs	.+4      	; 0x1098 <prvIdleTask+0x56>
			{
				taskYIELD();
    1094:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    1098:	0e 94 7f 00 	call	0xfe	; 0xfe <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    109c:	d2 cf       	rjmp	.-92     	; 0x1042 <prvIdleTask>

0000109e <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    109e:	4f 92       	push	r4
    10a0:	5f 92       	push	r5
    10a2:	6f 92       	push	r6
    10a4:	7f 92       	push	r7
    10a6:	8f 92       	push	r8
    10a8:	9f 92       	push	r9
    10aa:	af 92       	push	r10
    10ac:	bf 92       	push	r11
    10ae:	cf 92       	push	r12
    10b0:	df 92       	push	r13
    10b2:	ef 92       	push	r14
    10b4:	ff 92       	push	r15
    10b6:	0f 93       	push	r16
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	4c 01       	movw	r8, r24
    10be:	6b 01       	movw	r12, r22
    10c0:	5a 01       	movw	r10, r20
    10c2:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    10c4:	ca 01       	movw	r24, r20
    10c6:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <pvPortMalloc>
    10ca:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
    10cc:	89 2b       	or	r24, r25
    10ce:	09 f4       	brne	.+2      	; 0x10d2 <xTaskCreate+0x34>
    10d0:	d0 c0       	rjmp	.+416    	; 0x1272 <xTaskCreate+0x1d4>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    10d2:	86 e2       	ldi	r24, 0x26	; 38
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <pvPortMalloc>
    10da:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    10dc:	00 97       	sbiw	r24, 0x00	; 0
    10de:	89 f0       	breq	.+34     	; 0x1102 <xTaskCreate+0x64>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    10e0:	78 8e       	std	Y+24, r7	; 0x18
    10e2:	6f 8a       	std	Y+23, r6	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    10e4:	21 e0       	ldi	r18, 0x01	; 1
    10e6:	a2 1a       	sub	r10, r18
    10e8:	b1 08       	sbc	r11, r1
    10ea:	a6 0c       	add	r10, r6
    10ec:	b7 1c       	adc	r11, r7
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    10ee:	c1 14       	cp	r12, r1
    10f0:	d1 04       	cpc	r13, r1
    10f2:	c9 f0       	breq	.+50     	; 0x1126 <xTaskCreate+0x88>
    10f4:	bc 01       	movw	r22, r24
    10f6:	67 5e       	subi	r22, 0xE7	; 231
    10f8:	7f 4f       	sbci	r23, 0xFF	; 255
    10fa:	f6 01       	movw	r30, r12
    10fc:	c6 01       	movw	r24, r12
    10fe:	08 96       	adiw	r24, 0x08	; 8
    1100:	07 c0       	rjmp	.+14     	; 0x1110 <xTaskCreate+0x72>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1102:	c3 01       	movw	r24, r6
    1104:	0e 94 23 16 	call	0x2c46	; 0x2c46 <vPortFree>
    1108:	b4 c0       	rjmp	.+360    	; 0x1272 <xTaskCreate+0x1d4>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    110a:	e8 17       	cp	r30, r24
    110c:	f9 07       	cpc	r31, r25
    110e:	49 f0       	breq	.+18     	; 0x1122 <xTaskCreate+0x84>
    1110:	9f 01       	movw	r18, r30
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1112:	41 91       	ld	r20, Z+
    1114:	db 01       	movw	r26, r22
    1116:	4d 93       	st	X+, r20
    1118:	bd 01       	movw	r22, r26

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    111a:	d9 01       	movw	r26, r18
    111c:	2c 91       	ld	r18, X
    111e:	21 11       	cpse	r18, r1
    1120:	f4 cf       	rjmp	.-24     	; 0x110a <xTaskCreate+0x6c>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1122:	18 a2       	std	Y+32, r1	; 0x20
    1124:	01 c0       	rjmp	.+2      	; 0x1128 <xTaskCreate+0x8a>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    1126:	19 8e       	std	Y+25, r1	; 0x19
    1128:	04 30       	cpi	r16, 0x04	; 4
    112a:	08 f0       	brcs	.+2      	; 0x112e <xTaskCreate+0x90>
    112c:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    112e:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1130:	6e 01       	movw	r12, r28
    1132:	b2 e0       	ldi	r27, 0x02	; 2
    1134:	cb 0e       	add	r12, r27
    1136:	d1 1c       	adc	r13, r1
    1138:	c6 01       	movw	r24, r12
    113a:	0e 94 aa 13 	call	0x2754	; 0x2754 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    113e:	ce 01       	movw	r24, r28
    1140:	0c 96       	adiw	r24, 0x0c	; 12
    1142:	0e 94 aa 13 	call	0x2754	; 0x2754 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1146:	d9 87       	std	Y+9, r29	; 0x09
    1148:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    114a:	84 e0       	ldi	r24, 0x04	; 4
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	80 1b       	sub	r24, r16
    1150:	91 09       	sbc	r25, r1
    1152:	9d 87       	std	Y+13, r25	; 0x0d
    1154:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1156:	db 8b       	std	Y+19, r29	; 0x13
    1158:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    115a:	19 a2       	std	Y+33, r1	; 0x21
    115c:	1a a2       	std	Y+34, r1	; 0x22
    115e:	1b a2       	std	Y+35, r1	; 0x23
    1160:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1162:	1d a2       	std	Y+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1164:	a2 01       	movw	r20, r4
    1166:	b4 01       	movw	r22, r8
    1168:	c5 01       	movw	r24, r10
    116a:	0e 94 32 16 	call	0x2c64	; 0x2c64 <pxPortInitialiseStack>
    116e:	99 83       	std	Y+1, r25	; 0x01
    1170:	88 83       	st	Y, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    1172:	e1 14       	cp	r14, r1
    1174:	f1 04       	cpc	r15, r1
    1176:	19 f0       	breq	.+6      	; 0x117e <xTaskCreate+0xe0>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1178:	f7 01       	movw	r30, r14
    117a:	d1 83       	std	Z+1, r29	; 0x01
    117c:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    117e:	0f b6       	in	r0, 0x3f	; 63
    1180:	f8 94       	cli
    1182:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1184:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <uxCurrentNumberOfTasks>
    1188:	8f 5f       	subi	r24, 0xFF	; 255
    118a:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    118e:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <pxCurrentTCB>
    1192:	90 91 47 02 	lds	r25, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1196:	89 2b       	or	r24, r25
    1198:	a9 f5       	brne	.+106    	; 0x1204 <xTaskCreate+0x166>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    119a:	d0 93 47 02 	sts	0x0247, r29	; 0x800247 <pxCurrentTCB+0x1>
    119e:	c0 93 46 02 	sts	0x0246, r28	; 0x800246 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    11a2:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <uxCurrentNumberOfTasks>
    11a6:	81 30       	cpi	r24, 0x01	; 1
    11a8:	e9 f5       	brne	.+122    	; 0x1224 <xTaskCreate+0x186>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    11aa:	8f e7       	ldi	r24, 0x7F	; 127
    11ac:	92 e0       	ldi	r25, 0x02	; 2
    11ae:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
    11b2:	88 e8       	ldi	r24, 0x88	; 136
    11b4:	92 e0       	ldi	r25, 0x02	; 2
    11b6:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
    11ba:	81 e9       	ldi	r24, 0x91	; 145
    11bc:	92 e0       	ldi	r25, 0x02	; 2
    11be:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
    11c2:	8a e9       	ldi	r24, 0x9A	; 154
    11c4:	92 e0       	ldi	r25, 0x02	; 2
    11c6:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    11ca:	86 e7       	ldi	r24, 0x76	; 118
    11cc:	92 e0       	ldi	r25, 0x02	; 2
    11ce:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    11d2:	8d e6       	ldi	r24, 0x6D	; 109
    11d4:	92 e0       	ldi	r25, 0x02	; 2
    11d6:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    11da:	80 e6       	ldi	r24, 0x60	; 96
    11dc:	92 e0       	ldi	r25, 0x02	; 2
    11de:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    11e2:	87 e5       	ldi	r24, 0x57	; 87
    11e4:	92 e0       	ldi	r25, 0x02	; 2
    11e6:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    11ea:	86 e7       	ldi	r24, 0x76	; 118
    11ec:	92 e0       	ldi	r25, 0x02	; 2
    11ee:	90 93 6c 02 	sts	0x026C, r25	; 0x80026c <pxDelayedTaskList+0x1>
    11f2:	80 93 6b 02 	sts	0x026B, r24	; 0x80026b <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    11f6:	8d e6       	ldi	r24, 0x6D	; 109
    11f8:	92 e0       	ldi	r25, 0x02	; 2
    11fa:	90 93 6a 02 	sts	0x026A, r25	; 0x80026a <pxOverflowDelayedTaskList+0x1>
    11fe:	80 93 69 02 	sts	0x0269, r24	; 0x800269 <pxOverflowDelayedTaskList>
    1202:	10 c0       	rjmp	.+32     	; 0x1224 <xTaskCreate+0x186>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1204:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <xSchedulerRunning>
    1208:	81 11       	cpse	r24, r1
    120a:	0c c0       	rjmp	.+24     	; 0x1224 <xTaskCreate+0x186>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    120c:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1210:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1214:	96 89       	ldd	r25, Z+22	; 0x16
    1216:	8e 89       	ldd	r24, Y+22	; 0x16
    1218:	89 17       	cp	r24, r25
    121a:	20 f0       	brcs	.+8      	; 0x1224 <xTaskCreate+0x186>
				{
					pxCurrentTCB = pxNewTCB;
    121c:	d0 93 47 02 	sts	0x0247, r29	; 0x800247 <pxCurrentTCB+0x1>
    1220:	c0 93 46 02 	sts	0x0246, r28	; 0x800246 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1224:	80 91 4d 02 	lds	r24, 0x024D	; 0x80024d <uxTaskNumber>
    1228:	8f 5f       	subi	r24, 0xFF	; 255
    122a:	80 93 4d 02 	sts	0x024D, r24	; 0x80024d <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    122e:	8e 89       	ldd	r24, Y+22	; 0x16
    1230:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    1234:	98 17       	cp	r25, r24
    1236:	10 f4       	brcc	.+4      	; 0x123c <xTaskCreate+0x19e>
    1238:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    123c:	f9 e0       	ldi	r31, 0x09	; 9
    123e:	8f 9f       	mul	r24, r31
    1240:	c0 01       	movw	r24, r0
    1242:	11 24       	eor	r1, r1
    1244:	b6 01       	movw	r22, r12
    1246:	81 58       	subi	r24, 0x81	; 129
    1248:	9d 4f       	sbci	r25, 0xFD	; 253
    124a:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    124e:	0f 90       	pop	r0
    1250:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1252:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <xSchedulerRunning>
    1256:	88 23       	and	r24, r24
    1258:	51 f0       	breq	.+20     	; 0x126e <xTaskCreate+0x1d0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    125a:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    125e:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1262:	96 89       	ldd	r25, Z+22	; 0x16
    1264:	8e 89       	ldd	r24, Y+22	; 0x16
    1266:	98 17       	cp	r25, r24
    1268:	10 f4       	brcc	.+4      	; 0x126e <xTaskCreate+0x1d0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    126a:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	01 c0       	rjmp	.+2      	; 0x1274 <xTaskCreate+0x1d6>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1272:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	0f 91       	pop	r16
    127a:	ff 90       	pop	r15
    127c:	ef 90       	pop	r14
    127e:	df 90       	pop	r13
    1280:	cf 90       	pop	r12
    1282:	bf 90       	pop	r11
    1284:	af 90       	pop	r10
    1286:	9f 90       	pop	r9
    1288:	8f 90       	pop	r8
    128a:	7f 90       	pop	r7
    128c:	6f 90       	pop	r6
    128e:	5f 90       	pop	r5
    1290:	4f 90       	pop	r4
    1292:	08 95       	ret

00001294 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1294:	0f 93       	push	r16
    1296:	1f 93       	push	r17
    1298:	cf 93       	push	r28
    129a:	df 93       	push	r29
    129c:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	f8 94       	cli
    12a2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    12a4:	89 2b       	or	r24, r25
    12a6:	21 f4       	brne	.+8      	; 0x12b0 <vTaskDelete+0x1c>
    12a8:	c0 91 46 02 	lds	r28, 0x0246	; 0x800246 <pxCurrentTCB>
    12ac:	d0 91 47 02 	lds	r29, 0x0247	; 0x800247 <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    12b0:	8e 01       	movw	r16, r28
    12b2:	0e 5f       	subi	r16, 0xFE	; 254
    12b4:	1f 4f       	sbci	r17, 0xFF	; 255
    12b6:	c8 01       	movw	r24, r16
    12b8:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    12bc:	8c 89       	ldd	r24, Y+20	; 0x14
    12be:	9d 89       	ldd	r25, Y+21	; 0x15
    12c0:	89 2b       	or	r24, r25
    12c2:	21 f0       	breq	.+8      	; 0x12cc <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    12c4:	ce 01       	movw	r24, r28
    12c6:	0c 96       	adiw	r24, 0x0c	; 12
    12c8:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    12cc:	80 91 4d 02 	lds	r24, 0x024D	; 0x80024d <uxTaskNumber>
    12d0:	8f 5f       	subi	r24, 0xFF	; 255
    12d2:	80 93 4d 02 	sts	0x024D, r24	; 0x80024d <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    12d6:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <pxCurrentTCB>
    12da:	90 91 47 02 	lds	r25, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    12de:	c8 17       	cp	r28, r24
    12e0:	d9 07       	cpc	r29, r25
    12e2:	59 f4       	brne	.+22     	; 0x12fa <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    12e4:	b8 01       	movw	r22, r16
    12e6:	87 e5       	ldi	r24, 0x57	; 87
    12e8:	92 e0       	ldi	r25, 0x02	; 2
    12ea:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    12ee:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <uxDeletedTasksWaitingCleanUp>
    12f2:	8f 5f       	subi	r24, 0xFF	; 255
    12f4:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <uxDeletedTasksWaitingCleanUp>
    12f8:	0e c0       	rjmp	.+28     	; 0x1316 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    12fa:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <uxCurrentNumberOfTasks>
    12fe:	81 50       	subi	r24, 0x01	; 1
    1300:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    1304:	8f 89       	ldd	r24, Y+23	; 0x17
    1306:	98 8d       	ldd	r25, Y+24	; 0x18
    1308:	0e 94 23 16 	call	0x2c46	; 0x2c46 <vPortFree>
			vPortFree( pxTCB );
    130c:	ce 01       	movw	r24, r28
    130e:	0e 94 23 16 	call	0x2c46	; 0x2c46 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    1312:	0e 94 c3 07 	call	0xf86	; 0xf86 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1316:	0f 90       	pop	r0
    1318:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    131a:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <xSchedulerRunning>
    131e:	88 23       	and	r24, r24
    1320:	49 f0       	breq	.+18     	; 0x1334 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
    1322:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <pxCurrentTCB>
    1326:	90 91 47 02 	lds	r25, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    132a:	c8 17       	cp	r28, r24
    132c:	d9 07       	cpc	r29, r25
    132e:	11 f4       	brne	.+4      	; 0x1334 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1330:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1334:	df 91       	pop	r29
    1336:	cf 91       	pop	r28
    1338:	1f 91       	pop	r17
    133a:	0f 91       	pop	r16
    133c:	08 95       	ret

0000133e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    133e:	ef 92       	push	r14
    1340:	ff 92       	push	r15
    1342:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1344:	89 e4       	ldi	r24, 0x49	; 73
    1346:	e8 2e       	mov	r14, r24
    1348:	82 e0       	ldi	r24, 0x02	; 2
    134a:	f8 2e       	mov	r15, r24
    134c:	00 e0       	ldi	r16, 0x00	; 0
    134e:	20 e0       	ldi	r18, 0x00	; 0
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	45 e5       	ldi	r20, 0x55	; 85
    1354:	50 e0       	ldi	r21, 0x00	; 0
    1356:	6b e0       	ldi	r22, 0x0B	; 11
    1358:	72 e0       	ldi	r23, 0x02	; 2
    135a:	81 e2       	ldi	r24, 0x21	; 33
    135c:	98 e0       	ldi	r25, 0x08	; 8
    135e:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1362:	81 30       	cpi	r24, 0x01	; 1
    1364:	91 f4       	brne	.+36     	; 0x138a <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1366:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1368:	2f ef       	ldi	r18, 0xFF	; 255
    136a:	3f ef       	ldi	r19, 0xFF	; 255
    136c:	30 93 4c 02 	sts	0x024C, r19	; 0x80024c <xNextTaskUnblockTime+0x1>
    1370:	20 93 4b 02 	sts	0x024B, r18	; 0x80024b <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    1374:	80 93 51 02 	sts	0x0251, r24	; 0x800251 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    1378:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <xTickCount+0x1>
    137c:	10 92 53 02 	sts	0x0253, r1	; 0x800253 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1380:	0f 91       	pop	r16
    1382:	ff 90       	pop	r15
    1384:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1386:	0c 94 9e 16 	jmp	0x2d3c	; 0x2d3c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    138a:	0f 91       	pop	r16
    138c:	ff 90       	pop	r15
    138e:	ef 90       	pop	r14
    1390:	08 95       	ret

00001392 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1392:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1394:	10 92 51 02 	sts	0x0251, r1	; 0x800251 <xSchedulerRunning>
	vPortEndScheduler();
    1398:	0c 94 d9 16 	jmp	0x2db2	; 0x2db2 <vPortEndScheduler>

0000139c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    139c:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    13a0:	8f 5f       	subi	r24, 0xFF	; 255
    13a2:	80 93 48 02 	sts	0x0248, r24	; 0x800248 <uxSchedulerSuspended>
    13a6:	08 95       	ret

000013a8 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    13a8:	0f b6       	in	r0, 0x3f	; 63
    13aa:	f8 94       	cli
    13ac:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    13ae:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <xTickCount>
    13b2:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
    13b6:	0f 90       	pop	r0
    13b8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    13ba:	08 95       	ret

000013bc <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    13bc:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <xTickCount>
    13c0:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13c4:	08 95       	ret

000013c6 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    13c6:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <uxCurrentNumberOfTasks>
}
    13ca:	08 95       	ret

000013cc <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    13cc:	00 97       	sbiw	r24, 0x00	; 0
    13ce:	21 f4       	brne	.+8      	; 0x13d8 <pcTaskGetName+0xc>
    13d0:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <pxCurrentTCB>
    13d4:	90 91 47 02 	lds	r25, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
    13d8:	49 96       	adiw	r24, 0x19	; 25
    13da:	08 95       	ret

000013dc <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    13dc:	cf 92       	push	r12
    13de:	df 92       	push	r13
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    13ec:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    13f0:	81 11       	cpse	r24, r1
    13f2:	8c c0       	rjmp	.+280    	; 0x150c <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    13f4:	00 91 53 02 	lds	r16, 0x0253	; 0x800253 <xTickCount>
    13f8:	10 91 54 02 	lds	r17, 0x0254	; 0x800254 <xTickCount+0x1>
    13fc:	0f 5f       	subi	r16, 0xFF	; 255
    13fe:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1400:	10 93 54 02 	sts	0x0254, r17	; 0x800254 <xTickCount+0x1>
    1404:	00 93 53 02 	sts	0x0253, r16	; 0x800253 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1408:	01 15       	cp	r16, r1
    140a:	11 05       	cpc	r17, r1
    140c:	b9 f4       	brne	.+46     	; 0x143c <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
    140e:	80 91 6b 02 	lds	r24, 0x026B	; 0x80026b <pxDelayedTaskList>
    1412:	90 91 6c 02 	lds	r25, 0x026C	; 0x80026c <pxDelayedTaskList+0x1>
    1416:	20 91 69 02 	lds	r18, 0x0269	; 0x800269 <pxOverflowDelayedTaskList>
    141a:	30 91 6a 02 	lds	r19, 0x026A	; 0x80026a <pxOverflowDelayedTaskList+0x1>
    141e:	30 93 6c 02 	sts	0x026C, r19	; 0x80026c <pxDelayedTaskList+0x1>
    1422:	20 93 6b 02 	sts	0x026B, r18	; 0x80026b <pxDelayedTaskList>
    1426:	90 93 6a 02 	sts	0x026A, r25	; 0x80026a <pxOverflowDelayedTaskList+0x1>
    142a:	80 93 69 02 	sts	0x0269, r24	; 0x800269 <pxOverflowDelayedTaskList>
    142e:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <xNumOfOverflows>
    1432:	8f 5f       	subi	r24, 0xFF	; 255
    1434:	80 93 4e 02 	sts	0x024E, r24	; 0x80024e <xNumOfOverflows>
    1438:	0e 94 c3 07 	call	0xf86	; 0xf86 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    143c:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <xNextTaskUnblockTime>
    1440:	90 91 4c 02 	lds	r25, 0x024C	; 0x80024c <xNextTaskUnblockTime+0x1>
    1444:	c0 e0       	ldi	r28, 0x00	; 0
    1446:	08 17       	cp	r16, r24
    1448:	19 07       	cpc	r17, r25
    144a:	08 f4       	brcc	.+2      	; 0x144e <xTaskIncrementTick+0x72>
    144c:	4f c0       	rjmp	.+158    	; 0x14ec <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    144e:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1450:	e0 91 6b 02 	lds	r30, 0x026B	; 0x80026b <pxDelayedTaskList>
    1454:	f0 91 6c 02 	lds	r31, 0x026C	; 0x80026c <pxDelayedTaskList+0x1>
    1458:	80 81       	ld	r24, Z
    145a:	81 11       	cpse	r24, r1
    145c:	03 c0       	rjmp	.+6      	; 0x1464 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    145e:	8f ef       	ldi	r24, 0xFF	; 255
    1460:	9f ef       	ldi	r25, 0xFF	; 255
    1462:	11 c0       	rjmp	.+34     	; 0x1486 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1464:	e0 91 6b 02 	lds	r30, 0x026B	; 0x80026b <pxDelayedTaskList>
    1468:	f0 91 6c 02 	lds	r31, 0x026C	; 0x80026c <pxDelayedTaskList+0x1>
    146c:	05 80       	ldd	r0, Z+5	; 0x05
    146e:	f6 81       	ldd	r31, Z+6	; 0x06
    1470:	e0 2d       	mov	r30, r0
    1472:	e6 80       	ldd	r14, Z+6	; 0x06
    1474:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1476:	d7 01       	movw	r26, r14
    1478:	12 96       	adiw	r26, 0x02	; 2
    147a:	8d 91       	ld	r24, X+
    147c:	9c 91       	ld	r25, X
    147e:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
    1480:	08 17       	cp	r16, r24
    1482:	19 07       	cpc	r17, r25
    1484:	28 f4       	brcc	.+10     	; 0x1490 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1486:	90 93 4c 02 	sts	0x024C, r25	; 0x80024c <xNextTaskUnblockTime+0x1>
    148a:	80 93 4b 02 	sts	0x024B, r24	; 0x80024b <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    148e:	2e c0       	rjmp	.+92     	; 0x14ec <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1490:	67 01       	movw	r12, r14
    1492:	b2 e0       	ldi	r27, 0x02	; 2
    1494:	cb 0e       	add	r12, r27
    1496:	d1 1c       	adc	r13, r1
    1498:	c6 01       	movw	r24, r12
    149a:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    149e:	f7 01       	movw	r30, r14
    14a0:	84 89       	ldd	r24, Z+20	; 0x14
    14a2:	95 89       	ldd	r25, Z+21	; 0x15
    14a4:	89 2b       	or	r24, r25
    14a6:	21 f0       	breq	.+8      	; 0x14b0 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    14a8:	c7 01       	movw	r24, r14
    14aa:	0c 96       	adiw	r24, 0x0c	; 12
    14ac:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    14b0:	d7 01       	movw	r26, r14
    14b2:	56 96       	adiw	r26, 0x16	; 22
    14b4:	8c 91       	ld	r24, X
    14b6:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    14ba:	98 17       	cp	r25, r24
    14bc:	10 f4       	brcc	.+4      	; 0x14c2 <xTaskIncrementTick+0xe6>
    14be:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    14c2:	d8 9f       	mul	r29, r24
    14c4:	c0 01       	movw	r24, r0
    14c6:	11 24       	eor	r1, r1
    14c8:	b6 01       	movw	r22, r12
    14ca:	81 58       	subi	r24, 0x81	; 129
    14cc:	9d 4f       	sbci	r25, 0xFD	; 253
    14ce:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    14d2:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    14d6:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    14da:	d7 01       	movw	r26, r14
    14dc:	56 96       	adiw	r26, 0x16	; 22
    14de:	9c 91       	ld	r25, X
    14e0:	86 89       	ldd	r24, Z+22	; 0x16
    14e2:	98 17       	cp	r25, r24
    14e4:	08 f4       	brcc	.+2      	; 0x14e8 <xTaskIncrementTick+0x10c>
    14e6:	b4 cf       	rjmp	.-152    	; 0x1450 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
    14e8:	c1 e0       	ldi	r28, 0x01	; 1
    14ea:	b2 cf       	rjmp	.-156    	; 0x1450 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    14ec:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    14f0:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    14f4:	e6 89       	ldd	r30, Z+22	; 0x16
    14f6:	b9 e0       	ldi	r27, 0x09	; 9
    14f8:	eb 9f       	mul	r30, r27
    14fa:	f0 01       	movw	r30, r0
    14fc:	11 24       	eor	r1, r1
    14fe:	e1 58       	subi	r30, 0x81	; 129
    1500:	fd 4f       	sbci	r31, 0xFD	; 253
    1502:	80 81       	ld	r24, Z
    1504:	82 30       	cpi	r24, 0x02	; 2
    1506:	40 f0       	brcs	.+16     	; 0x1518 <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
    1508:	c1 e0       	ldi	r28, 0x01	; 1
    150a:	06 c0       	rjmp	.+12     	; 0x1518 <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    150c:	80 91 50 02 	lds	r24, 0x0250	; 0x800250 <uxPendedTicks>
    1510:	8f 5f       	subi	r24, 0xFF	; 255
    1512:	80 93 50 02 	sts	0x0250, r24	; 0x800250 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1516:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1518:	80 91 4f 02 	lds	r24, 0x024F	; 0x80024f <xYieldPending>
    151c:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
    151e:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1520:	8c 2f       	mov	r24, r28
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	1f 91       	pop	r17
    1528:	0f 91       	pop	r16
    152a:	ff 90       	pop	r15
    152c:	ef 90       	pop	r14
    152e:	df 90       	pop	r13
    1530:	cf 90       	pop	r12
    1532:	08 95       	ret

00001534 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1534:	ef 92       	push	r14
    1536:	ff 92       	push	r15
    1538:	0f 93       	push	r16
    153a:	1f 93       	push	r17
    153c:	cf 93       	push	r28
    153e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1540:	0f b6       	in	r0, 0x3f	; 63
    1542:	f8 94       	cli
    1544:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1546:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    154a:	81 50       	subi	r24, 0x01	; 1
    154c:	80 93 48 02 	sts	0x0248, r24	; 0x800248 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1550:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    1554:	88 23       	and	r24, r24
    1556:	11 f0       	breq	.+4      	; 0x155c <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	52 c0       	rjmp	.+164    	; 0x1600 <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    155c:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <uxCurrentNumberOfTasks>
    1560:	88 23       	and	r24, r24
    1562:	d1 f3       	breq	.-12     	; 0x1558 <xTaskResumeAll+0x24>
    1564:	c0 e0       	ldi	r28, 0x00	; 0
    1566:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
    1568:	89 e0       	ldi	r24, 0x09	; 9
    156a:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    156c:	ee 24       	eor	r14, r14
    156e:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1570:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <xPendingReadyList>
    1574:	88 23       	and	r24, r24
    1576:	51 f1       	breq	.+84     	; 0x15cc <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1578:	e0 91 65 02 	lds	r30, 0x0265	; 0x800265 <xPendingReadyList+0x5>
    157c:	f0 91 66 02 	lds	r31, 0x0266	; 0x800266 <xPendingReadyList+0x6>
    1580:	c6 81       	ldd	r28, Z+6	; 0x06
    1582:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1584:	ce 01       	movw	r24, r28
    1586:	0c 96       	adiw	r24, 0x0c	; 12
    1588:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    158c:	8e 01       	movw	r16, r28
    158e:	0e 5f       	subi	r16, 0xFE	; 254
    1590:	1f 4f       	sbci	r17, 0xFF	; 255
    1592:	c8 01       	movw	r24, r16
    1594:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1598:	8e 89       	ldd	r24, Y+22	; 0x16
    159a:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    159e:	98 17       	cp	r25, r24
    15a0:	10 f4       	brcc	.+4      	; 0x15a6 <xTaskResumeAll+0x72>
    15a2:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    15a6:	f8 9e       	mul	r15, r24
    15a8:	c0 01       	movw	r24, r0
    15aa:	11 24       	eor	r1, r1
    15ac:	b8 01       	movw	r22, r16
    15ae:	81 58       	subi	r24, 0x81	; 129
    15b0:	9d 4f       	sbci	r25, 0xFD	; 253
    15b2:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    15b6:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    15ba:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    15be:	9e 89       	ldd	r25, Y+22	; 0x16
    15c0:	86 89       	ldd	r24, Z+22	; 0x16
    15c2:	98 17       	cp	r25, r24
    15c4:	a8 f2       	brcs	.-86     	; 0x1570 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
    15c6:	e0 92 4f 02 	sts	0x024F, r14	; 0x80024f <xYieldPending>
    15ca:	d2 cf       	rjmp	.-92     	; 0x1570 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    15cc:	cd 2b       	or	r28, r29
    15ce:	11 f0       	breq	.+4      	; 0x15d4 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    15d0:	0e 94 c3 07 	call	0xf86	; 0xf86 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    15d4:	c0 91 50 02 	lds	r28, 0x0250	; 0x800250 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    15d8:	cc 23       	and	r28, r28
    15da:	51 f0       	breq	.+20     	; 0x15f0 <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    15dc:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    15de:	0e 94 ee 09 	call	0x13dc	; 0x13dc <xTaskIncrementTick>
    15e2:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
    15e4:	d0 93 4f 02 	sts	0x024F, r29	; 0x80024f <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    15e8:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    15ea:	c9 f7       	brne	.-14     	; 0x15de <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
    15ec:	10 92 50 02 	sts	0x0250, r1	; 0x800250 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    15f0:	80 91 4f 02 	lds	r24, 0x024F	; 0x80024f <xYieldPending>
    15f4:	88 23       	and	r24, r24
    15f6:	09 f4       	brne	.+2      	; 0x15fa <xTaskResumeAll+0xc6>
    15f8:	af cf       	rjmp	.-162    	; 0x1558 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    15fa:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    15fe:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1600:	0f 90       	pop	r0
    1602:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1604:	df 91       	pop	r29
    1606:	cf 91       	pop	r28
    1608:	1f 91       	pop	r17
    160a:	0f 91       	pop	r16
    160c:	ff 90       	pop	r15
    160e:	ef 90       	pop	r14
    1610:	08 95       	ret

00001612 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1612:	0f 93       	push	r16
    1614:	1f 93       	push	r17
    1616:	cf 93       	push	r28
    1618:	df 93       	push	r29
    161a:	8c 01       	movw	r16, r24
    161c:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    161e:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1622:	40 91 53 02 	lds	r20, 0x0253	; 0x800253 <xTickCount>
    1626:	50 91 54 02 	lds	r21, 0x0254	; 0x800254 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    162a:	f8 01       	movw	r30, r16
    162c:	20 81       	ld	r18, Z
    162e:	31 81       	ldd	r19, Z+1	; 0x01
    1630:	c9 01       	movw	r24, r18
    1632:	8c 0f       	add	r24, r28
    1634:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    1636:	42 17       	cp	r20, r18
    1638:	53 07       	cpc	r21, r19
    163a:	20 f4       	brcc	.+8      	; 0x1644 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    163c:	82 17       	cp	r24, r18
    163e:	93 07       	cpc	r25, r19
    1640:	40 f4       	brcc	.+16     	; 0x1652 <vTaskDelayUntil+0x40>
    1642:	03 c0       	rjmp	.+6      	; 0x164a <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1644:	82 17       	cp	r24, r18
    1646:	93 07       	cpc	r25, r19
    1648:	30 f0       	brcs	.+12     	; 0x1656 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    164a:	21 e0       	ldi	r18, 0x01	; 1
    164c:	48 17       	cp	r20, r24
    164e:	59 07       	cpc	r21, r25
    1650:	18 f0       	brcs	.+6      	; 0x1658 <vTaskDelayUntil+0x46>
    1652:	20 e0       	ldi	r18, 0x00	; 0
    1654:	01 c0       	rjmp	.+2      	; 0x1658 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1656:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1658:	f8 01       	movw	r30, r16
    165a:	91 83       	std	Z+1, r25	; 0x01
    165c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    165e:	22 23       	and	r18, r18
    1660:	21 f0       	breq	.+8      	; 0x166a <vTaskDelayUntil+0x58>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1662:	84 1b       	sub	r24, r20
    1664:	95 0b       	sbc	r25, r21
    1666:	0e 94 de 07 	call	0xfbc	; 0xfbc <prvAddCurrentTaskToDelayedList.isra.2>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    166a:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    166e:	81 11       	cpse	r24, r1
    1670:	02 c0       	rjmp	.+4      	; 0x1676 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
    1672:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1676:	df 91       	pop	r29
    1678:	cf 91       	pop	r28
    167a:	1f 91       	pop	r17
    167c:	0f 91       	pop	r16
    167e:	08 95       	ret

00001680 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1680:	cf 93       	push	r28
    1682:	df 93       	push	r29
    1684:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1686:	89 2b       	or	r24, r25
    1688:	19 f4       	brne	.+6      	; 0x1690 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    168a:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
    168e:	09 c0       	rjmp	.+18     	; 0x16a2 <vTaskDelay+0x22>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1690:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1694:	ce 01       	movw	r24, r28
    1696:	0e 94 de 07 	call	0xfbc	; 0xfbc <prvAddCurrentTaskToDelayedList.isra.2>
			}
			xAlreadyYielded = xTaskResumeAll();
    169a:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    169e:	88 23       	and	r24, r24
    16a0:	a1 f3       	breq	.-24     	; 0x168a <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    16a2:	df 91       	pop	r29
    16a4:	cf 91       	pop	r28
    16a6:	08 95       	ret

000016a8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    16a8:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    16ac:	88 23       	and	r24, r24
    16ae:	21 f0       	breq	.+8      	; 0x16b8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	80 93 4f 02 	sts	0x024F, r24	; 0x80024f <xYieldPending>
    16b6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    16b8:	10 92 4f 02 	sts	0x024F, r1	; 0x80024f <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    16bc:	80 91 52 02 	lds	r24, 0x0252	; 0x800252 <uxTopReadyPriority>
    16c0:	69 e0       	ldi	r22, 0x09	; 9
    16c2:	48 2f       	mov	r20, r24
    16c4:	50 e0       	ldi	r21, 0x00	; 0
    16c6:	64 9f       	mul	r22, r20
    16c8:	90 01       	movw	r18, r0
    16ca:	65 9f       	mul	r22, r21
    16cc:	30 0d       	add	r19, r0
    16ce:	11 24       	eor	r1, r1
    16d0:	f9 01       	movw	r30, r18
    16d2:	e1 58       	subi	r30, 0x81	; 129
    16d4:	fd 4f       	sbci	r31, 0xFD	; 253
    16d6:	90 81       	ld	r25, Z
    16d8:	91 11       	cpse	r25, r1
    16da:	02 c0       	rjmp	.+4      	; 0x16e0 <vTaskSwitchContext+0x38>
    16dc:	81 50       	subi	r24, 0x01	; 1
    16de:	f1 cf       	rjmp	.-30     	; 0x16c2 <vTaskSwitchContext+0x1a>
    16e0:	a1 81       	ldd	r26, Z+1	; 0x01
    16e2:	b2 81       	ldd	r27, Z+2	; 0x02
    16e4:	12 96       	adiw	r26, 0x02	; 2
    16e6:	0d 90       	ld	r0, X+
    16e8:	bc 91       	ld	r27, X
    16ea:	a0 2d       	mov	r26, r0
    16ec:	b2 83       	std	Z+2, r27	; 0x02
    16ee:	a1 83       	std	Z+1, r26	; 0x01
    16f0:	2e 57       	subi	r18, 0x7E	; 126
    16f2:	3d 4f       	sbci	r19, 0xFD	; 253
    16f4:	a2 17       	cp	r26, r18
    16f6:	b3 07       	cpc	r27, r19
    16f8:	31 f4       	brne	.+12     	; 0x1706 <vTaskSwitchContext+0x5e>
    16fa:	12 96       	adiw	r26, 0x02	; 2
    16fc:	2d 91       	ld	r18, X+
    16fe:	3c 91       	ld	r19, X
    1700:	13 97       	sbiw	r26, 0x03	; 3
    1702:	32 83       	std	Z+2, r19	; 0x02
    1704:	21 83       	std	Z+1, r18	; 0x01
    1706:	99 e0       	ldi	r25, 0x09	; 9
    1708:	94 9f       	mul	r25, r20
    170a:	f0 01       	movw	r30, r0
    170c:	95 9f       	mul	r25, r21
    170e:	f0 0d       	add	r31, r0
    1710:	11 24       	eor	r1, r1
    1712:	e1 58       	subi	r30, 0x81	; 129
    1714:	fd 4f       	sbci	r31, 0xFD	; 253
    1716:	01 80       	ldd	r0, Z+1	; 0x01
    1718:	f2 81       	ldd	r31, Z+2	; 0x02
    171a:	e0 2d       	mov	r30, r0
    171c:	26 81       	ldd	r18, Z+6	; 0x06
    171e:	37 81       	ldd	r19, Z+7	; 0x07
    1720:	30 93 47 02 	sts	0x0247, r19	; 0x800247 <pxCurrentTCB+0x1>
    1724:	20 93 46 02 	sts	0x0246, r18	; 0x800246 <pxCurrentTCB>
    1728:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    172c:	08 95       	ret

0000172e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    172e:	cf 93       	push	r28
    1730:	df 93       	push	r29
    1732:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1734:	60 91 46 02 	lds	r22, 0x0246	; 0x800246 <pxCurrentTCB>
    1738:	70 91 47 02 	lds	r23, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    173c:	64 5f       	subi	r22, 0xF4	; 244
    173e:	7f 4f       	sbci	r23, 0xFF	; 255
    1740:	0e 94 cf 13 	call	0x279e	; 0x279e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1744:	ce 01       	movw	r24, r28
}
    1746:	df 91       	pop	r29
    1748:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    174a:	0c 94 de 07 	jmp	0xfbc	; 0xfbc <prvAddCurrentTaskToDelayedList.isra.2>

0000174e <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    174e:	cf 93       	push	r28
    1750:	df 93       	push	r29
    1752:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1754:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1758:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    175c:	70 68       	ori	r23, 0x80	; 128
    175e:	75 87       	std	Z+13, r23	; 0x0d
    1760:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1762:	60 91 46 02 	lds	r22, 0x0246	; 0x800246 <pxCurrentTCB>
    1766:	70 91 47 02 	lds	r23, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    176a:	64 5f       	subi	r22, 0xF4	; 244
    176c:	7f 4f       	sbci	r23, 0xFF	; 255
    176e:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1772:	ce 01       	movw	r24, r28
}
    1774:	df 91       	pop	r29
    1776:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1778:	0c 94 de 07 	jmp	0xfbc	; 0xfbc <prvAddCurrentTaskToDelayedList.isra.2>

0000177c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    177c:	0f 93       	push	r16
    177e:	1f 93       	push	r17
    1780:	cf 93       	push	r28
    1782:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1784:	dc 01       	movw	r26, r24
    1786:	15 96       	adiw	r26, 0x05	; 5
    1788:	ed 91       	ld	r30, X+
    178a:	fc 91       	ld	r31, X
    178c:	16 97       	sbiw	r26, 0x06	; 6
    178e:	c6 81       	ldd	r28, Z+6	; 0x06
    1790:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1792:	8e 01       	movw	r16, r28
    1794:	04 5f       	subi	r16, 0xF4	; 244
    1796:	1f 4f       	sbci	r17, 0xFF	; 255
    1798:	c8 01       	movw	r24, r16
    179a:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    179e:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    17a2:	81 11       	cpse	r24, r1
    17a4:	14 c0       	rjmp	.+40     	; 0x17ce <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    17a6:	0a 50       	subi	r16, 0x0A	; 10
    17a8:	11 09       	sbc	r17, r1
    17aa:	c8 01       	movw	r24, r16
    17ac:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    17b0:	8e 89       	ldd	r24, Y+22	; 0x16
    17b2:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    17b6:	98 17       	cp	r25, r24
    17b8:	10 f4       	brcc	.+4      	; 0x17be <xTaskRemoveFromEventList+0x42>
    17ba:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    17be:	b9 e0       	ldi	r27, 0x09	; 9
    17c0:	8b 9f       	mul	r24, r27
    17c2:	c0 01       	movw	r24, r0
    17c4:	11 24       	eor	r1, r1
    17c6:	b8 01       	movw	r22, r16
    17c8:	81 58       	subi	r24, 0x81	; 129
    17ca:	9d 4f       	sbci	r25, 0xFD	; 253
    17cc:	03 c0       	rjmp	.+6      	; 0x17d4 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    17ce:	b8 01       	movw	r22, r16
    17d0:	80 e6       	ldi	r24, 0x60	; 96
    17d2:	92 e0       	ldi	r25, 0x02	; 2
    17d4:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    17d8:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    17dc:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    17e0:	9e 89       	ldd	r25, Y+22	; 0x16
    17e2:	86 89       	ldd	r24, Z+22	; 0x16
    17e4:	89 17       	cp	r24, r25
    17e6:	20 f4       	brcc	.+8      	; 0x17f0 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    17e8:	81 e0       	ldi	r24, 0x01	; 1
    17ea:	80 93 4f 02 	sts	0x024F, r24	; 0x80024f <xYieldPending>
    17ee:	01 c0       	rjmp	.+2      	; 0x17f2 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
    17f0:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    17f2:	df 91       	pop	r29
    17f4:	cf 91       	pop	r28
    17f6:	1f 91       	pop	r17
    17f8:	0f 91       	pop	r16
    17fa:	08 95       	ret

000017fc <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    17fc:	0f 93       	push	r16
    17fe:	1f 93       	push	r17
    1800:	cf 93       	push	r28
    1802:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1804:	70 68       	ori	r23, 0x80	; 128
    1806:	fc 01       	movw	r30, r24
    1808:	71 83       	std	Z+1, r23	; 0x01
    180a:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    180c:	c6 81       	ldd	r28, Z+6	; 0x06
    180e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1810:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1814:	8e 01       	movw	r16, r28
    1816:	0e 5f       	subi	r16, 0xFE	; 254
    1818:	1f 4f       	sbci	r17, 0xFF	; 255
    181a:	c8 01       	movw	r24, r16
    181c:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1820:	8e 89       	ldd	r24, Y+22	; 0x16
    1822:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    1826:	98 17       	cp	r25, r24
    1828:	10 f4       	brcc	.+4      	; 0x182e <vTaskRemoveFromUnorderedEventList+0x32>
    182a:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    182e:	f9 e0       	ldi	r31, 0x09	; 9
    1830:	8f 9f       	mul	r24, r31
    1832:	c0 01       	movw	r24, r0
    1834:	11 24       	eor	r1, r1
    1836:	b8 01       	movw	r22, r16
    1838:	81 58       	subi	r24, 0x81	; 129
    183a:	9d 4f       	sbci	r25, 0xFD	; 253
    183c:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1840:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1844:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1848:	9e 89       	ldd	r25, Y+22	; 0x16
    184a:	86 89       	ldd	r24, Z+22	; 0x16
    184c:	89 17       	cp	r24, r25
    184e:	18 f4       	brcc	.+6      	; 0x1856 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	80 93 4f 02 	sts	0x024F, r24	; 0x80024f <xYieldPending>
	}
}
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	1f 91       	pop	r17
    185c:	0f 91       	pop	r16
    185e:	08 95       	ret

00001860 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	f8 94       	cli
    1864:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    1866:	20 91 4e 02 	lds	r18, 0x024E	; 0x80024e <xNumOfOverflows>
    186a:	fc 01       	movw	r30, r24
    186c:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    186e:	20 91 53 02 	lds	r18, 0x0253	; 0x800253 <xTickCount>
    1872:	30 91 54 02 	lds	r19, 0x0254	; 0x800254 <xTickCount+0x1>
    1876:	32 83       	std	Z+2, r19	; 0x02
    1878:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    187a:	0f 90       	pop	r0
    187c:	0f be       	out	0x3f, r0	; 63
    187e:	08 95       	ret

00001880 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1880:	20 91 4e 02 	lds	r18, 0x024E	; 0x80024e <xNumOfOverflows>
    1884:	fc 01       	movw	r30, r24
    1886:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1888:	20 91 53 02 	lds	r18, 0x0253	; 0x800253 <xTickCount>
    188c:	30 91 54 02 	lds	r19, 0x0254	; 0x800254 <xTickCount+0x1>
    1890:	32 83       	std	Z+2, r19	; 0x02
    1892:	21 83       	std	Z+1, r18	; 0x01
    1894:	08 95       	ret

00001896 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	f8 94       	cli
    189a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    189c:	20 91 53 02 	lds	r18, 0x0253	; 0x800253 <xTickCount>
    18a0:	30 91 54 02 	lds	r19, 0x0254	; 0x800254 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    18a4:	dc 01       	movw	r26, r24
    18a6:	11 96       	adiw	r26, 0x01	; 1
    18a8:	4d 91       	ld	r20, X+
    18aa:	5c 91       	ld	r21, X
    18ac:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    18ae:	e0 91 4e 02 	lds	r30, 0x024E	; 0x80024e <xNumOfOverflows>
    18b2:	fc 91       	ld	r31, X
    18b4:	fe 17       	cp	r31, r30
    18b6:	19 f0       	breq	.+6      	; 0x18be <xTaskCheckForTimeOut+0x28>
    18b8:	24 17       	cp	r18, r20
    18ba:	35 07       	cpc	r19, r21
    18bc:	90 f4       	brcc	.+36     	; 0x18e2 <xTaskCheckForTimeOut+0x4c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    18be:	24 1b       	sub	r18, r20
    18c0:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    18c2:	fb 01       	movw	r30, r22
    18c4:	40 81       	ld	r20, Z
    18c6:	51 81       	ldd	r21, Z+1	; 0x01
    18c8:	24 17       	cp	r18, r20
    18ca:	35 07       	cpc	r19, r21
    18cc:	40 f4       	brcc	.+16     	; 0x18de <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    18ce:	42 1b       	sub	r20, r18
    18d0:	53 0b       	sbc	r21, r19
    18d2:	51 83       	std	Z+1, r21	; 0x01
    18d4:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    18d6:	0e 94 40 0c 	call	0x1880	; 0x1880 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    18da:	80 e0       	ldi	r24, 0x00	; 0
    18dc:	03 c0       	rjmp	.+6      	; 0x18e4 <xTaskCheckForTimeOut+0x4e>
		}
		else
		{
			*pxTicksToWait = 0;
    18de:	11 82       	std	Z+1, r1	; 0x01
    18e0:	10 82       	st	Z, r1
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    18e2:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    18e4:	0f 90       	pop	r0
    18e6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    18e8:	08 95       	ret

000018ea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    18ea:	81 e0       	ldi	r24, 0x01	; 1
    18ec:	80 93 4f 02 	sts	0x024F, r24	; 0x80024f <xYieldPending>
    18f0:	08 95       	ret

000018f2 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    18f2:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    18f6:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    18fa:	84 85       	ldd	r24, Z+12	; 0x0c
    18fc:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18fe:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1902:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1906:	a0 91 46 02 	lds	r26, 0x0246	; 0x800246 <pxCurrentTCB>
    190a:	b0 91 47 02 	lds	r27, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    190e:	56 96       	adiw	r26, 0x16	; 22
    1910:	4c 91       	ld	r20, X
    1912:	24 e0       	ldi	r18, 0x04	; 4
    1914:	30 e0       	ldi	r19, 0x00	; 0
    1916:	24 1b       	sub	r18, r20
    1918:	31 09       	sbc	r19, r1
    191a:	35 87       	std	Z+13, r19	; 0x0d
    191c:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    191e:	08 95       	ret

00001920 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1920:	0f 93       	push	r16
    1922:	1f 93       	push	r17
    1924:	18 2f       	mov	r17, r24
    1926:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    192e:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1932:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1936:	41 a1       	ldd	r20, Z+33	; 0x21
    1938:	52 a1       	ldd	r21, Z+34	; 0x22
    193a:	63 a1       	ldd	r22, Z+35	; 0x23
    193c:	74 a1       	ldd	r23, Z+36	; 0x24
    193e:	45 2b       	or	r20, r21
    1940:	46 2b       	or	r20, r22
    1942:	47 2b       	or	r20, r23
    1944:	61 f4       	brne	.+24     	; 0x195e <ulTaskNotifyTake+0x3e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1946:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    194a:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    194e:	21 e0       	ldi	r18, 0x01	; 1
    1950:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1952:	00 97       	sbiw	r24, 0x00	; 0
    1954:	21 f0       	breq	.+8      	; 0x195e <ulTaskNotifyTake+0x3e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1956:	0e 94 de 07 	call	0xfbc	; 0xfbc <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    195a:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    195e:	0f 90       	pop	r0
    1960:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1968:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    196c:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1970:	61 a1       	ldd	r22, Z+33	; 0x21
    1972:	72 a1       	ldd	r23, Z+34	; 0x22
    1974:	83 a1       	ldd	r24, Z+35	; 0x23
    1976:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    1978:	61 15       	cp	r22, r1
    197a:	71 05       	cpc	r23, r1
    197c:	81 05       	cpc	r24, r1
    197e:	91 05       	cpc	r25, r1
    1980:	a9 f0       	breq	.+42     	; 0x19ac <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    1982:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1986:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    198a:	11 23       	and	r17, r17
    198c:	29 f0       	breq	.+10     	; 0x1998 <ulTaskNotifyTake+0x78>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    198e:	11 a2       	std	Z+33, r1	; 0x21
    1990:	12 a2       	std	Z+34, r1	; 0x22
    1992:	13 a2       	std	Z+35, r1	; 0x23
    1994:	14 a2       	std	Z+36, r1	; 0x24
    1996:	0a c0       	rjmp	.+20     	; 0x19ac <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    1998:	8b 01       	movw	r16, r22
    199a:	9c 01       	movw	r18, r24
    199c:	01 50       	subi	r16, 0x01	; 1
    199e:	11 09       	sbc	r17, r1
    19a0:	21 09       	sbc	r18, r1
    19a2:	31 09       	sbc	r19, r1
    19a4:	01 a3       	std	Z+33, r16	; 0x21
    19a6:	12 a3       	std	Z+34, r17	; 0x22
    19a8:	23 a3       	std	Z+35, r18	; 0x23
    19aa:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    19ac:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    19b0:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    19b4:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    19b6:	0f 90       	pop	r0
    19b8:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    19ba:	1f 91       	pop	r17
    19bc:	0f 91       	pop	r16
    19be:	08 95       	ret

000019c0 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    19c0:	4f 92       	push	r4
    19c2:	5f 92       	push	r5
    19c4:	6f 92       	push	r6
    19c6:	7f 92       	push	r7
    19c8:	8f 92       	push	r8
    19ca:	9f 92       	push	r9
    19cc:	af 92       	push	r10
    19ce:	bf 92       	push	r11
    19d0:	ef 92       	push	r14
    19d2:	ff 92       	push	r15
    19d4:	0f 93       	push	r16
    19d6:	1f 93       	push	r17
    19d8:	49 01       	movw	r8, r18
    19da:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    19dc:	0f b6       	in	r0, 0x3f	; 63
    19de:	f8 94       	cli
    19e0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    19e2:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    19e6:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    19ea:	25 a1       	ldd	r18, Z+37	; 0x25
    19ec:	22 30       	cpi	r18, 0x02	; 2
    19ee:	31 f1       	breq	.+76     	; 0x1a3c <xTaskNotifyWait+0x7c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    19f0:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    19f4:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    19f8:	21 a1       	ldd	r18, Z+33	; 0x21
    19fa:	32 a1       	ldd	r19, Z+34	; 0x22
    19fc:	43 a1       	ldd	r20, Z+35	; 0x23
    19fe:	54 a1       	ldd	r21, Z+36	; 0x24
    1a00:	2b 01       	movw	r4, r22
    1a02:	3c 01       	movw	r6, r24
    1a04:	40 94       	com	r4
    1a06:	50 94       	com	r5
    1a08:	60 94       	com	r6
    1a0a:	70 94       	com	r7
    1a0c:	d3 01       	movw	r26, r6
    1a0e:	c2 01       	movw	r24, r4
    1a10:	82 23       	and	r24, r18
    1a12:	93 23       	and	r25, r19
    1a14:	a4 23       	and	r26, r20
    1a16:	b5 23       	and	r27, r21
    1a18:	81 a3       	std	Z+33, r24	; 0x21
    1a1a:	92 a3       	std	Z+34, r25	; 0x22
    1a1c:	a3 a3       	std	Z+35, r26	; 0x23
    1a1e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1a20:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1a24:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1a2c:	e1 14       	cp	r14, r1
    1a2e:	f1 04       	cpc	r15, r1
    1a30:	29 f0       	breq	.+10     	; 0x1a3c <xTaskNotifyWait+0x7c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1a32:	c7 01       	movw	r24, r14
    1a34:	0e 94 de 07 	call	0xfbc	; 0xfbc <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1a38:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1a40:	0f b6       	in	r0, 0x3f	; 63
    1a42:	f8 94       	cli
    1a44:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1a46:	01 15       	cp	r16, r1
    1a48:	11 05       	cpc	r17, r1
    1a4a:	69 f0       	breq	.+26     	; 0x1a66 <xTaskNotifyWait+0xa6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1a4c:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1a50:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1a54:	81 a1       	ldd	r24, Z+33	; 0x21
    1a56:	92 a1       	ldd	r25, Z+34	; 0x22
    1a58:	a3 a1       	ldd	r26, Z+35	; 0x23
    1a5a:	b4 a1       	ldd	r27, Z+36	; 0x24
    1a5c:	f8 01       	movw	r30, r16
    1a5e:	80 83       	st	Z, r24
    1a60:	91 83       	std	Z+1, r25	; 0x01
    1a62:	a2 83       	std	Z+2, r26	; 0x02
    1a64:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1a66:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1a6a:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1a6e:	85 a1       	ldd	r24, Z+37	; 0x25
    1a70:	82 30       	cpi	r24, 0x02	; 2
    1a72:	c1 f4       	brne	.+48     	; 0x1aa4 <xTaskNotifyWait+0xe4>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1a74:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1a78:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1a7c:	41 a1       	ldd	r20, Z+33	; 0x21
    1a7e:	52 a1       	ldd	r21, Z+34	; 0x22
    1a80:	63 a1       	ldd	r22, Z+35	; 0x23
    1a82:	74 a1       	ldd	r23, Z+36	; 0x24
    1a84:	d5 01       	movw	r26, r10
    1a86:	c4 01       	movw	r24, r8
    1a88:	80 95       	com	r24
    1a8a:	90 95       	com	r25
    1a8c:	a0 95       	com	r26
    1a8e:	b0 95       	com	r27
    1a90:	84 23       	and	r24, r20
    1a92:	95 23       	and	r25, r21
    1a94:	a6 23       	and	r26, r22
    1a96:	b7 23       	and	r27, r23
    1a98:	81 a3       	std	Z+33, r24	; 0x21
    1a9a:	92 a3       	std	Z+34, r25	; 0x22
    1a9c:	a3 a3       	std	Z+35, r26	; 0x23
    1a9e:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    1aa0:	81 e0       	ldi	r24, 0x01	; 1
    1aa2:	01 c0       	rjmp	.+2      	; 0x1aa6 <xTaskNotifyWait+0xe6>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    1aa4:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1aa6:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1aaa:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1aae:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1ab0:	0f 90       	pop	r0
    1ab2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1ab4:	1f 91       	pop	r17
    1ab6:	0f 91       	pop	r16
    1ab8:	ff 90       	pop	r15
    1aba:	ef 90       	pop	r14
    1abc:	bf 90       	pop	r11
    1abe:	af 90       	pop	r10
    1ac0:	9f 90       	pop	r9
    1ac2:	8f 90       	pop	r8
    1ac4:	7f 90       	pop	r7
    1ac6:	6f 90       	pop	r6
    1ac8:	5f 90       	pop	r5
    1aca:	4f 90       	pop	r4
    1acc:	08 95       	ret

00001ace <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1ace:	0f 93       	push	r16
    1ad0:	1f 93       	push	r17
    1ad2:	cf 93       	push	r28
    1ad4:	df 93       	push	r29
    1ad6:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1ade:	01 15       	cp	r16, r1
    1ae0:	11 05       	cpc	r17, r1
    1ae2:	49 f0       	breq	.+18     	; 0x1af6 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1ae4:	81 a1       	ldd	r24, Z+33	; 0x21
    1ae6:	92 a1       	ldd	r25, Z+34	; 0x22
    1ae8:	a3 a1       	ldd	r26, Z+35	; 0x23
    1aea:	b4 a1       	ldd	r27, Z+36	; 0x24
    1aec:	e8 01       	movw	r28, r16
    1aee:	88 83       	st	Y, r24
    1af0:	99 83       	std	Y+1, r25	; 0x01
    1af2:	aa 83       	std	Y+2, r26	; 0x02
    1af4:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1af6:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1af8:	82 e0       	ldi	r24, 0x02	; 2
    1afa:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1afc:	22 30       	cpi	r18, 0x02	; 2
    1afe:	89 f0       	breq	.+34     	; 0x1b22 <xTaskGenericNotify+0x54>
    1b00:	58 f4       	brcc	.+22     	; 0x1b18 <xTaskGenericNotify+0x4a>
    1b02:	21 30       	cpi	r18, 0x01	; 1
    1b04:	01 f5       	brne	.+64     	; 0x1b46 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1b06:	81 a1       	ldd	r24, Z+33	; 0x21
    1b08:	92 a1       	ldd	r25, Z+34	; 0x22
    1b0a:	a3 a1       	ldd	r26, Z+35	; 0x23
    1b0c:	b4 a1       	ldd	r27, Z+36	; 0x24
    1b0e:	48 2b       	or	r20, r24
    1b10:	59 2b       	or	r21, r25
    1b12:	6a 2b       	or	r22, r26
    1b14:	7b 2b       	or	r23, r27
    1b16:	13 c0       	rjmp	.+38     	; 0x1b3e <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1b18:	23 30       	cpi	r18, 0x03	; 3
    1b1a:	89 f0       	breq	.+34     	; 0x1b3e <xTaskGenericNotify+0x70>
    1b1c:	24 30       	cpi	r18, 0x04	; 4
    1b1e:	69 f0       	breq	.+26     	; 0x1b3a <xTaskGenericNotify+0x6c>
    1b20:	12 c0       	rjmp	.+36     	; 0x1b46 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1b22:	81 a1       	ldd	r24, Z+33	; 0x21
    1b24:	92 a1       	ldd	r25, Z+34	; 0x22
    1b26:	a3 a1       	ldd	r26, Z+35	; 0x23
    1b28:	b4 a1       	ldd	r27, Z+36	; 0x24
    1b2a:	01 96       	adiw	r24, 0x01	; 1
    1b2c:	a1 1d       	adc	r26, r1
    1b2e:	b1 1d       	adc	r27, r1
    1b30:	81 a3       	std	Z+33, r24	; 0x21
    1b32:	92 a3       	std	Z+34, r25	; 0x22
    1b34:	a3 a3       	std	Z+35, r26	; 0x23
    1b36:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1b38:	06 c0       	rjmp	.+12     	; 0x1b46 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1b3a:	32 30       	cpi	r19, 0x02	; 2
    1b3c:	49 f1       	breq	.+82     	; 0x1b90 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1b3e:	41 a3       	std	Z+33, r20	; 0x21
    1b40:	52 a3       	std	Z+34, r21	; 0x22
    1b42:	63 a3       	std	Z+35, r22	; 0x23
    1b44:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1b46:	31 30       	cpi	r19, 0x01	; 1
    1b48:	09 f5       	brne	.+66     	; 0x1b8c <xTaskGenericNotify+0xbe>
    1b4a:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1b4c:	8f 01       	movw	r16, r30
    1b4e:	0e 5f       	subi	r16, 0xFE	; 254
    1b50:	1f 4f       	sbci	r17, 0xFF	; 255
    1b52:	c8 01       	movw	r24, r16
    1b54:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1b58:	8e 89       	ldd	r24, Y+22	; 0x16
    1b5a:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    1b5e:	98 17       	cp	r25, r24
    1b60:	10 f4       	brcc	.+4      	; 0x1b66 <xTaskGenericNotify+0x98>
    1b62:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    1b66:	29 e0       	ldi	r18, 0x09	; 9
    1b68:	82 9f       	mul	r24, r18
    1b6a:	c0 01       	movw	r24, r0
    1b6c:	11 24       	eor	r1, r1
    1b6e:	b8 01       	movw	r22, r16
    1b70:	81 58       	subi	r24, 0x81	; 129
    1b72:	9d 4f       	sbci	r25, 0xFD	; 253
    1b74:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1b78:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1b7c:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1b80:	9e 89       	ldd	r25, Y+22	; 0x16
    1b82:	86 89       	ldd	r24, Z+22	; 0x16
    1b84:	89 17       	cp	r24, r25
    1b86:	10 f4       	brcc	.+4      	; 0x1b8c <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    1b88:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	01 c0       	rjmp	.+2      	; 0x1b92 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1b90:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1b92:	0f 90       	pop	r0
    1b94:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	1f 91       	pop	r17
    1b9c:	0f 91       	pop	r16
    1b9e:	08 95       	ret

00001ba0 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1ba0:	ef 92       	push	r14
    1ba2:	ff 92       	push	r15
    1ba4:	0f 93       	push	r16
    1ba6:	1f 93       	push	r17
    1ba8:	cf 93       	push	r28
    1baa:	df 93       	push	r29
    1bac:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1bae:	01 15       	cp	r16, r1
    1bb0:	11 05       	cpc	r17, r1
    1bb2:	49 f0       	breq	.+18     	; 0x1bc6 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1bb4:	81 a1       	ldd	r24, Z+33	; 0x21
    1bb6:	92 a1       	ldd	r25, Z+34	; 0x22
    1bb8:	a3 a1       	ldd	r26, Z+35	; 0x23
    1bba:	b4 a1       	ldd	r27, Z+36	; 0x24
    1bbc:	e8 01       	movw	r28, r16
    1bbe:	88 83       	st	Y, r24
    1bc0:	99 83       	std	Y+1, r25	; 0x01
    1bc2:	aa 83       	std	Y+2, r26	; 0x02
    1bc4:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1bc6:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1bc8:	82 e0       	ldi	r24, 0x02	; 2
    1bca:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1bcc:	22 30       	cpi	r18, 0x02	; 2
    1bce:	89 f0       	breq	.+34     	; 0x1bf2 <xTaskGenericNotifyFromISR+0x52>
    1bd0:	58 f4       	brcc	.+22     	; 0x1be8 <xTaskGenericNotifyFromISR+0x48>
    1bd2:	21 30       	cpi	r18, 0x01	; 1
    1bd4:	01 f5       	brne	.+64     	; 0x1c16 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1bd6:	81 a1       	ldd	r24, Z+33	; 0x21
    1bd8:	92 a1       	ldd	r25, Z+34	; 0x22
    1bda:	a3 a1       	ldd	r26, Z+35	; 0x23
    1bdc:	b4 a1       	ldd	r27, Z+36	; 0x24
    1bde:	48 2b       	or	r20, r24
    1be0:	59 2b       	or	r21, r25
    1be2:	6a 2b       	or	r22, r26
    1be4:	7b 2b       	or	r23, r27
    1be6:	13 c0       	rjmp	.+38     	; 0x1c0e <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1be8:	23 30       	cpi	r18, 0x03	; 3
    1bea:	89 f0       	breq	.+34     	; 0x1c0e <xTaskGenericNotifyFromISR+0x6e>
    1bec:	24 30       	cpi	r18, 0x04	; 4
    1bee:	69 f0       	breq	.+26     	; 0x1c0a <xTaskGenericNotifyFromISR+0x6a>
    1bf0:	12 c0       	rjmp	.+36     	; 0x1c16 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1bf2:	81 a1       	ldd	r24, Z+33	; 0x21
    1bf4:	92 a1       	ldd	r25, Z+34	; 0x22
    1bf6:	a3 a1       	ldd	r26, Z+35	; 0x23
    1bf8:	b4 a1       	ldd	r27, Z+36	; 0x24
    1bfa:	01 96       	adiw	r24, 0x01	; 1
    1bfc:	a1 1d       	adc	r26, r1
    1bfe:	b1 1d       	adc	r27, r1
    1c00:	81 a3       	std	Z+33, r24	; 0x21
    1c02:	92 a3       	std	Z+34, r25	; 0x22
    1c04:	a3 a3       	std	Z+35, r26	; 0x23
    1c06:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1c08:	06 c0       	rjmp	.+12     	; 0x1c16 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1c0a:	32 30       	cpi	r19, 0x02	; 2
    1c0c:	d9 f1       	breq	.+118    	; 0x1c84 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1c0e:	41 a3       	std	Z+33, r20	; 0x21
    1c10:	52 a3       	std	Z+34, r21	; 0x22
    1c12:	63 a3       	std	Z+35, r22	; 0x23
    1c14:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1c16:	31 30       	cpi	r19, 0x01	; 1
    1c18:	11 f0       	breq	.+4      	; 0x1c1e <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	34 c0       	rjmp	.+104    	; 0x1c86 <xTaskGenericNotifyFromISR+0xe6>
    1c1e:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1c20:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    1c24:	81 11       	cpse	r24, r1
    1c26:	15 c0       	rjmp	.+42     	; 0x1c52 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1c28:	8f 01       	movw	r16, r30
    1c2a:	0e 5f       	subi	r16, 0xFE	; 254
    1c2c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c2e:	c8 01       	movw	r24, r16
    1c30:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1c34:	8e 89       	ldd	r24, Y+22	; 0x16
    1c36:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    1c3a:	98 17       	cp	r25, r24
    1c3c:	10 f4       	brcc	.+4      	; 0x1c42 <xTaskGenericNotifyFromISR+0xa2>
    1c3e:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    1c42:	e9 e0       	ldi	r30, 0x09	; 9
    1c44:	8e 9f       	mul	r24, r30
    1c46:	c0 01       	movw	r24, r0
    1c48:	11 24       	eor	r1, r1
    1c4a:	b8 01       	movw	r22, r16
    1c4c:	81 58       	subi	r24, 0x81	; 129
    1c4e:	9d 4f       	sbci	r25, 0xFD	; 253
    1c50:	05 c0       	rjmp	.+10     	; 0x1c5c <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1c52:	bf 01       	movw	r22, r30
    1c54:	64 5f       	subi	r22, 0xF4	; 244
    1c56:	7f 4f       	sbci	r23, 0xFF	; 255
    1c58:	80 e6       	ldi	r24, 0x60	; 96
    1c5a:	92 e0       	ldi	r25, 0x02	; 2
    1c5c:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1c60:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1c64:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1c68:	9e 89       	ldd	r25, Y+22	; 0x16
    1c6a:	86 89       	ldd	r24, Z+22	; 0x16
    1c6c:	89 17       	cp	r24, r25
    1c6e:	a8 f6       	brcc	.-86     	; 0x1c1a <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1c70:	e1 14       	cp	r14, r1
    1c72:	f1 04       	cpc	r15, r1
    1c74:	19 f0       	breq	.+6      	; 0x1c7c <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1c76:	81 e0       	ldi	r24, 0x01	; 1
    1c78:	e7 01       	movw	r28, r14
    1c7a:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	80 93 4f 02 	sts	0x024F, r24	; 0x80024f <xYieldPending>
    1c82:	01 c0       	rjmp	.+2      	; 0x1c86 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1c84:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    1c86:	df 91       	pop	r29
    1c88:	cf 91       	pop	r28
    1c8a:	1f 91       	pop	r17
    1c8c:	0f 91       	pop	r16
    1c8e:	ff 90       	pop	r15
    1c90:	ef 90       	pop	r14
    1c92:	08 95       	ret

00001c94 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1c94:	ef 92       	push	r14
    1c96:	ff 92       	push	r15
    1c98:	0f 93       	push	r16
    1c9a:	1f 93       	push	r17
    1c9c:	cf 93       	push	r28
    1c9e:	df 93       	push	r29
    1ca0:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1ca2:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1ca4:	82 e0       	ldi	r24, 0x02	; 2
    1ca6:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1ca8:	81 a1       	ldd	r24, Z+33	; 0x21
    1caa:	92 a1       	ldd	r25, Z+34	; 0x22
    1cac:	a3 a1       	ldd	r26, Z+35	; 0x23
    1cae:	b4 a1       	ldd	r27, Z+36	; 0x24
    1cb0:	01 96       	adiw	r24, 0x01	; 1
    1cb2:	a1 1d       	adc	r26, r1
    1cb4:	b1 1d       	adc	r27, r1
    1cb6:	81 a3       	std	Z+33, r24	; 0x21
    1cb8:	92 a3       	std	Z+34, r25	; 0x22
    1cba:	a3 a3       	std	Z+35, r26	; 0x23
    1cbc:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1cbe:	21 30       	cpi	r18, 0x01	; 1
    1cc0:	a1 f5       	brne	.+104    	; 0x1d2a <vTaskNotifyGiveFromISR+0x96>
    1cc2:	8b 01       	movw	r16, r22
    1cc4:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1cc6:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <uxSchedulerSuspended>
    1cca:	81 11       	cpse	r24, r1
    1ccc:	16 c0       	rjmp	.+44     	; 0x1cfa <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1cce:	7f 01       	movw	r14, r30
    1cd0:	22 e0       	ldi	r18, 0x02	; 2
    1cd2:	e2 0e       	add	r14, r18
    1cd4:	f1 1c       	adc	r15, r1
    1cd6:	c7 01       	movw	r24, r14
    1cd8:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1cdc:	8e 89       	ldd	r24, Y+22	; 0x16
    1cde:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <uxTopReadyPriority>
    1ce2:	98 17       	cp	r25, r24
    1ce4:	10 f4       	brcc	.+4      	; 0x1cea <vTaskNotifyGiveFromISR+0x56>
    1ce6:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <uxTopReadyPriority>
    1cea:	e9 e0       	ldi	r30, 0x09	; 9
    1cec:	8e 9f       	mul	r24, r30
    1cee:	c0 01       	movw	r24, r0
    1cf0:	11 24       	eor	r1, r1
    1cf2:	b7 01       	movw	r22, r14
    1cf4:	81 58       	subi	r24, 0x81	; 129
    1cf6:	9d 4f       	sbci	r25, 0xFD	; 253
    1cf8:	05 c0       	rjmp	.+10     	; 0x1d04 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1cfa:	bf 01       	movw	r22, r30
    1cfc:	64 5f       	subi	r22, 0xF4	; 244
    1cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1d00:	80 e6       	ldi	r24, 0x60	; 96
    1d02:	92 e0       	ldi	r25, 0x02	; 2
    1d04:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1d08:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <pxCurrentTCB>
    1d0c:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    1d10:	9e 89       	ldd	r25, Y+22	; 0x16
    1d12:	86 89       	ldd	r24, Z+22	; 0x16
    1d14:	89 17       	cp	r24, r25
    1d16:	48 f4       	brcc	.+18     	; 0x1d2a <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1d18:	01 15       	cp	r16, r1
    1d1a:	11 05       	cpc	r17, r1
    1d1c:	19 f0       	breq	.+6      	; 0x1d24 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1d1e:	81 e0       	ldi	r24, 0x01	; 1
    1d20:	f8 01       	movw	r30, r16
    1d22:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1d24:	81 e0       	ldi	r24, 0x01	; 1
    1d26:	80 93 4f 02 	sts	0x024F, r24	; 0x80024f <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1d2a:	df 91       	pop	r29
    1d2c:	cf 91       	pop	r28
    1d2e:	1f 91       	pop	r17
    1d30:	0f 91       	pop	r16
    1d32:	ff 90       	pop	r15
    1d34:	ef 90       	pop	r14
    1d36:	08 95       	ret

00001d38 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1d38:	00 97       	sbiw	r24, 0x00	; 0
    1d3a:	21 f4       	brne	.+8      	; 0x1d44 <xTaskNotifyStateClear+0xc>
    1d3c:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <pxCurrentTCB>
    1d40:	90 91 47 02 	lds	r25, 0x0247	; 0x800247 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1d4a:	fc 01       	movw	r30, r24
    1d4c:	25 a1       	ldd	r18, Z+37	; 0x25
    1d4e:	22 30       	cpi	r18, 0x02	; 2
    1d50:	19 f4       	brne	.+6      	; 0x1d58 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1d52:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	01 c0       	rjmp	.+2      	; 0x1d5a <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1d58:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1d5a:	0f 90       	pop	r0
    1d5c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1d5e:	08 95       	ret

00001d60 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1d60:	0f b6       	in	r0, 0x3f	; 63
    1d62:	f8 94       	cli
    1d64:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1d66:	fc 01       	movw	r30, r24
    1d68:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1d6a:	0f 90       	pop	r0
    1d6c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	91 11       	cpse	r25, r1
    1d72:	80 e0       	ldi	r24, 0x00	; 0
}
    1d74:	08 95       	ret

00001d76 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1d76:	0f 93       	push	r16
    1d78:	1f 93       	push	r17
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	ec 01       	movw	r28, r24
    1d80:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1d82:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1d84:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d86:	44 23       	and	r20, r20
    1d88:	b1 f1       	breq	.+108    	; 0x1df6 <prvCopyDataToQueue+0x80>
    1d8a:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1d8c:	01 11       	cpse	r16, r1
    1d8e:	15 c0       	rjmp	.+42     	; 0x1dba <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1d90:	8a 81       	ldd	r24, Y+2	; 0x02
    1d92:	9b 81       	ldd	r25, Y+3	; 0x03
    1d94:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1d98:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d9e:	82 0f       	add	r24, r18
    1da0:	91 1d       	adc	r25, r1
    1da2:	9b 83       	std	Y+3, r25	; 0x03
    1da4:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1da6:	2c 81       	ldd	r18, Y+4	; 0x04
    1da8:	3d 81       	ldd	r19, Y+5	; 0x05
    1daa:	82 17       	cp	r24, r18
    1dac:	93 07       	cpc	r25, r19
    1dae:	18 f1       	brcs	.+70     	; 0x1df6 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1db0:	88 81       	ld	r24, Y
    1db2:	99 81       	ldd	r25, Y+1	; 0x01
    1db4:	9b 83       	std	Y+3, r25	; 0x03
    1db6:	8a 83       	std	Y+2, r24	; 0x02
    1db8:	1e c0       	rjmp	.+60     	; 0x1df6 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1dba:	8e 81       	ldd	r24, Y+6	; 0x06
    1dbc:	9f 81       	ldd	r25, Y+7	; 0x07
    1dbe:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1dc2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	91 95       	neg	r25
    1dc8:	81 95       	neg	r24
    1dca:	91 09       	sbc	r25, r1
    1dcc:	2e 81       	ldd	r18, Y+6	; 0x06
    1dce:	3f 81       	ldd	r19, Y+7	; 0x07
    1dd0:	28 0f       	add	r18, r24
    1dd2:	39 1f       	adc	r19, r25
    1dd4:	3f 83       	std	Y+7, r19	; 0x07
    1dd6:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1dd8:	48 81       	ld	r20, Y
    1dda:	59 81       	ldd	r21, Y+1	; 0x01
    1ddc:	24 17       	cp	r18, r20
    1dde:	35 07       	cpc	r19, r21
    1de0:	30 f4       	brcc	.+12     	; 0x1dee <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1de2:	2c 81       	ldd	r18, Y+4	; 0x04
    1de4:	3d 81       	ldd	r19, Y+5	; 0x05
    1de6:	82 0f       	add	r24, r18
    1de8:	93 1f       	adc	r25, r19
    1dea:	9f 83       	std	Y+7, r25	; 0x07
    1dec:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1dee:	02 30       	cpi	r16, 0x02	; 2
    1df0:	11 f4       	brne	.+4      	; 0x1df6 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1df2:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1df4:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1df6:	1f 5f       	subi	r17, 0xFF	; 255
    1df8:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1dfa:	80 e0       	ldi	r24, 0x00	; 0
    1dfc:	df 91       	pop	r29
    1dfe:	cf 91       	pop	r28
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	08 95       	ret

00001e06 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1e06:	fc 01       	movw	r30, r24
    1e08:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1e0a:	44 8d       	ldd	r20, Z+28	; 0x1c
    1e0c:	44 23       	and	r20, r20
    1e0e:	a1 f0       	breq	.+40     	; 0x1e38 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1e10:	50 e0       	ldi	r21, 0x00	; 0
    1e12:	26 81       	ldd	r18, Z+6	; 0x06
    1e14:	37 81       	ldd	r19, Z+7	; 0x07
    1e16:	24 0f       	add	r18, r20
    1e18:	35 1f       	adc	r19, r21
    1e1a:	37 83       	std	Z+7, r19	; 0x07
    1e1c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1e1e:	64 81       	ldd	r22, Z+4	; 0x04
    1e20:	75 81       	ldd	r23, Z+5	; 0x05
    1e22:	26 17       	cp	r18, r22
    1e24:	37 07       	cpc	r19, r23
    1e26:	20 f0       	brcs	.+8      	; 0x1e30 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1e28:	20 81       	ld	r18, Z
    1e2a:	31 81       	ldd	r19, Z+1	; 0x01
    1e2c:	37 83       	std	Z+7, r19	; 0x07
    1e2e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1e30:	66 81       	ldd	r22, Z+6	; 0x06
    1e32:	77 81       	ldd	r23, Z+7	; 0x07
    1e34:	0c 94 01 2d 	jmp	0x5a02	; 0x5a02 <memcpy>
    1e38:	08 95       	ret

00001e3a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1e3a:	ef 92       	push	r14
    1e3c:	ff 92       	push	r15
    1e3e:	1f 93       	push	r17
    1e40:	cf 93       	push	r28
    1e42:	df 93       	push	r29
    1e44:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1e4c:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e4e:	7c 01       	movw	r14, r24
    1e50:	81 e1       	ldi	r24, 0x11	; 17
    1e52:	e8 0e       	add	r14, r24
    1e54:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1e56:	11 16       	cp	r1, r17
    1e58:	5c f4       	brge	.+22     	; 0x1e70 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e5a:	89 89       	ldd	r24, Y+17	; 0x11
    1e5c:	88 23       	and	r24, r24
    1e5e:	41 f0       	breq	.+16     	; 0x1e70 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e60:	c7 01       	movw	r24, r14
    1e62:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    1e66:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1e68:	0e 94 75 0c 	call	0x18ea	; 0x18ea <vTaskMissedYield>
    1e6c:	11 50       	subi	r17, 0x01	; 1
    1e6e:	f3 cf       	rjmp	.-26     	; 0x1e56 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1e70:	8f ef       	ldi	r24, 0xFF	; 255
    1e72:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1e78:	0f b6       	in	r0, 0x3f	; 63
    1e7a:	f8 94       	cli
    1e7c:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1e7e:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e80:	7e 01       	movw	r14, r28
    1e82:	88 e0       	ldi	r24, 0x08	; 8
    1e84:	e8 0e       	add	r14, r24
    1e86:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1e88:	11 16       	cp	r1, r17
    1e8a:	5c f4       	brge	.+22     	; 0x1ea2 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e8c:	88 85       	ldd	r24, Y+8	; 0x08
    1e8e:	88 23       	and	r24, r24
    1e90:	41 f0       	breq	.+16     	; 0x1ea2 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e92:	c7 01       	movw	r24, r14
    1e94:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    1e98:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1e9a:	0e 94 75 0c 	call	0x18ea	; 0x18ea <vTaskMissedYield>
    1e9e:	11 50       	subi	r17, 0x01	; 1
    1ea0:	f3 cf       	rjmp	.-26     	; 0x1e88 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1ea2:	8f ef       	ldi	r24, 0xFF	; 255
    1ea4:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1ea6:	0f 90       	pop	r0
    1ea8:	0f be       	out	0x3f, r0	; 63
}
    1eaa:	df 91       	pop	r29
    1eac:	cf 91       	pop	r28
    1eae:	1f 91       	pop	r17
    1eb0:	ff 90       	pop	r15
    1eb2:	ef 90       	pop	r14
    1eb4:	08 95       	ret

00001eb6 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1eb6:	cf 93       	push	r28
    1eb8:	df 93       	push	r29
    1eba:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1ebc:	0f b6       	in	r0, 0x3f	; 63
    1ebe:	f8 94       	cli
    1ec0:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1ec2:	48 81       	ld	r20, Y
    1ec4:	59 81       	ldd	r21, Y+1	; 0x01
    1ec6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ec8:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1eca:	9a 01       	movw	r18, r20
    1ecc:	87 9f       	mul	r24, r23
    1ece:	20 0d       	add	r18, r0
    1ed0:	31 1d       	adc	r19, r1
    1ed2:	11 24       	eor	r1, r1
    1ed4:	3d 83       	std	Y+5, r19	; 0x05
    1ed6:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1ed8:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1eda:	5b 83       	std	Y+3, r21	; 0x03
    1edc:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1ede:	90 e0       	ldi	r25, 0x00	; 0
    1ee0:	01 97       	sbiw	r24, 0x01	; 1
    1ee2:	78 9f       	mul	r23, r24
    1ee4:	90 01       	movw	r18, r0
    1ee6:	79 9f       	mul	r23, r25
    1ee8:	30 0d       	add	r19, r0
    1eea:	11 24       	eor	r1, r1
    1eec:	ca 01       	movw	r24, r20
    1eee:	82 0f       	add	r24, r18
    1ef0:	93 1f       	adc	r25, r19
    1ef2:	9f 83       	std	Y+7, r25	; 0x07
    1ef4:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1ef6:	8f ef       	ldi	r24, 0xFF	; 255
    1ef8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1efa:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1efc:	61 11       	cpse	r22, r1
    1efe:	0c c0       	rjmp	.+24     	; 0x1f18 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f00:	88 85       	ldd	r24, Y+8	; 0x08
    1f02:	88 23       	and	r24, r24
    1f04:	89 f0       	breq	.+34     	; 0x1f28 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f06:	ce 01       	movw	r24, r28
    1f08:	08 96       	adiw	r24, 0x08	; 8
    1f0a:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    1f0e:	88 23       	and	r24, r24
    1f10:	59 f0       	breq	.+22     	; 0x1f28 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1f12:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
    1f16:	08 c0       	rjmp	.+16     	; 0x1f28 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1f18:	ce 01       	movw	r24, r28
    1f1a:	08 96       	adiw	r24, 0x08	; 8
    1f1c:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1f20:	ce 01       	movw	r24, r28
    1f22:	41 96       	adiw	r24, 0x11	; 17
    1f24:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1f2c:	81 e0       	ldi	r24, 0x01	; 1
    1f2e:	df 91       	pop	r29
    1f30:	cf 91       	pop	r28
    1f32:	08 95       	ret

00001f34 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1f34:	0f 93       	push	r16
    1f36:	1f 93       	push	r17
    1f38:	cf 93       	push	r28
    1f3a:	df 93       	push	r29
    1f3c:	08 2f       	mov	r16, r24
    1f3e:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1f40:	66 23       	and	r22, r22
    1f42:	21 f0       	breq	.+8      	; 0x1f4c <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f44:	86 9f       	mul	r24, r22
    1f46:	c0 01       	movw	r24, r0
    1f48:	11 24       	eor	r1, r1
    1f4a:	02 c0       	rjmp	.+4      	; 0x1f50 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1f4c:	80 e0       	ldi	r24, 0x00	; 0
    1f4e:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1f50:	4f 96       	adiw	r24, 0x1f	; 31
    1f52:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <pvPortMalloc>
    1f56:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1f58:	00 97       	sbiw	r24, 0x00	; 0
    1f5a:	71 f0       	breq	.+28     	; 0x1f78 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1f5c:	11 11       	cpse	r17, r1
    1f5e:	03 c0       	rjmp	.+6      	; 0x1f66 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1f60:	99 83       	std	Y+1, r25	; 0x01
    1f62:	88 83       	st	Y, r24
    1f64:	03 c0       	rjmp	.+6      	; 0x1f6c <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1f66:	4f 96       	adiw	r24, 0x1f	; 31
    1f68:	99 83       	std	Y+1, r25	; 0x01
    1f6a:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1f6c:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1f6e:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1f70:	61 e0       	ldi	r22, 0x01	; 1
    1f72:	ce 01       	movw	r24, r28
    1f74:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    1f78:	ce 01       	movw	r24, r28
    1f7a:	df 91       	pop	r29
    1f7c:	cf 91       	pop	r28
    1f7e:	1f 91       	pop	r17
    1f80:	0f 91       	pop	r16
    1f82:	08 95       	ret

00001f84 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1f84:	af 92       	push	r10
    1f86:	bf 92       	push	r11
    1f88:	cf 92       	push	r12
    1f8a:	df 92       	push	r13
    1f8c:	ff 92       	push	r15
    1f8e:	0f 93       	push	r16
    1f90:	1f 93       	push	r17
    1f92:	cf 93       	push	r28
    1f94:	df 93       	push	r29
    1f96:	00 d0       	rcall	.+0      	; 0x1f98 <xQueueGenericSend+0x14>
    1f98:	00 d0       	rcall	.+0      	; 0x1f9a <xQueueGenericSend+0x16>
    1f9a:	1f 92       	push	r1
    1f9c:	cd b7       	in	r28, 0x3d	; 61
    1f9e:	de b7       	in	r29, 0x3e	; 62
    1fa0:	8c 01       	movw	r16, r24
    1fa2:	6b 01       	movw	r12, r22
    1fa4:	5d 83       	std	Y+5, r21	; 0x05
    1fa6:	4c 83       	std	Y+4, r20	; 0x04
    1fa8:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1faa:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1fac:	58 01       	movw	r10, r16
    1fae:	98 e0       	ldi	r25, 0x08	; 8
    1fb0:	a9 0e       	add	r10, r25
    1fb2:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1fb4:	0f b6       	in	r0, 0x3f	; 63
    1fb6:	f8 94       	cli
    1fb8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1fba:	f8 01       	movw	r30, r16
    1fbc:	22 8d       	ldd	r18, Z+26	; 0x1a
    1fbe:	93 8d       	ldd	r25, Z+27	; 0x1b
    1fc0:	29 17       	cp	r18, r25
    1fc2:	18 f0       	brcs	.+6      	; 0x1fca <xQueueGenericSend+0x46>
    1fc4:	f2 e0       	ldi	r31, 0x02	; 2
    1fc6:	ff 12       	cpse	r15, r31
    1fc8:	14 c0       	rjmp	.+40     	; 0x1ff2 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1fca:	4f 2d       	mov	r20, r15
    1fcc:	b6 01       	movw	r22, r12
    1fce:	c8 01       	movw	r24, r16
    1fd0:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fd4:	f8 01       	movw	r30, r16
    1fd6:	91 89       	ldd	r25, Z+17	; 0x11
    1fd8:	99 23       	and	r25, r25
    1fda:	21 f0       	breq	.+8      	; 0x1fe4 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fdc:	c8 01       	movw	r24, r16
    1fde:	41 96       	adiw	r24, 0x11	; 17
    1fe0:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    1fe4:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1fe6:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1fea:	0f 90       	pop	r0
    1fec:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	50 c0       	rjmp	.+160    	; 0x2092 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1ff2:	2c 81       	ldd	r18, Y+4	; 0x04
    1ff4:	3d 81       	ldd	r19, Y+5	; 0x05
    1ff6:	23 2b       	or	r18, r19
    1ff8:	19 f4       	brne	.+6      	; 0x2000 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	48 c0       	rjmp	.+144    	; 0x2090 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    2000:	81 11       	cpse	r24, r1
    2002:	04 c0       	rjmp	.+8      	; 0x200c <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2004:	ce 01       	movw	r24, r28
    2006:	01 96       	adiw	r24, 0x01	; 1
    2008:	0e 94 40 0c 	call	0x1880	; 0x1880 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    200c:	0f 90       	pop	r0
    200e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2010:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2014:	0f b6       	in	r0, 0x3f	; 63
    2016:	f8 94       	cli
    2018:	0f 92       	push	r0
    201a:	f8 01       	movw	r30, r16
    201c:	85 8d       	ldd	r24, Z+29	; 0x1d
    201e:	8f 3f       	cpi	r24, 0xFF	; 255
    2020:	09 f4       	brne	.+2      	; 0x2024 <xQueueGenericSend+0xa0>
    2022:	15 8e       	std	Z+29, r1	; 0x1d
    2024:	f8 01       	movw	r30, r16
    2026:	86 8d       	ldd	r24, Z+30	; 0x1e
    2028:	8f 3f       	cpi	r24, 0xFF	; 255
    202a:	09 f4       	brne	.+2      	; 0x202e <xQueueGenericSend+0xaa>
    202c:	16 8e       	std	Z+30, r1	; 0x1e
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2032:	be 01       	movw	r22, r28
    2034:	6c 5f       	subi	r22, 0xFC	; 252
    2036:	7f 4f       	sbci	r23, 0xFF	; 255
    2038:	ce 01       	movw	r24, r28
    203a:	01 96       	adiw	r24, 0x01	; 1
    203c:	0e 94 4b 0c 	call	0x1896	; 0x1896 <xTaskCheckForTimeOut>
    2040:	81 11       	cpse	r24, r1
    2042:	21 c0       	rjmp	.+66     	; 0x2086 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2044:	0f b6       	in	r0, 0x3f	; 63
    2046:	f8 94       	cli
    2048:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    204a:	f8 01       	movw	r30, r16
    204c:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    204e:	0f 90       	pop	r0
    2050:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2052:	83 8d       	ldd	r24, Z+27	; 0x1b
    2054:	98 13       	cpse	r25, r24
    2056:	11 c0       	rjmp	.+34     	; 0x207a <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2058:	6c 81       	ldd	r22, Y+4	; 0x04
    205a:	7d 81       	ldd	r23, Y+5	; 0x05
    205c:	c5 01       	movw	r24, r10
    205e:	0e 94 97 0b 	call	0x172e	; 0x172e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2062:	c8 01       	movw	r24, r16
    2064:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2068:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    206c:	88 23       	and	r24, r24
    206e:	11 f0       	breq	.+4      	; 0x2074 <xQueueGenericSend+0xf0>
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	a0 cf       	rjmp	.-192    	; 0x1fb4 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    2074:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
    2078:	fb cf       	rjmp	.-10     	; 0x2070 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    207a:	c8 01       	movw	r24, r16
    207c:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2080:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    2084:	f5 cf       	rjmp	.-22     	; 0x2070 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2086:	c8 01       	movw	r24, r16
    2088:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    208c:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2090:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    2092:	0f 90       	pop	r0
    2094:	0f 90       	pop	r0
    2096:	0f 90       	pop	r0
    2098:	0f 90       	pop	r0
    209a:	0f 90       	pop	r0
    209c:	df 91       	pop	r29
    209e:	cf 91       	pop	r28
    20a0:	1f 91       	pop	r17
    20a2:	0f 91       	pop	r16
    20a4:	ff 90       	pop	r15
    20a6:	df 90       	pop	r13
    20a8:	cf 90       	pop	r12
    20aa:	bf 90       	pop	r11
    20ac:	af 90       	pop	r10
    20ae:	08 95       	ret

000020b0 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    20b0:	ef 92       	push	r14
    20b2:	ff 92       	push	r15
    20b4:	1f 93       	push	r17
    20b6:	cf 93       	push	r28
    20b8:	df 93       	push	r29
    20ba:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    20bc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    20be:	8b 8d       	ldd	r24, Y+27	; 0x1b
    20c0:	98 17       	cp	r25, r24
    20c2:	10 f0       	brcs	.+4      	; 0x20c8 <xQueueGenericSendFromISR+0x18>
    20c4:	22 30       	cpi	r18, 0x02	; 2
    20c6:	e1 f4       	brne	.+56     	; 0x2100 <xQueueGenericSendFromISR+0x50>
    20c8:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    20ca:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20cc:	42 2f       	mov	r20, r18
    20ce:	ce 01       	movw	r24, r28
    20d0:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    20d4:	1f 3f       	cpi	r17, 0xFF	; 255
    20d6:	81 f4       	brne	.+32     	; 0x20f8 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20d8:	89 89       	ldd	r24, Y+17	; 0x11
    20da:	88 23       	and	r24, r24
    20dc:	79 f0       	breq	.+30     	; 0x20fc <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20de:	ce 01       	movw	r24, r28
    20e0:	41 96       	adiw	r24, 0x11	; 17
    20e2:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    20e6:	88 23       	and	r24, r24
    20e8:	49 f0       	breq	.+18     	; 0x20fc <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    20ea:	e1 14       	cp	r14, r1
    20ec:	f1 04       	cpc	r15, r1
    20ee:	31 f0       	breq	.+12     	; 0x20fc <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    20f0:	81 e0       	ldi	r24, 0x01	; 1
    20f2:	f7 01       	movw	r30, r14
    20f4:	80 83       	st	Z, r24
    20f6:	05 c0       	rjmp	.+10     	; 0x2102 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    20f8:	1f 5f       	subi	r17, 0xFF	; 255
    20fa:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    20fc:	81 e0       	ldi	r24, 0x01	; 1
    20fe:	01 c0       	rjmp	.+2      	; 0x2102 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2100:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2102:	df 91       	pop	r29
    2104:	cf 91       	pop	r28
    2106:	1f 91       	pop	r17
    2108:	ff 90       	pop	r15
    210a:	ef 90       	pop	r14
    210c:	08 95       	ret

0000210e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    210e:	cf 93       	push	r28
    2110:	df 93       	push	r29
    2112:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2114:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2116:	83 8d       	ldd	r24, Z+27	; 0x1b
    2118:	98 17       	cp	r25, r24
    211a:	c0 f4       	brcc	.+48     	; 0x214c <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    211c:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    211e:	9f 5f       	subi	r25, 0xFF	; 255
    2120:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2122:	8f 3f       	cpi	r24, 0xFF	; 255
    2124:	79 f4       	brne	.+30     	; 0x2144 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2126:	81 89       	ldd	r24, Z+17	; 0x11
    2128:	88 23       	and	r24, r24
    212a:	71 f0       	breq	.+28     	; 0x2148 <xQueueGiveFromISR+0x3a>
    212c:	eb 01       	movw	r28, r22
    212e:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2130:	41 96       	adiw	r24, 0x11	; 17
    2132:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    2136:	88 23       	and	r24, r24
    2138:	39 f0       	breq	.+14     	; 0x2148 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    213a:	20 97       	sbiw	r28, 0x00	; 0
    213c:	29 f0       	breq	.+10     	; 0x2148 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    213e:	81 e0       	ldi	r24, 0x01	; 1
    2140:	88 83       	st	Y, r24
    2142:	05 c0       	rjmp	.+10     	; 0x214e <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2144:	8f 5f       	subi	r24, 0xFF	; 255
    2146:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2148:	81 e0       	ldi	r24, 0x01	; 1
    214a:	01 c0       	rjmp	.+2      	; 0x214e <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    214c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    214e:	df 91       	pop	r29
    2150:	cf 91       	pop	r28
    2152:	08 95       	ret

00002154 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2154:	af 92       	push	r10
    2156:	bf 92       	push	r11
    2158:	cf 92       	push	r12
    215a:	df 92       	push	r13
    215c:	ff 92       	push	r15
    215e:	0f 93       	push	r16
    2160:	1f 93       	push	r17
    2162:	cf 93       	push	r28
    2164:	df 93       	push	r29
    2166:	00 d0       	rcall	.+0      	; 0x2168 <xQueueReceive+0x14>
    2168:	00 d0       	rcall	.+0      	; 0x216a <xQueueReceive+0x16>
    216a:	1f 92       	push	r1
    216c:	cd b7       	in	r28, 0x3d	; 61
    216e:	de b7       	in	r29, 0x3e	; 62
    2170:	8c 01       	movw	r16, r24
    2172:	6b 01       	movw	r12, r22
    2174:	5d 83       	std	Y+5, r21	; 0x05
    2176:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    2178:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    217a:	58 01       	movw	r10, r16
    217c:	91 e1       	ldi	r25, 0x11	; 17
    217e:	a9 0e       	add	r10, r25
    2180:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2182:	0f b6       	in	r0, 0x3f	; 63
    2184:	f8 94       	cli
    2186:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2188:	f8 01       	movw	r30, r16
    218a:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    218c:	ff 20       	and	r15, r15
    218e:	a9 f0       	breq	.+42     	; 0x21ba <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2190:	b6 01       	movw	r22, r12
    2192:	c8 01       	movw	r24, r16
    2194:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2198:	fa 94       	dec	r15
    219a:	f8 01       	movw	r30, r16
    219c:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    219e:	80 85       	ldd	r24, Z+8	; 0x08
    21a0:	88 23       	and	r24, r24
    21a2:	39 f0       	breq	.+14     	; 0x21b2 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    21a4:	c8 01       	movw	r24, r16
    21a6:	08 96       	adiw	r24, 0x08	; 8
    21a8:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    21ac:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    21ae:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    21b2:	0f 90       	pop	r0
    21b4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    21b6:	81 e0       	ldi	r24, 0x01	; 1
    21b8:	50 c0       	rjmp	.+160    	; 0x225a <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    21ba:	2c 81       	ldd	r18, Y+4	; 0x04
    21bc:	3d 81       	ldd	r19, Y+5	; 0x05
    21be:	23 2b       	or	r18, r19
    21c0:	19 f4       	brne	.+6      	; 0x21c8 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    21c2:	0f 90       	pop	r0
    21c4:	0f be       	out	0x3f, r0	; 63
    21c6:	48 c0       	rjmp	.+144    	; 0x2258 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    21c8:	81 11       	cpse	r24, r1
    21ca:	04 c0       	rjmp	.+8      	; 0x21d4 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    21cc:	ce 01       	movw	r24, r28
    21ce:	01 96       	adiw	r24, 0x01	; 1
    21d0:	0e 94 40 0c 	call	0x1880	; 0x1880 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    21d4:	0f 90       	pop	r0
    21d6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    21d8:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    21dc:	0f b6       	in	r0, 0x3f	; 63
    21de:	f8 94       	cli
    21e0:	0f 92       	push	r0
    21e2:	f8 01       	movw	r30, r16
    21e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    21e6:	8f 3f       	cpi	r24, 0xFF	; 255
    21e8:	09 f4       	brne	.+2      	; 0x21ec <xQueueReceive+0x98>
    21ea:	15 8e       	std	Z+29, r1	; 0x1d
    21ec:	f8 01       	movw	r30, r16
    21ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    21f0:	8f 3f       	cpi	r24, 0xFF	; 255
    21f2:	09 f4       	brne	.+2      	; 0x21f6 <xQueueReceive+0xa2>
    21f4:	16 8e       	std	Z+30, r1	; 0x1e
    21f6:	0f 90       	pop	r0
    21f8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    21fa:	be 01       	movw	r22, r28
    21fc:	6c 5f       	subi	r22, 0xFC	; 252
    21fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2200:	ce 01       	movw	r24, r28
    2202:	01 96       	adiw	r24, 0x01	; 1
    2204:	0e 94 4b 0c 	call	0x1896	; 0x1896 <xTaskCheckForTimeOut>
    2208:	81 11       	cpse	r24, r1
    220a:	1c c0       	rjmp	.+56     	; 0x2244 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    220c:	c8 01       	movw	r24, r16
    220e:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <prvIsQueueEmpty>
    2212:	88 23       	and	r24, r24
    2214:	89 f0       	breq	.+34     	; 0x2238 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2216:	6c 81       	ldd	r22, Y+4	; 0x04
    2218:	7d 81       	ldd	r23, Y+5	; 0x05
    221a:	c5 01       	movw	r24, r10
    221c:	0e 94 97 0b 	call	0x172e	; 0x172e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2220:	c8 01       	movw	r24, r16
    2222:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2226:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    222a:	88 23       	and	r24, r24
    222c:	11 f0       	breq	.+4      	; 0x2232 <xQueueReceive+0xde>
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	a8 cf       	rjmp	.-176    	; 0x2182 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    2232:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
    2236:	fb cf       	rjmp	.-10     	; 0x222e <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2238:	c8 01       	movw	r24, r16
    223a:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    223e:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    2242:	f5 cf       	rjmp	.-22     	; 0x222e <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    2244:	c8 01       	movw	r24, r16
    2246:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    224a:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    224e:	c8 01       	movw	r24, r16
    2250:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <prvIsQueueEmpty>
    2254:	88 23       	and	r24, r24
    2256:	59 f3       	breq	.-42     	; 0x222e <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2258:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    225a:	0f 90       	pop	r0
    225c:	0f 90       	pop	r0
    225e:	0f 90       	pop	r0
    2260:	0f 90       	pop	r0
    2262:	0f 90       	pop	r0
    2264:	df 91       	pop	r29
    2266:	cf 91       	pop	r28
    2268:	1f 91       	pop	r17
    226a:	0f 91       	pop	r16
    226c:	ff 90       	pop	r15
    226e:	df 90       	pop	r13
    2270:	cf 90       	pop	r12
    2272:	bf 90       	pop	r11
    2274:	af 90       	pop	r10
    2276:	08 95       	ret

00002278 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2278:	ef 92       	push	r14
    227a:	ff 92       	push	r15
    227c:	0f 93       	push	r16
    227e:	1f 93       	push	r17
    2280:	cf 93       	push	r28
    2282:	df 93       	push	r29
    2284:	00 d0       	rcall	.+0      	; 0x2286 <xQueueSemaphoreTake+0xe>
    2286:	00 d0       	rcall	.+0      	; 0x2288 <xQueueSemaphoreTake+0x10>
    2288:	1f 92       	push	r1
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
    228e:	8c 01       	movw	r16, r24
    2290:	7d 83       	std	Y+5, r23	; 0x05
    2292:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    2294:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2296:	78 01       	movw	r14, r16
    2298:	81 e1       	ldi	r24, 0x11	; 17
    229a:	e8 0e       	add	r14, r24
    229c:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    229e:	0f b6       	in	r0, 0x3f	; 63
    22a0:	f8 94       	cli
    22a2:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    22a4:	f8 01       	movw	r30, r16
    22a6:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    22a8:	88 23       	and	r24, r24
    22aa:	81 f0       	breq	.+32     	; 0x22cc <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    22ac:	81 50       	subi	r24, 0x01	; 1
    22ae:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22b0:	80 85       	ldd	r24, Z+8	; 0x08
    22b2:	88 23       	and	r24, r24
    22b4:	39 f0       	breq	.+14     	; 0x22c4 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22b6:	c8 01       	movw	r24, r16
    22b8:	08 96       	adiw	r24, 0x08	; 8
    22ba:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    22be:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    22c0:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    22c4:	0f 90       	pop	r0
    22c6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    22c8:	81 e0       	ldi	r24, 0x01	; 1
    22ca:	50 c0       	rjmp	.+160    	; 0x236c <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    22cc:	2c 81       	ldd	r18, Y+4	; 0x04
    22ce:	3d 81       	ldd	r19, Y+5	; 0x05
    22d0:	23 2b       	or	r18, r19
    22d2:	19 f4       	brne	.+6      	; 0x22da <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    22d4:	0f 90       	pop	r0
    22d6:	0f be       	out	0x3f, r0	; 63
    22d8:	48 c0       	rjmp	.+144    	; 0x236a <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    22da:	91 11       	cpse	r25, r1
    22dc:	04 c0       	rjmp	.+8      	; 0x22e6 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    22de:	ce 01       	movw	r24, r28
    22e0:	01 96       	adiw	r24, 0x01	; 1
    22e2:	0e 94 40 0c 	call	0x1880	; 0x1880 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    22e6:	0f 90       	pop	r0
    22e8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    22ea:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    22ee:	0f b6       	in	r0, 0x3f	; 63
    22f0:	f8 94       	cli
    22f2:	0f 92       	push	r0
    22f4:	f8 01       	movw	r30, r16
    22f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    22f8:	8f 3f       	cpi	r24, 0xFF	; 255
    22fa:	09 f4       	brne	.+2      	; 0x22fe <xQueueSemaphoreTake+0x86>
    22fc:	15 8e       	std	Z+29, r1	; 0x1d
    22fe:	f8 01       	movw	r30, r16
    2300:	86 8d       	ldd	r24, Z+30	; 0x1e
    2302:	8f 3f       	cpi	r24, 0xFF	; 255
    2304:	09 f4       	brne	.+2      	; 0x2308 <xQueueSemaphoreTake+0x90>
    2306:	16 8e       	std	Z+30, r1	; 0x1e
    2308:	0f 90       	pop	r0
    230a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    230c:	be 01       	movw	r22, r28
    230e:	6c 5f       	subi	r22, 0xFC	; 252
    2310:	7f 4f       	sbci	r23, 0xFF	; 255
    2312:	ce 01       	movw	r24, r28
    2314:	01 96       	adiw	r24, 0x01	; 1
    2316:	0e 94 4b 0c 	call	0x1896	; 0x1896 <xTaskCheckForTimeOut>
    231a:	81 11       	cpse	r24, r1
    231c:	1c c0       	rjmp	.+56     	; 0x2356 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    231e:	c8 01       	movw	r24, r16
    2320:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <prvIsQueueEmpty>
    2324:	88 23       	and	r24, r24
    2326:	89 f0       	breq	.+34     	; 0x234a <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2328:	6c 81       	ldd	r22, Y+4	; 0x04
    232a:	7d 81       	ldd	r23, Y+5	; 0x05
    232c:	c7 01       	movw	r24, r14
    232e:	0e 94 97 0b 	call	0x172e	; 0x172e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2332:	c8 01       	movw	r24, r16
    2334:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2338:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    233c:	88 23       	and	r24, r24
    233e:	11 f0       	breq	.+4      	; 0x2344 <xQueueSemaphoreTake+0xcc>
    2340:	91 e0       	ldi	r25, 0x01	; 1
    2342:	ad cf       	rjmp	.-166    	; 0x229e <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    2344:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
    2348:	fb cf       	rjmp	.-10     	; 0x2340 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    234a:	c8 01       	movw	r24, r16
    234c:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2350:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    2354:	f5 cf       	rjmp	.-22     	; 0x2340 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2356:	c8 01       	movw	r24, r16
    2358:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    235c:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2360:	c8 01       	movw	r24, r16
    2362:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <prvIsQueueEmpty>
    2366:	88 23       	and	r24, r24
    2368:	59 f3       	breq	.-42     	; 0x2340 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    236a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    236c:	0f 90       	pop	r0
    236e:	0f 90       	pop	r0
    2370:	0f 90       	pop	r0
    2372:	0f 90       	pop	r0
    2374:	0f 90       	pop	r0
    2376:	df 91       	pop	r29
    2378:	cf 91       	pop	r28
    237a:	1f 91       	pop	r17
    237c:	0f 91       	pop	r16
    237e:	ff 90       	pop	r15
    2380:	ef 90       	pop	r14
    2382:	08 95       	ret

00002384 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2384:	cf 92       	push	r12
    2386:	df 92       	push	r13
    2388:	ef 92       	push	r14
    238a:	ff 92       	push	r15
    238c:	0f 93       	push	r16
    238e:	1f 93       	push	r17
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	00 d0       	rcall	.+0      	; 0x2396 <xQueuePeek+0x12>
    2396:	00 d0       	rcall	.+0      	; 0x2398 <xQueuePeek+0x14>
    2398:	1f 92       	push	r1
    239a:	cd b7       	in	r28, 0x3d	; 61
    239c:	de b7       	in	r29, 0x3e	; 62
    239e:	8c 01       	movw	r16, r24
    23a0:	7b 01       	movw	r14, r22
    23a2:	5d 83       	std	Y+5, r21	; 0x05
    23a4:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    23a6:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23a8:	68 01       	movw	r12, r16
    23aa:	91 e1       	ldi	r25, 0x11	; 17
    23ac:	c9 0e       	add	r12, r25
    23ae:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    23b0:	0f b6       	in	r0, 0x3f	; 63
    23b2:	f8 94       	cli
    23b4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    23b6:	f8 01       	movw	r30, r16
    23b8:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    23ba:	99 23       	and	r25, r25
    23bc:	b9 f0       	breq	.+46     	; 0x23ec <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    23be:	c6 80       	ldd	r12, Z+6	; 0x06
    23c0:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    23c2:	b7 01       	movw	r22, r14
    23c4:	c8 01       	movw	r24, r16
    23c6:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    23ca:	f8 01       	movw	r30, r16
    23cc:	d7 82       	std	Z+7, r13	; 0x07
    23ce:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23d0:	81 89       	ldd	r24, Z+17	; 0x11
    23d2:	88 23       	and	r24, r24
    23d4:	39 f0       	breq	.+14     	; 0x23e4 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23d6:	c8 01       	movw	r24, r16
    23d8:	41 96       	adiw	r24, 0x11	; 17
    23da:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    23de:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    23e0:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    23e4:	0f 90       	pop	r0
    23e6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    23e8:	81 e0       	ldi	r24, 0x01	; 1
    23ea:	50 c0       	rjmp	.+160    	; 0x248c <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    23ec:	2c 81       	ldd	r18, Y+4	; 0x04
    23ee:	3d 81       	ldd	r19, Y+5	; 0x05
    23f0:	23 2b       	or	r18, r19
    23f2:	19 f4       	brne	.+6      	; 0x23fa <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23f4:	0f 90       	pop	r0
    23f6:	0f be       	out	0x3f, r0	; 63
    23f8:	48 c0       	rjmp	.+144    	; 0x248a <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    23fa:	81 11       	cpse	r24, r1
    23fc:	04 c0       	rjmp	.+8      	; 0x2406 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    23fe:	ce 01       	movw	r24, r28
    2400:	01 96       	adiw	r24, 0x01	; 1
    2402:	0e 94 40 0c 	call	0x1880	; 0x1880 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2406:	0f 90       	pop	r0
    2408:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    240a:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    240e:	0f b6       	in	r0, 0x3f	; 63
    2410:	f8 94       	cli
    2412:	0f 92       	push	r0
    2414:	f8 01       	movw	r30, r16
    2416:	85 8d       	ldd	r24, Z+29	; 0x1d
    2418:	8f 3f       	cpi	r24, 0xFF	; 255
    241a:	09 f4       	brne	.+2      	; 0x241e <xQueuePeek+0x9a>
    241c:	15 8e       	std	Z+29, r1	; 0x1d
    241e:	f8 01       	movw	r30, r16
    2420:	86 8d       	ldd	r24, Z+30	; 0x1e
    2422:	8f 3f       	cpi	r24, 0xFF	; 255
    2424:	09 f4       	brne	.+2      	; 0x2428 <xQueuePeek+0xa4>
    2426:	16 8e       	std	Z+30, r1	; 0x1e
    2428:	0f 90       	pop	r0
    242a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    242c:	be 01       	movw	r22, r28
    242e:	6c 5f       	subi	r22, 0xFC	; 252
    2430:	7f 4f       	sbci	r23, 0xFF	; 255
    2432:	ce 01       	movw	r24, r28
    2434:	01 96       	adiw	r24, 0x01	; 1
    2436:	0e 94 4b 0c 	call	0x1896	; 0x1896 <xTaskCheckForTimeOut>
    243a:	81 11       	cpse	r24, r1
    243c:	1c c0       	rjmp	.+56     	; 0x2476 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    243e:	c8 01       	movw	r24, r16
    2440:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <prvIsQueueEmpty>
    2444:	88 23       	and	r24, r24
    2446:	89 f0       	breq	.+34     	; 0x246a <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2448:	6c 81       	ldd	r22, Y+4	; 0x04
    244a:	7d 81       	ldd	r23, Y+5	; 0x05
    244c:	c6 01       	movw	r24, r12
    244e:	0e 94 97 0b 	call	0x172e	; 0x172e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2452:	c8 01       	movw	r24, r16
    2454:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2458:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    245c:	88 23       	and	r24, r24
    245e:	11 f0       	breq	.+4      	; 0x2464 <xQueuePeek+0xe0>
    2460:	81 e0       	ldi	r24, 0x01	; 1
    2462:	a6 cf       	rjmp	.-180    	; 0x23b0 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    2464:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortYield>
    2468:	fb cf       	rjmp	.-10     	; 0x2460 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    246a:	c8 01       	movw	r24, r16
    246c:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2470:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
    2474:	f5 cf       	rjmp	.-22     	; 0x2460 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2476:	c8 01       	movw	r24, r16
    2478:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    247c:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2480:	c8 01       	movw	r24, r16
    2482:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <prvIsQueueEmpty>
    2486:	88 23       	and	r24, r24
    2488:	59 f3       	breq	.-42     	; 0x2460 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    248a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    248c:	0f 90       	pop	r0
    248e:	0f 90       	pop	r0
    2490:	0f 90       	pop	r0
    2492:	0f 90       	pop	r0
    2494:	0f 90       	pop	r0
    2496:	df 91       	pop	r29
    2498:	cf 91       	pop	r28
    249a:	1f 91       	pop	r17
    249c:	0f 91       	pop	r16
    249e:	ff 90       	pop	r15
    24a0:	ef 90       	pop	r14
    24a2:	df 90       	pop	r13
    24a4:	cf 90       	pop	r12
    24a6:	08 95       	ret

000024a8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    24a8:	ef 92       	push	r14
    24aa:	ff 92       	push	r15
    24ac:	0f 93       	push	r16
    24ae:	1f 93       	push	r17
    24b0:	cf 93       	push	r28
    24b2:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    24b4:	fc 01       	movw	r30, r24
    24b6:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    24b8:	00 23       	and	r16, r16
    24ba:	e9 f0       	breq	.+58     	; 0x24f6 <xQueueReceiveFromISR+0x4e>
    24bc:	7a 01       	movw	r14, r20
    24be:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    24c0:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    24c2:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    24c6:	01 50       	subi	r16, 0x01	; 1
    24c8:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    24ca:	1f 3f       	cpi	r17, 0xFF	; 255
    24cc:	81 f4       	brne	.+32     	; 0x24ee <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24ce:	88 85       	ldd	r24, Y+8	; 0x08
    24d0:	88 23       	and	r24, r24
    24d2:	79 f0       	breq	.+30     	; 0x24f2 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24d4:	ce 01       	movw	r24, r28
    24d6:	08 96       	adiw	r24, 0x08	; 8
    24d8:	0e 94 be 0b 	call	0x177c	; 0x177c <xTaskRemoveFromEventList>
    24dc:	88 23       	and	r24, r24
    24de:	49 f0       	breq	.+18     	; 0x24f2 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    24e0:	e1 14       	cp	r14, r1
    24e2:	f1 04       	cpc	r15, r1
    24e4:	31 f0       	breq	.+12     	; 0x24f2 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	f7 01       	movw	r30, r14
    24ea:	80 83       	st	Z, r24
    24ec:	05 c0       	rjmp	.+10     	; 0x24f8 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    24ee:	1f 5f       	subi	r17, 0xFF	; 255
    24f0:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    24f2:	81 e0       	ldi	r24, 0x01	; 1
    24f4:	01 c0       	rjmp	.+2      	; 0x24f8 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    24f6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    24f8:	df 91       	pop	r29
    24fa:	cf 91       	pop	r28
    24fc:	1f 91       	pop	r17
    24fe:	0f 91       	pop	r16
    2500:	ff 90       	pop	r15
    2502:	ef 90       	pop	r14
    2504:	08 95       	ret

00002506 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2506:	0f 93       	push	r16
    2508:	1f 93       	push	r17
    250a:	cf 93       	push	r28
    250c:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    250e:	fc 01       	movw	r30, r24
    2510:	22 8d       	ldd	r18, Z+26	; 0x1a
    2512:	22 23       	and	r18, r18
    2514:	49 f0       	breq	.+18     	; 0x2528 <xQueuePeekFromISR+0x22>
    2516:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2518:	06 81       	ldd	r16, Z+6	; 0x06
    251a:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    251c:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2520:	1f 83       	std	Y+7, r17	; 0x07
    2522:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    2524:	81 e0       	ldi	r24, 0x01	; 1
    2526:	01 c0       	rjmp	.+2      	; 0x252a <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    2528:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    252a:	df 91       	pop	r29
    252c:	cf 91       	pop	r28
    252e:	1f 91       	pop	r17
    2530:	0f 91       	pop	r16
    2532:	08 95       	ret

00002534 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2534:	0f b6       	in	r0, 0x3f	; 63
    2536:	f8 94       	cli
    2538:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    253a:	fc 01       	movw	r30, r24
    253c:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    253e:	0f 90       	pop	r0
    2540:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2542:	08 95       	ret

00002544 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2544:	0f b6       	in	r0, 0x3f	; 63
    2546:	f8 94       	cli
    2548:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    254a:	fc 01       	movw	r30, r24
    254c:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    254e:	0f 90       	pop	r0
    2550:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2552:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2554:	82 1b       	sub	r24, r18
    2556:	08 95       	ret

00002558 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2558:	fc 01       	movw	r30, r24
    255a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    255c:	08 95       	ret

0000255e <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    255e:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <vPortFree>

00002562 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2562:	fc 01       	movw	r30, r24
    2564:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2566:	81 e0       	ldi	r24, 0x01	; 1
    2568:	91 11       	cpse	r25, r1
    256a:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    256c:	08 95       	ret

0000256e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    256e:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2570:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2572:	81 e0       	ldi	r24, 0x01	; 1
    2574:	23 8d       	ldd	r18, Z+27	; 0x1b
    2576:	29 13       	cpse	r18, r25
    2578:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    257a:	08 95       	ret

0000257c <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    257c:	cf 93       	push	r28
    257e:	df 93       	push	r29
    2580:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2582:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2584:	0f b6       	in	r0, 0x3f	; 63
    2586:	f8 94       	cli
    2588:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    258a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    258c:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    258e:	0f 90       	pop	r0
    2590:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2592:	89 13       	cpse	r24, r25
    2594:	0f c0       	rjmp	.+30     	; 0x25b4 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2596:	41 15       	cp	r20, r1
    2598:	51 05       	cpc	r21, r1
    259a:	49 f0       	breq	.+18     	; 0x25ae <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    259c:	be 01       	movw	r22, r28
    259e:	68 5f       	subi	r22, 0xF8	; 248
    25a0:	7f 4f       	sbci	r23, 0xFF	; 255
    25a2:	ca 01       	movw	r24, r20
    25a4:	0e 94 9d 14 	call	0x293a	; 0x293a <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    25a8:	78 94       	sei
					return errQUEUE_BLOCKED;
    25aa:	8c ef       	ldi	r24, 0xFC	; 252
    25ac:	1b c0       	rjmp	.+54     	; 0x25e4 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    25ae:	78 94       	sei
					return errQUEUE_FULL;
    25b0:	80 e0       	ldi	r24, 0x00	; 0
    25b2:	18 c0       	rjmp	.+48     	; 0x25e4 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    25b4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    25b6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    25b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25ba:	89 17       	cp	r24, r25
    25bc:	88 f4       	brcc	.+34     	; 0x25e0 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    25be:	40 e0       	ldi	r20, 0x00	; 0
    25c0:	ce 01       	movw	r24, r28
    25c2:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25c6:	89 89       	ldd	r24, Y+17	; 0x11
    25c8:	81 11       	cpse	r24, r1
    25ca:	02 c0       	rjmp	.+4      	; 0x25d0 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	09 c0       	rjmp	.+18     	; 0x25e2 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25d0:	ce 01       	movw	r24, r28
    25d2:	41 96       	adiw	r24, 0x11	; 17
    25d4:	0e 94 cc 15 	call	0x2b98	; 0x2b98 <xCoRoutineRemoveFromEventList>
    25d8:	88 23       	and	r24, r24
    25da:	c1 f3       	breq	.-16     	; 0x25cc <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    25dc:	8b ef       	ldi	r24, 0xFB	; 251
    25de:	01 c0       	rjmp	.+2      	; 0x25e2 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    25e0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    25e2:	78 94       	sei

		return xReturn;
	}
    25e4:	df 91       	pop	r29
    25e6:	cf 91       	pop	r28
    25e8:	08 95       	ret

000025ea <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    25ea:	cf 93       	push	r28
    25ec:	df 93       	push	r29
    25ee:	ec 01       	movw	r28, r24
    25f0:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    25f2:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    25f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25f6:	81 11       	cpse	r24, r1
    25f8:	0f c0       	rjmp	.+30     	; 0x2618 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    25fa:	41 15       	cp	r20, r1
    25fc:	51 05       	cpc	r21, r1
    25fe:	49 f0       	breq	.+18     	; 0x2612 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2600:	be 01       	movw	r22, r28
    2602:	6f 5e       	subi	r22, 0xEF	; 239
    2604:	7f 4f       	sbci	r23, 0xFF	; 255
    2606:	ca 01       	movw	r24, r20
    2608:	0e 94 9d 14 	call	0x293a	; 0x293a <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    260c:	78 94       	sei
					return errQUEUE_BLOCKED;
    260e:	8c ef       	ldi	r24, 0xFC	; 252
    2610:	30 c0       	rjmp	.+96     	; 0x2672 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    2612:	78 94       	sei
					return errQUEUE_FULL;
    2614:	80 e0       	ldi	r24, 0x00	; 0
    2616:	2d c0       	rjmp	.+90     	; 0x2672 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    2618:	78 94       	sei

		portDISABLE_INTERRUPTS();
    261a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    261c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    261e:	88 23       	and	r24, r24
    2620:	31 f1       	breq	.+76     	; 0x266e <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2622:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2624:	50 e0       	ldi	r21, 0x00	; 0
    2626:	2e 81       	ldd	r18, Y+6	; 0x06
    2628:	3f 81       	ldd	r19, Y+7	; 0x07
    262a:	24 0f       	add	r18, r20
    262c:	35 1f       	adc	r19, r21
    262e:	3f 83       	std	Y+7, r19	; 0x07
    2630:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2632:	8c 81       	ldd	r24, Y+4	; 0x04
    2634:	9d 81       	ldd	r25, Y+5	; 0x05
    2636:	28 17       	cp	r18, r24
    2638:	39 07       	cpc	r19, r25
    263a:	20 f0       	brcs	.+8      	; 0x2644 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    263c:	88 81       	ld	r24, Y
    263e:	99 81       	ldd	r25, Y+1	; 0x01
    2640:	9f 83       	std	Y+7, r25	; 0x07
    2642:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    2644:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2646:	91 50       	subi	r25, 0x01	; 1
    2648:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    264a:	6e 81       	ldd	r22, Y+6	; 0x06
    264c:	7f 81       	ldd	r23, Y+7	; 0x07
    264e:	cf 01       	movw	r24, r30
    2650:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2654:	88 85       	ldd	r24, Y+8	; 0x08
    2656:	81 11       	cpse	r24, r1
    2658:	02 c0       	rjmp	.+4      	; 0x265e <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    265a:	81 e0       	ldi	r24, 0x01	; 1
    265c:	09 c0       	rjmp	.+18     	; 0x2670 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    265e:	ce 01       	movw	r24, r28
    2660:	08 96       	adiw	r24, 0x08	; 8
    2662:	0e 94 cc 15 	call	0x2b98	; 0x2b98 <xCoRoutineRemoveFromEventList>
    2666:	88 23       	and	r24, r24
    2668:	c1 f3       	breq	.-16     	; 0x265a <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    266a:	8b ef       	ldi	r24, 0xFB	; 251
    266c:	01 c0       	rjmp	.+2      	; 0x2670 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    266e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    2670:	78 94       	sei

		return xReturn;
	}
    2672:	df 91       	pop	r29
    2674:	cf 91       	pop	r28
    2676:	08 95       	ret

00002678 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    2678:	0f 93       	push	r16
    267a:	1f 93       	push	r17
    267c:	cf 93       	push	r28
    267e:	8c 01       	movw	r16, r24
    2680:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2682:	fc 01       	movw	r30, r24
    2684:	92 8d       	ldd	r25, Z+26	; 0x1a
    2686:	83 8d       	ldd	r24, Z+27	; 0x1b
    2688:	98 17       	cp	r25, r24
    268a:	10 f0       	brcs	.+4      	; 0x2690 <xQueueCRSendFromISR+0x18>
    268c:	4c 2f       	mov	r20, r28
    268e:	12 c0       	rjmp	.+36     	; 0x26b4 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2690:	40 e0       	ldi	r20, 0x00	; 0
    2692:	c8 01       	movw	r24, r16
    2694:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    2698:	c1 11       	cpse	r28, r1
    269a:	f8 cf       	rjmp	.-16     	; 0x268c <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    269c:	f8 01       	movw	r30, r16
    269e:	81 89       	ldd	r24, Z+17	; 0x11
    26a0:	88 23       	and	r24, r24
    26a2:	39 f0       	breq	.+14     	; 0x26b2 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26a4:	c8 01       	movw	r24, r16
    26a6:	41 96       	adiw	r24, 0x11	; 17
    26a8:	0e 94 cc 15 	call	0x2b98	; 0x2b98 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    26ac:	41 e0       	ldi	r20, 0x01	; 1
    26ae:	81 11       	cpse	r24, r1
    26b0:	01 c0       	rjmp	.+2      	; 0x26b4 <xQueueCRSendFromISR+0x3c>
    26b2:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    26b4:	84 2f       	mov	r24, r20
    26b6:	cf 91       	pop	r28
    26b8:	1f 91       	pop	r17
    26ba:	0f 91       	pop	r16
    26bc:	08 95       	ret

000026be <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    26be:	0f 93       	push	r16
    26c0:	1f 93       	push	r17
    26c2:	cf 93       	push	r28
    26c4:	df 93       	push	r29
    26c6:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    26c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    26ca:	88 23       	and	r24, r24
    26cc:	79 f1       	breq	.+94     	; 0x272c <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    26ce:	24 8d       	ldd	r18, Z+28	; 0x1c
    26d0:	30 e0       	ldi	r19, 0x00	; 0
    26d2:	a6 81       	ldd	r26, Z+6	; 0x06
    26d4:	b7 81       	ldd	r27, Z+7	; 0x07
    26d6:	a2 0f       	add	r26, r18
    26d8:	b3 1f       	adc	r27, r19
    26da:	b7 83       	std	Z+7, r27	; 0x07
    26dc:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    26de:	84 81       	ldd	r24, Z+4	; 0x04
    26e0:	95 81       	ldd	r25, Z+5	; 0x05
    26e2:	a8 17       	cp	r26, r24
    26e4:	b9 07       	cpc	r27, r25
    26e6:	20 f0       	brcs	.+8      	; 0x26f0 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    26e8:	80 81       	ld	r24, Z
    26ea:	91 81       	ldd	r25, Z+1	; 0x01
    26ec:	97 83       	std	Z+7, r25	; 0x07
    26ee:	86 83       	std	Z+6, r24	; 0x06
    26f0:	8a 01       	movw	r16, r20
    26f2:	cb 01       	movw	r24, r22
    26f4:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    26f6:	42 8d       	ldd	r20, Z+26	; 0x1a
    26f8:	41 50       	subi	r20, 0x01	; 1
    26fa:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    26fc:	66 81       	ldd	r22, Z+6	; 0x06
    26fe:	77 81       	ldd	r23, Z+7	; 0x07
    2700:	a9 01       	movw	r20, r18
    2702:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    2706:	f8 01       	movw	r30, r16
    2708:	80 81       	ld	r24, Z
    270a:	88 23       	and	r24, r24
    270c:	11 f0       	breq	.+4      	; 0x2712 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    270e:	81 e0       	ldi	r24, 0x01	; 1
    2710:	0e c0       	rjmp	.+28     	; 0x272e <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2712:	88 85       	ldd	r24, Y+8	; 0x08
    2714:	88 23       	and	r24, r24
    2716:	d9 f3       	breq	.-10     	; 0x270e <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2718:	ce 01       	movw	r24, r28
    271a:	08 96       	adiw	r24, 0x08	; 8
    271c:	0e 94 cc 15 	call	0x2b98	; 0x2b98 <xCoRoutineRemoveFromEventList>
    2720:	88 23       	and	r24, r24
    2722:	a9 f3       	breq	.-22     	; 0x270e <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    2724:	81 e0       	ldi	r24, 0x01	; 1
    2726:	f8 01       	movw	r30, r16
    2728:	80 83       	st	Z, r24
    272a:	01 c0       	rjmp	.+2      	; 0x272e <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    272c:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    272e:	df 91       	pop	r29
    2730:	cf 91       	pop	r28
    2732:	1f 91       	pop	r17
    2734:	0f 91       	pop	r16
    2736:	08 95       	ret

00002738 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2738:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    273a:	03 96       	adiw	r24, 0x03	; 3
    273c:	92 83       	std	Z+2, r25	; 0x02
    273e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2740:	2f ef       	ldi	r18, 0xFF	; 255
    2742:	3f ef       	ldi	r19, 0xFF	; 255
    2744:	34 83       	std	Z+4, r19	; 0x04
    2746:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2748:	96 83       	std	Z+6, r25	; 0x06
    274a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    274c:	90 87       	std	Z+8, r25	; 0x08
    274e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2750:	10 82       	st	Z, r1
    2752:	08 95       	ret

00002754 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2754:	fc 01       	movw	r30, r24
    2756:	11 86       	std	Z+9, r1	; 0x09
    2758:	10 86       	std	Z+8, r1	; 0x08
    275a:	08 95       	ret

0000275c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    275c:	cf 93       	push	r28
    275e:	df 93       	push	r29
    2760:	9c 01       	movw	r18, r24
    2762:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2764:	dc 01       	movw	r26, r24
    2766:	11 96       	adiw	r26, 0x01	; 1
    2768:	cd 91       	ld	r28, X+
    276a:	dc 91       	ld	r29, X
    276c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    276e:	d3 83       	std	Z+3, r29	; 0x03
    2770:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2772:	8c 81       	ldd	r24, Y+4	; 0x04
    2774:	9d 81       	ldd	r25, Y+5	; 0x05
    2776:	95 83       	std	Z+5, r25	; 0x05
    2778:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    277a:	8c 81       	ldd	r24, Y+4	; 0x04
    277c:	9d 81       	ldd	r25, Y+5	; 0x05
    277e:	dc 01       	movw	r26, r24
    2780:	13 96       	adiw	r26, 0x03	; 3
    2782:	7c 93       	st	X, r23
    2784:	6e 93       	st	-X, r22
    2786:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    2788:	7d 83       	std	Y+5, r23	; 0x05
    278a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    278c:	31 87       	std	Z+9, r19	; 0x09
    278e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2790:	f9 01       	movw	r30, r18
    2792:	80 81       	ld	r24, Z
    2794:	8f 5f       	subi	r24, 0xFF	; 255
    2796:	80 83       	st	Z, r24
}
    2798:	df 91       	pop	r29
    279a:	cf 91       	pop	r28
    279c:	08 95       	ret

0000279e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    279e:	0f 93       	push	r16
    27a0:	1f 93       	push	r17
    27a2:	cf 93       	push	r28
    27a4:	df 93       	push	r29
    27a6:	8c 01       	movw	r16, r24
    27a8:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    27aa:	80 81       	ld	r24, Z
    27ac:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    27ae:	8f 3f       	cpi	r24, 0xFF	; 255
    27b0:	2f ef       	ldi	r18, 0xFF	; 255
    27b2:	92 07       	cpc	r25, r18
    27b4:	21 f4       	brne	.+8      	; 0x27be <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    27b6:	e8 01       	movw	r28, r16
    27b8:	af 81       	ldd	r26, Y+7	; 0x07
    27ba:	b8 85       	ldd	r27, Y+8	; 0x08
    27bc:	0e c0       	rjmp	.+28     	; 0x27da <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    27be:	d8 01       	movw	r26, r16
    27c0:	13 96       	adiw	r26, 0x03	; 3
    27c2:	12 96       	adiw	r26, 0x02	; 2
    27c4:	2d 91       	ld	r18, X+
    27c6:	3c 91       	ld	r19, X
    27c8:	13 97       	sbiw	r26, 0x03	; 3
    27ca:	e9 01       	movw	r28, r18
    27cc:	48 81       	ld	r20, Y
    27ce:	59 81       	ldd	r21, Y+1	; 0x01
    27d0:	84 17       	cp	r24, r20
    27d2:	95 07       	cpc	r25, r21
    27d4:	10 f0       	brcs	.+4      	; 0x27da <vListInsert+0x3c>
    27d6:	d9 01       	movw	r26, r18
    27d8:	f4 cf       	rjmp	.-24     	; 0x27c2 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    27da:	12 96       	adiw	r26, 0x02	; 2
    27dc:	8d 91       	ld	r24, X+
    27de:	9c 91       	ld	r25, X
    27e0:	13 97       	sbiw	r26, 0x03	; 3
    27e2:	93 83       	std	Z+3, r25	; 0x03
    27e4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    27e6:	ec 01       	movw	r28, r24
    27e8:	fd 83       	std	Y+5, r31	; 0x05
    27ea:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    27ec:	b5 83       	std	Z+5, r27	; 0x05
    27ee:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    27f0:	13 96       	adiw	r26, 0x03	; 3
    27f2:	fc 93       	st	X, r31
    27f4:	ee 93       	st	-X, r30
    27f6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    27f8:	11 87       	std	Z+9, r17	; 0x09
    27fa:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    27fc:	f8 01       	movw	r30, r16
    27fe:	80 81       	ld	r24, Z
    2800:	8f 5f       	subi	r24, 0xFF	; 255
    2802:	80 83       	st	Z, r24
}
    2804:	df 91       	pop	r29
    2806:	cf 91       	pop	r28
    2808:	1f 91       	pop	r17
    280a:	0f 91       	pop	r16
    280c:	08 95       	ret

0000280e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    280e:	cf 93       	push	r28
    2810:	df 93       	push	r29
    2812:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2814:	a0 85       	ldd	r26, Z+8	; 0x08
    2816:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2818:	82 81       	ldd	r24, Z+2	; 0x02
    281a:	93 81       	ldd	r25, Z+3	; 0x03
    281c:	24 81       	ldd	r18, Z+4	; 0x04
    281e:	35 81       	ldd	r19, Z+5	; 0x05
    2820:	ec 01       	movw	r28, r24
    2822:	3d 83       	std	Y+5, r19	; 0x05
    2824:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2826:	c4 81       	ldd	r28, Z+4	; 0x04
    2828:	d5 81       	ldd	r29, Z+5	; 0x05
    282a:	9b 83       	std	Y+3, r25	; 0x03
    282c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    282e:	11 96       	adiw	r26, 0x01	; 1
    2830:	8d 91       	ld	r24, X+
    2832:	9c 91       	ld	r25, X
    2834:	12 97       	sbiw	r26, 0x02	; 2
    2836:	e8 17       	cp	r30, r24
    2838:	f9 07       	cpc	r31, r25
    283a:	21 f4       	brne	.+8      	; 0x2844 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    283c:	12 96       	adiw	r26, 0x02	; 2
    283e:	dc 93       	st	X, r29
    2840:	ce 93       	st	-X, r28
    2842:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2844:	11 86       	std	Z+9, r1	; 0x09
    2846:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2848:	8c 91       	ld	r24, X
    284a:	81 50       	subi	r24, 0x01	; 1
    284c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    284e:	8c 91       	ld	r24, X
}
    2850:	df 91       	pop	r29
    2852:	cf 91       	pop	r28
    2854:	08 95       	ret

00002856 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    2856:	cf 92       	push	r12
    2858:	df 92       	push	r13
    285a:	ef 92       	push	r14
    285c:	ff 92       	push	r15
    285e:	1f 93       	push	r17
    2860:	cf 93       	push	r28
    2862:	df 93       	push	r29
    2864:	6c 01       	movw	r12, r24
    2866:	16 2f       	mov	r17, r22
    2868:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    286a:	8a e1       	ldi	r24, 0x1A	; 26
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <pvPortMalloc>
    2872:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    2874:	89 2b       	or	r24, r25
    2876:	09 f4       	brne	.+2      	; 0x287a <xCoRoutineCreate+0x24>
    2878:	57 c0       	rjmp	.+174    	; 0x2928 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    287a:	80 91 a3 02 	lds	r24, 0x02A3	; 0x8002a3 <pxCurrentCoRoutine>
    287e:	90 91 a4 02 	lds	r25, 0x02A4	; 0x8002a4 <pxCurrentCoRoutine+0x1>
    2882:	89 2b       	or	r24, r25
    2884:	21 f5       	brne	.+72     	; 0x28ce <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2886:	d0 93 a4 02 	sts	0x02A4, r29	; 0x8002a4 <pxCurrentCoRoutine+0x1>
    288a:	c0 93 a3 02 	sts	0x02A3, r28	; 0x8002a3 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    288e:	8b ec       	ldi	r24, 0xCB	; 203
    2890:	92 e0       	ldi	r25, 0x02	; 2
    2892:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
    2896:	84 ed       	ldi	r24, 0xD4	; 212
    2898:	92 e0       	ldi	r25, 0x02	; 2
    289a:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    289e:	82 ec       	ldi	r24, 0xC2	; 194
    28a0:	92 e0       	ldi	r25, 0x02	; 2
    28a2:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    28a6:	89 eb       	ldi	r24, 0xB9	; 185
    28a8:	92 e0       	ldi	r25, 0x02	; 2
    28aa:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    28ae:	8c ea       	ldi	r24, 0xAC	; 172
    28b0:	92 e0       	ldi	r25, 0x02	; 2
    28b2:	0e 94 9c 13 	call	0x2738	; 0x2738 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    28b6:	82 ec       	ldi	r24, 0xC2	; 194
    28b8:	92 e0       	ldi	r25, 0x02	; 2
    28ba:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <pxDelayedCoRoutineList+0x1>
    28be:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    28c2:	89 eb       	ldi	r24, 0xB9	; 185
    28c4:	92 e0       	ldi	r25, 0x02	; 2
    28c6:	90 93 b6 02 	sts	0x02B6, r25	; 0x8002b6 <pxOverflowDelayedCoRoutineList+0x1>
    28ca:	80 93 b5 02 	sts	0x02B5, r24	; 0x8002b5 <pxOverflowDelayedCoRoutineList>
    28ce:	11 11       	cpse	r17, r1
    28d0:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    28d2:	19 8e       	std	Y+25, r1	; 0x19
    28d4:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    28d6:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    28d8:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    28da:	fe 01       	movw	r30, r28
    28dc:	c1 92       	st	Z+, r12
    28de:	d1 92       	st	Z+, r13
    28e0:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    28e2:	cf 01       	movw	r24, r30
    28e4:	0e 94 aa 13 	call	0x2754	; 0x2754 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    28e8:	ce 01       	movw	r24, r28
    28ea:	0c 96       	adiw	r24, 0x0c	; 12
    28ec:	0e 94 aa 13 	call	0x2754	; 0x2754 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    28f0:	d9 87       	std	Y+9, r29	; 0x09
    28f2:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    28f4:	db 8b       	std	Y+19, r29	; 0x13
    28f6:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    28f8:	82 e0       	ldi	r24, 0x02	; 2
    28fa:	90 e0       	ldi	r25, 0x00	; 0
    28fc:	81 1b       	sub	r24, r17
    28fe:	91 09       	sbc	r25, r1
    2900:	9d 87       	std	Y+13, r25	; 0x0d
    2902:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2904:	8e 89       	ldd	r24, Y+22	; 0x16
    2906:	90 91 ab 02 	lds	r25, 0x02AB	; 0x8002ab <uxTopCoRoutineReadyPriority>
    290a:	98 17       	cp	r25, r24
    290c:	10 f4       	brcc	.+4      	; 0x2912 <xCoRoutineCreate+0xbc>
    290e:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <uxTopCoRoutineReadyPriority>
    2912:	f9 e0       	ldi	r31, 0x09	; 9
    2914:	8f 9f       	mul	r24, r31
    2916:	c0 01       	movw	r24, r0
    2918:	11 24       	eor	r1, r1
    291a:	b7 01       	movw	r22, r14
    291c:	85 53       	subi	r24, 0x35	; 53
    291e:	9d 4f       	sbci	r25, 0xFD	; 253
    2920:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>

		xReturn = pdPASS;
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	01 c0       	rjmp	.+2      	; 0x292a <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2928:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    292a:	df 91       	pop	r29
    292c:	cf 91       	pop	r28
    292e:	1f 91       	pop	r17
    2930:	ff 90       	pop	r15
    2932:	ef 90       	pop	r14
    2934:	df 90       	pop	r13
    2936:	cf 90       	pop	r12
    2938:	08 95       	ret

0000293a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    293a:	0f 93       	push	r16
    293c:	1f 93       	push	r17
    293e:	cf 93       	push	r28
    2940:	df 93       	push	r29
    2942:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2944:	c0 91 a9 02 	lds	r28, 0x02A9	; 0x8002a9 <xCoRoutineTickCount>
    2948:	d0 91 aa 02 	lds	r29, 0x02AA	; 0x8002aa <xCoRoutineTickCount+0x1>
    294c:	c8 0f       	add	r28, r24
    294e:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2950:	80 91 a3 02 	lds	r24, 0x02A3	; 0x8002a3 <pxCurrentCoRoutine>
    2954:	90 91 a4 02 	lds	r25, 0x02A4	; 0x8002a4 <pxCurrentCoRoutine+0x1>
    2958:	02 96       	adiw	r24, 0x02	; 2
    295a:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    295e:	e0 91 a3 02 	lds	r30, 0x02A3	; 0x8002a3 <pxCurrentCoRoutine>
    2962:	f0 91 a4 02 	lds	r31, 0x02A4	; 0x8002a4 <pxCurrentCoRoutine+0x1>
    2966:	d3 83       	std	Z+3, r29	; 0x03
    2968:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    296a:	80 91 a9 02 	lds	r24, 0x02A9	; 0x8002a9 <xCoRoutineTickCount>
    296e:	90 91 aa 02 	lds	r25, 0x02AA	; 0x8002aa <xCoRoutineTickCount+0x1>
    2972:	bf 01       	movw	r22, r30
    2974:	6e 5f       	subi	r22, 0xFE	; 254
    2976:	7f 4f       	sbci	r23, 0xFF	; 255
    2978:	c8 17       	cp	r28, r24
    297a:	d9 07       	cpc	r29, r25
    297c:	28 f4       	brcc	.+10     	; 0x2988 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    297e:	80 91 b5 02 	lds	r24, 0x02B5	; 0x8002b5 <pxOverflowDelayedCoRoutineList>
    2982:	90 91 b6 02 	lds	r25, 0x02B6	; 0x8002b6 <pxOverflowDelayedCoRoutineList+0x1>
    2986:	04 c0       	rjmp	.+8      	; 0x2990 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2988:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <pxDelayedCoRoutineList>
    298c:	90 91 b8 02 	lds	r25, 0x02B8	; 0x8002b8 <pxDelayedCoRoutineList+0x1>
    2990:	0e 94 cf 13 	call	0x279e	; 0x279e <vListInsert>
	}

	if( pxEventList )
    2994:	01 15       	cp	r16, r1
    2996:	11 05       	cpc	r17, r1
    2998:	69 f0       	breq	.+26     	; 0x29b4 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    299a:	60 91 a3 02 	lds	r22, 0x02A3	; 0x8002a3 <pxCurrentCoRoutine>
    299e:	70 91 a4 02 	lds	r23, 0x02A4	; 0x8002a4 <pxCurrentCoRoutine+0x1>
    29a2:	64 5f       	subi	r22, 0xF4	; 244
    29a4:	7f 4f       	sbci	r23, 0xFF	; 255
    29a6:	c8 01       	movw	r24, r16
	}
}
    29a8:	df 91       	pop	r29
    29aa:	cf 91       	pop	r28
    29ac:	1f 91       	pop	r17
    29ae:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    29b0:	0c 94 cf 13 	jmp	0x279e	; 0x279e <vListInsert>
	}
}
    29b4:	df 91       	pop	r29
    29b6:	cf 91       	pop	r28
    29b8:	1f 91       	pop	r17
    29ba:	0f 91       	pop	r16
    29bc:	08 95       	ret

000029be <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    29be:	ff 92       	push	r15
    29c0:	0f 93       	push	r16
    29c2:	1f 93       	push	r17
    29c4:	cf 93       	push	r28
    29c6:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    29c8:	99 e0       	ldi	r25, 0x09	; 9
    29ca:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    29cc:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <xPendingReadyCoRoutineList>
    29d0:	88 23       	and	r24, r24
    29d2:	11 f1       	breq	.+68     	; 0x2a18 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    29d4:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    29d6:	e0 91 b1 02 	lds	r30, 0x02B1	; 0x8002b1 <xPendingReadyCoRoutineList+0x5>
    29da:	f0 91 b2 02 	lds	r31, 0x02B2	; 0x8002b2 <xPendingReadyCoRoutineList+0x6>
    29de:	c6 81       	ldd	r28, Z+6	; 0x06
    29e0:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    29e2:	ce 01       	movw	r24, r28
    29e4:	0c 96       	adiw	r24, 0x0c	; 12
    29e6:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    29ea:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    29ec:	8e 01       	movw	r16, r28
    29ee:	0e 5f       	subi	r16, 0xFE	; 254
    29f0:	1f 4f       	sbci	r17, 0xFF	; 255
    29f2:	c8 01       	movw	r24, r16
    29f4:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    29f8:	8e 89       	ldd	r24, Y+22	; 0x16
    29fa:	90 91 ab 02 	lds	r25, 0x02AB	; 0x8002ab <uxTopCoRoutineReadyPriority>
    29fe:	98 17       	cp	r25, r24
    2a00:	10 f4       	brcc	.+4      	; 0x2a06 <vCoRoutineSchedule+0x48>
    2a02:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <uxTopCoRoutineReadyPriority>
    2a06:	f8 9e       	mul	r15, r24
    2a08:	c0 01       	movw	r24, r0
    2a0a:	11 24       	eor	r1, r1
    2a0c:	b8 01       	movw	r22, r16
    2a0e:	85 53       	subi	r24, 0x35	; 53
    2a10:	9d 4f       	sbci	r25, 0xFD	; 253
    2a12:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>
    2a16:	da cf       	rjmp	.-76     	; 0x29cc <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2a18:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <xTaskGetTickCount>
    2a1c:	20 91 a7 02 	lds	r18, 0x02A7	; 0x8002a7 <xLastTickCount>
    2a20:	30 91 a8 02 	lds	r19, 0x02A8	; 0x8002a8 <xLastTickCount+0x1>
    2a24:	82 1b       	sub	r24, r18
    2a26:	93 0b       	sbc	r25, r19
    2a28:	90 93 a6 02 	sts	0x02A6, r25	; 0x8002a6 <xPassedTicks+0x1>
    2a2c:	80 93 a5 02 	sts	0x02A5, r24	; 0x8002a5 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2a30:	89 e0       	ldi	r24, 0x09	; 9
    2a32:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2a34:	20 91 a5 02 	lds	r18, 0x02A5	; 0x8002a5 <xPassedTicks>
    2a38:	30 91 a6 02 	lds	r19, 0x02A6	; 0x8002a6 <xPassedTicks+0x1>
    2a3c:	80 91 a9 02 	lds	r24, 0x02A9	; 0x8002a9 <xCoRoutineTickCount>
    2a40:	90 91 aa 02 	lds	r25, 0x02AA	; 0x8002aa <xCoRoutineTickCount+0x1>
    2a44:	21 15       	cp	r18, r1
    2a46:	31 05       	cpc	r19, r1
    2a48:	09 f4       	brne	.+2      	; 0x2a4c <vCoRoutineSchedule+0x8e>
    2a4a:	54 c0       	rjmp	.+168    	; 0x2af4 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    2a4c:	01 96       	adiw	r24, 0x01	; 1
    2a4e:	90 93 aa 02 	sts	0x02AA, r25	; 0x8002aa <xCoRoutineTickCount+0x1>
    2a52:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <xCoRoutineTickCount>
		xPassedTicks--;
    2a56:	21 50       	subi	r18, 0x01	; 1
    2a58:	31 09       	sbc	r19, r1
    2a5a:	30 93 a6 02 	sts	0x02A6, r19	; 0x8002a6 <xPassedTicks+0x1>
    2a5e:	20 93 a5 02 	sts	0x02A5, r18	; 0x8002a5 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2a62:	89 2b       	or	r24, r25
    2a64:	09 f0       	breq	.+2      	; 0x2a68 <vCoRoutineSchedule+0xaa>
    2a66:	3e c0       	rjmp	.+124    	; 0x2ae4 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2a68:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <pxDelayedCoRoutineList>
    2a6c:	90 91 b8 02 	lds	r25, 0x02B8	; 0x8002b8 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2a70:	20 91 b5 02 	lds	r18, 0x02B5	; 0x8002b5 <pxOverflowDelayedCoRoutineList>
    2a74:	30 91 b6 02 	lds	r19, 0x02B6	; 0x8002b6 <pxOverflowDelayedCoRoutineList+0x1>
    2a78:	30 93 b8 02 	sts	0x02B8, r19	; 0x8002b8 <pxDelayedCoRoutineList+0x1>
    2a7c:	20 93 b7 02 	sts	0x02B7, r18	; 0x8002b7 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    2a80:	90 93 b6 02 	sts	0x02B6, r25	; 0x8002b6 <pxOverflowDelayedCoRoutineList+0x1>
    2a84:	80 93 b5 02 	sts	0x02B5, r24	; 0x8002b5 <pxOverflowDelayedCoRoutineList>
    2a88:	2d c0       	rjmp	.+90     	; 0x2ae4 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2a8a:	05 80       	ldd	r0, Z+5	; 0x05
    2a8c:	f6 81       	ldd	r31, Z+6	; 0x06
    2a8e:	e0 2d       	mov	r30, r0
    2a90:	c6 81       	ldd	r28, Z+6	; 0x06
    2a92:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2a94:	2a 81       	ldd	r18, Y+2	; 0x02
    2a96:	3b 81       	ldd	r19, Y+3	; 0x03
    2a98:	80 91 a9 02 	lds	r24, 0x02A9	; 0x8002a9 <xCoRoutineTickCount>
    2a9c:	90 91 aa 02 	lds	r25, 0x02AA	; 0x8002aa <xCoRoutineTickCount+0x1>
    2aa0:	82 17       	cp	r24, r18
    2aa2:	93 07       	cpc	r25, r19
    2aa4:	38 f2       	brcs	.-114    	; 0x2a34 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2aa6:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2aa8:	8e 01       	movw	r16, r28
    2aaa:	0e 5f       	subi	r16, 0xFE	; 254
    2aac:	1f 4f       	sbci	r17, 0xFF	; 255
    2aae:	c8 01       	movw	r24, r16
    2ab0:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    2ab4:	8c 89       	ldd	r24, Y+20	; 0x14
    2ab6:	9d 89       	ldd	r25, Y+21	; 0x15
    2ab8:	89 2b       	or	r24, r25
    2aba:	21 f0       	breq	.+8      	; 0x2ac4 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2abc:	ce 01       	movw	r24, r28
    2abe:	0c 96       	adiw	r24, 0x0c	; 12
    2ac0:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2ac4:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2ac6:	8e 89       	ldd	r24, Y+22	; 0x16
    2ac8:	90 91 ab 02 	lds	r25, 0x02AB	; 0x8002ab <uxTopCoRoutineReadyPriority>
    2acc:	98 17       	cp	r25, r24
    2ace:	10 f4       	brcc	.+4      	; 0x2ad4 <vCoRoutineSchedule+0x116>
    2ad0:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <uxTopCoRoutineReadyPriority>
    2ad4:	f8 9e       	mul	r15, r24
    2ad6:	c0 01       	movw	r24, r0
    2ad8:	11 24       	eor	r1, r1
    2ada:	b8 01       	movw	r22, r16
    2adc:	85 53       	subi	r24, 0x35	; 53
    2ade:	9d 4f       	sbci	r25, 0xFD	; 253
    2ae0:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2ae4:	e0 91 b7 02 	lds	r30, 0x02B7	; 0x8002b7 <pxDelayedCoRoutineList>
    2ae8:	f0 91 b8 02 	lds	r31, 0x02B8	; 0x8002b8 <pxDelayedCoRoutineList+0x1>
    2aec:	80 81       	ld	r24, Z
    2aee:	81 11       	cpse	r24, r1
    2af0:	cc cf       	rjmp	.-104    	; 0x2a8a <vCoRoutineSchedule+0xcc>
    2af2:	a0 cf       	rjmp	.-192    	; 0x2a34 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2af4:	90 93 a8 02 	sts	0x02A8, r25	; 0x8002a8 <xLastTickCount+0x1>
    2af8:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <xLastTickCount>
    2afc:	80 91 ab 02 	lds	r24, 0x02AB	; 0x8002ab <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b00:	69 e0       	ldi	r22, 0x09	; 9
    2b02:	48 2f       	mov	r20, r24
    2b04:	50 e0       	ldi	r21, 0x00	; 0
    2b06:	64 9f       	mul	r22, r20
    2b08:	90 01       	movw	r18, r0
    2b0a:	65 9f       	mul	r22, r21
    2b0c:	30 0d       	add	r19, r0
    2b0e:	11 24       	eor	r1, r1
    2b10:	f9 01       	movw	r30, r18
    2b12:	e5 53       	subi	r30, 0x35	; 53
    2b14:	fd 4f       	sbci	r31, 0xFD	; 253
    2b16:	90 81       	ld	r25, Z
    2b18:	91 11       	cpse	r25, r1
    2b1a:	0c c0       	rjmp	.+24     	; 0x2b34 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2b1c:	81 11       	cpse	r24, r1
    2b1e:	08 c0       	rjmp	.+16     	; 0x2b30 <vCoRoutineSchedule+0x172>
    2b20:	10 92 ab 02 	sts	0x02AB, r1	; 0x8002ab <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    2b24:	df 91       	pop	r29
    2b26:	cf 91       	pop	r28
    2b28:	1f 91       	pop	r17
    2b2a:	0f 91       	pop	r16
    2b2c:	ff 90       	pop	r15
    2b2e:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2b30:	81 50       	subi	r24, 0x01	; 1
    2b32:	e7 cf       	rjmp	.-50     	; 0x2b02 <vCoRoutineSchedule+0x144>
    2b34:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2b38:	a1 81       	ldd	r26, Z+1	; 0x01
    2b3a:	b2 81       	ldd	r27, Z+2	; 0x02
    2b3c:	12 96       	adiw	r26, 0x02	; 2
    2b3e:	0d 90       	ld	r0, X+
    2b40:	bc 91       	ld	r27, X
    2b42:	a0 2d       	mov	r26, r0
    2b44:	b2 83       	std	Z+2, r27	; 0x02
    2b46:	a1 83       	std	Z+1, r26	; 0x01
    2b48:	22 53       	subi	r18, 0x32	; 50
    2b4a:	3d 4f       	sbci	r19, 0xFD	; 253
    2b4c:	a2 17       	cp	r26, r18
    2b4e:	b3 07       	cpc	r27, r19
    2b50:	31 f4       	brne	.+12     	; 0x2b5e <vCoRoutineSchedule+0x1a0>
    2b52:	12 96       	adiw	r26, 0x02	; 2
    2b54:	8d 91       	ld	r24, X+
    2b56:	9c 91       	ld	r25, X
    2b58:	13 97       	sbiw	r26, 0x03	; 3
    2b5a:	92 83       	std	Z+2, r25	; 0x02
    2b5c:	81 83       	std	Z+1, r24	; 0x01
    2b5e:	89 e0       	ldi	r24, 0x09	; 9
    2b60:	84 9f       	mul	r24, r20
    2b62:	f0 01       	movw	r30, r0
    2b64:	85 9f       	mul	r24, r21
    2b66:	f0 0d       	add	r31, r0
    2b68:	11 24       	eor	r1, r1
    2b6a:	e5 53       	subi	r30, 0x35	; 53
    2b6c:	fd 4f       	sbci	r31, 0xFD	; 253
    2b6e:	01 80       	ldd	r0, Z+1	; 0x01
    2b70:	f2 81       	ldd	r31, Z+2	; 0x02
    2b72:	e0 2d       	mov	r30, r0
    2b74:	86 81       	ldd	r24, Z+6	; 0x06
    2b76:	97 81       	ldd	r25, Z+7	; 0x07
    2b78:	90 93 a4 02 	sts	0x02A4, r25	; 0x8002a4 <pxCurrentCoRoutine+0x1>
    2b7c:	80 93 a3 02 	sts	0x02A3, r24	; 0x8002a3 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2b80:	dc 01       	movw	r26, r24
    2b82:	ed 91       	ld	r30, X+
    2b84:	fc 91       	ld	r31, X
    2b86:	11 97       	sbiw	r26, 0x01	; 1
    2b88:	57 96       	adiw	r26, 0x17	; 23
    2b8a:	6c 91       	ld	r22, X

	return;
}
    2b8c:	df 91       	pop	r29
    2b8e:	cf 91       	pop	r28
    2b90:	1f 91       	pop	r17
    2b92:	0f 91       	pop	r16
    2b94:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2b96:	09 94       	ijmp

00002b98 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2b98:	0f 93       	push	r16
    2b9a:	1f 93       	push	r17
    2b9c:	cf 93       	push	r28
    2b9e:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2ba0:	dc 01       	movw	r26, r24
    2ba2:	15 96       	adiw	r26, 0x05	; 5
    2ba4:	ed 91       	ld	r30, X+
    2ba6:	fc 91       	ld	r31, X
    2ba8:	16 97       	sbiw	r26, 0x06	; 6
    2baa:	c6 81       	ldd	r28, Z+6	; 0x06
    2bac:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2bae:	8e 01       	movw	r16, r28
    2bb0:	04 5f       	subi	r16, 0xF4	; 244
    2bb2:	1f 4f       	sbci	r17, 0xFF	; 255
    2bb4:	c8 01       	movw	r24, r16
    2bb6:	0e 94 07 14 	call	0x280e	; 0x280e <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2bba:	b8 01       	movw	r22, r16
    2bbc:	8c ea       	ldi	r24, 0xAC	; 172
    2bbe:	92 e0       	ldi	r25, 0x02	; 2
    2bc0:	0e 94 ae 13 	call	0x275c	; 0x275c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2bc4:	e0 91 a3 02 	lds	r30, 0x02A3	; 0x8002a3 <pxCurrentCoRoutine>
    2bc8:	f0 91 a4 02 	lds	r31, 0x02A4	; 0x8002a4 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2bcc:	81 e0       	ldi	r24, 0x01	; 1
    2bce:	2e 89       	ldd	r18, Y+22	; 0x16
    2bd0:	96 89       	ldd	r25, Z+22	; 0x16
    2bd2:	29 17       	cp	r18, r25
    2bd4:	08 f4       	brcc	.+2      	; 0x2bd8 <xCoRoutineRemoveFromEventList+0x40>
    2bd6:	80 e0       	ldi	r24, 0x00	; 0
}
    2bd8:	df 91       	pop	r29
    2bda:	cf 91       	pop	r28
    2bdc:	1f 91       	pop	r17
    2bde:	0f 91       	pop	r16
    2be0:	08 95       	ret

00002be2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2be2:	cf 93       	push	r28
    2be4:	df 93       	push	r29
    2be6:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2be8:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2bec:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <pucAlignedHeap.2085>
    2bf0:	90 91 de 02 	lds	r25, 0x02DE	; 0x8002de <pucAlignedHeap.2085+0x1>
    2bf4:	89 2b       	or	r24, r25
    2bf6:	31 f4       	brne	.+12     	; 0x2c04 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2bf8:	82 ee       	ldi	r24, 0xE2	; 226
    2bfa:	92 e0       	ldi	r25, 0x02	; 2
    2bfc:	90 93 de 02 	sts	0x02DE, r25	; 0x8002de <pucAlignedHeap.2085+0x1>
    2c00:	80 93 dd 02 	sts	0x02DD, r24	; 0x8002dd <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2c04:	20 91 df 02 	lds	r18, 0x02DF	; 0x8002df <xNextFreeByte>
    2c08:	30 91 e0 02 	lds	r19, 0x02E0	; 0x8002e0 <xNextFreeByte+0x1>
    2c0c:	c9 01       	movw	r24, r18
    2c0e:	8c 0f       	add	r24, r28
    2c10:	9d 1f       	adc	r25, r29
    2c12:	87 3e       	cpi	r24, 0xE7	; 231
    2c14:	43 e0       	ldi	r20, 0x03	; 3
    2c16:	94 07       	cpc	r25, r20
    2c18:	70 f4       	brcc	.+28     	; 0x2c36 <pvPortMalloc+0x54>
    2c1a:	28 17       	cp	r18, r24
    2c1c:	39 07       	cpc	r19, r25
    2c1e:	58 f4       	brcc	.+22     	; 0x2c36 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2c20:	c0 91 dd 02 	lds	r28, 0x02DD	; 0x8002dd <pucAlignedHeap.2085>
    2c24:	d0 91 de 02 	lds	r29, 0x02DE	; 0x8002de <pucAlignedHeap.2085+0x1>
    2c28:	c2 0f       	add	r28, r18
    2c2a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2c2c:	90 93 e0 02 	sts	0x02E0, r25	; 0x8002e0 <xNextFreeByte+0x1>
    2c30:	80 93 df 02 	sts	0x02DF, r24	; 0x8002df <xNextFreeByte>
    2c34:	02 c0       	rjmp	.+4      	; 0x2c3a <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2c36:	c0 e0       	ldi	r28, 0x00	; 0
    2c38:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2c3a:	0e 94 9a 0a 	call	0x1534	; 0x1534 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2c3e:	ce 01       	movw	r24, r28
    2c40:	df 91       	pop	r29
    2c42:	cf 91       	pop	r28
    2c44:	08 95       	ret

00002c46 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2c46:	08 95       	ret

00002c48 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2c48:	10 92 e0 02 	sts	0x02E0, r1	; 0x8002e0 <xNextFreeByte+0x1>
    2c4c:	10 92 df 02 	sts	0x02DF, r1	; 0x8002df <xNextFreeByte>
    2c50:	08 95       	ret

00002c52 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2c52:	20 91 df 02 	lds	r18, 0x02DF	; 0x8002df <xNextFreeByte>
    2c56:	30 91 e0 02 	lds	r19, 0x02E0	; 0x8002e0 <xNextFreeByte+0x1>
}
    2c5a:	87 ee       	ldi	r24, 0xE7	; 231
    2c5c:	93 e0       	ldi	r25, 0x03	; 3
    2c5e:	82 1b       	sub	r24, r18
    2c60:	93 0b       	sbc	r25, r19
    2c62:	08 95       	ret

00002c64 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2c64:	31 e1       	ldi	r19, 0x11	; 17
    2c66:	fc 01       	movw	r30, r24
    2c68:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2c6a:	31 97       	sbiw	r30, 0x01	; 1
    2c6c:	22 e2       	ldi	r18, 0x22	; 34
    2c6e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2c70:	31 97       	sbiw	r30, 0x01	; 1
    2c72:	a3 e3       	ldi	r26, 0x33	; 51
    2c74:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c76:	31 97       	sbiw	r30, 0x01	; 1
    2c78:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c7a:	31 97       	sbiw	r30, 0x01	; 1
    2c7c:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2c7e:	31 97       	sbiw	r30, 0x01	; 1
    2c80:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2c82:	31 97       	sbiw	r30, 0x01	; 1
    2c84:	60 e8       	ldi	r22, 0x80	; 128
    2c86:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2c88:	31 97       	sbiw	r30, 0x01	; 1
    2c8a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2c8c:	31 97       	sbiw	r30, 0x01	; 1
    2c8e:	62 e0       	ldi	r22, 0x02	; 2
    2c90:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2c92:	31 97       	sbiw	r30, 0x01	; 1
    2c94:	63 e0       	ldi	r22, 0x03	; 3
    2c96:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2c98:	31 97       	sbiw	r30, 0x01	; 1
    2c9a:	64 e0       	ldi	r22, 0x04	; 4
    2c9c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2c9e:	31 97       	sbiw	r30, 0x01	; 1
    2ca0:	65 e0       	ldi	r22, 0x05	; 5
    2ca2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2ca4:	31 97       	sbiw	r30, 0x01	; 1
    2ca6:	66 e0       	ldi	r22, 0x06	; 6
    2ca8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2caa:	31 97       	sbiw	r30, 0x01	; 1
    2cac:	67 e0       	ldi	r22, 0x07	; 7
    2cae:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2cb0:	31 97       	sbiw	r30, 0x01	; 1
    2cb2:	68 e0       	ldi	r22, 0x08	; 8
    2cb4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2cb6:	31 97       	sbiw	r30, 0x01	; 1
    2cb8:	69 e0       	ldi	r22, 0x09	; 9
    2cba:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2cbc:	31 97       	sbiw	r30, 0x01	; 1
    2cbe:	60 e1       	ldi	r22, 0x10	; 16
    2cc0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2cc2:	31 97       	sbiw	r30, 0x01	; 1
    2cc4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2cc6:	31 97       	sbiw	r30, 0x01	; 1
    2cc8:	32 e1       	ldi	r19, 0x12	; 18
    2cca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2ccc:	31 97       	sbiw	r30, 0x01	; 1
    2cce:	33 e1       	ldi	r19, 0x13	; 19
    2cd0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2cd2:	31 97       	sbiw	r30, 0x01	; 1
    2cd4:	34 e1       	ldi	r19, 0x14	; 20
    2cd6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2cd8:	31 97       	sbiw	r30, 0x01	; 1
    2cda:	35 e1       	ldi	r19, 0x15	; 21
    2cdc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2cde:	31 97       	sbiw	r30, 0x01	; 1
    2ce0:	36 e1       	ldi	r19, 0x16	; 22
    2ce2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2ce4:	31 97       	sbiw	r30, 0x01	; 1
    2ce6:	37 e1       	ldi	r19, 0x17	; 23
    2ce8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2cea:	31 97       	sbiw	r30, 0x01	; 1
    2cec:	38 e1       	ldi	r19, 0x18	; 24
    2cee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2cf0:	31 97       	sbiw	r30, 0x01	; 1
    2cf2:	39 e1       	ldi	r19, 0x19	; 25
    2cf4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2cf6:	31 97       	sbiw	r30, 0x01	; 1
    2cf8:	30 e2       	ldi	r19, 0x20	; 32
    2cfa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2cfc:	31 97       	sbiw	r30, 0x01	; 1
    2cfe:	31 e2       	ldi	r19, 0x21	; 33
    2d00:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2d02:	31 97       	sbiw	r30, 0x01	; 1
    2d04:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2d06:	31 97       	sbiw	r30, 0x01	; 1
    2d08:	23 e2       	ldi	r18, 0x23	; 35
    2d0a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2d0c:	31 97       	sbiw	r30, 0x01	; 1
    2d0e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2d10:	31 97       	sbiw	r30, 0x01	; 1
    2d12:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2d14:	31 97       	sbiw	r30, 0x01	; 1
    2d16:	26 e2       	ldi	r18, 0x26	; 38
    2d18:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2d1a:	31 97       	sbiw	r30, 0x01	; 1
    2d1c:	27 e2       	ldi	r18, 0x27	; 39
    2d1e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2d20:	31 97       	sbiw	r30, 0x01	; 1
    2d22:	28 e2       	ldi	r18, 0x28	; 40
    2d24:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2d26:	31 97       	sbiw	r30, 0x01	; 1
    2d28:	29 e2       	ldi	r18, 0x29	; 41
    2d2a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2d2c:	31 97       	sbiw	r30, 0x01	; 1
    2d2e:	20 e3       	ldi	r18, 0x30	; 48
    2d30:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2d32:	31 97       	sbiw	r30, 0x01	; 1
    2d34:	21 e3       	ldi	r18, 0x31	; 49
    2d36:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2d38:	86 97       	sbiw	r24, 0x26	; 38
    2d3a:	08 95       	ret

00002d3c <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2d3c:	89 e0       	ldi	r24, 0x09	; 9
    2d3e:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
	OCR1AL = ucLowByte;
    2d42:	83 ec       	ldi	r24, 0xC3	; 195
    2d44:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2d48:	8b e0       	ldi	r24, 0x0B	; 11
    2d4a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK0;
    2d4e:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2d52:	82 60       	ori	r24, 0x02	; 2
	//TIMSK0 = ucLowByte;
	TIMSK1 = ucLowByte;
    2d54:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2d58:	a0 91 46 02 	lds	r26, 0x0246	; 0x800246 <pxCurrentTCB>
    2d5c:	b0 91 47 02 	lds	r27, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    2d60:	cd 91       	ld	r28, X+
    2d62:	cd bf       	out	0x3d, r28	; 61
    2d64:	dd 91       	ld	r29, X+
    2d66:	de bf       	out	0x3e, r29	; 62
    2d68:	ff 91       	pop	r31
    2d6a:	ef 91       	pop	r30
    2d6c:	df 91       	pop	r29
    2d6e:	cf 91       	pop	r28
    2d70:	bf 91       	pop	r27
    2d72:	af 91       	pop	r26
    2d74:	9f 91       	pop	r25
    2d76:	8f 91       	pop	r24
    2d78:	7f 91       	pop	r23
    2d7a:	6f 91       	pop	r22
    2d7c:	5f 91       	pop	r21
    2d7e:	4f 91       	pop	r20
    2d80:	3f 91       	pop	r19
    2d82:	2f 91       	pop	r18
    2d84:	1f 91       	pop	r17
    2d86:	0f 91       	pop	r16
    2d88:	ff 90       	pop	r15
    2d8a:	ef 90       	pop	r14
    2d8c:	df 90       	pop	r13
    2d8e:	cf 90       	pop	r12
    2d90:	bf 90       	pop	r11
    2d92:	af 90       	pop	r10
    2d94:	9f 90       	pop	r9
    2d96:	8f 90       	pop	r8
    2d98:	7f 90       	pop	r7
    2d9a:	6f 90       	pop	r6
    2d9c:	5f 90       	pop	r5
    2d9e:	4f 90       	pop	r4
    2da0:	3f 90       	pop	r3
    2da2:	2f 90       	pop	r2
    2da4:	1f 90       	pop	r1
    2da6:	0f 90       	pop	r0
    2da8:	0f be       	out	0x3f, r0	; 63
    2daa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2dac:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2dae:	81 e0       	ldi	r24, 0x01	; 1
    2db0:	08 95       	ret

00002db2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2db2:	08 95       	ret

00002db4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2db4:	0f 92       	push	r0
    2db6:	0f b6       	in	r0, 0x3f	; 63
    2db8:	f8 94       	cli
    2dba:	0f 92       	push	r0
    2dbc:	1f 92       	push	r1
    2dbe:	11 24       	eor	r1, r1
    2dc0:	2f 92       	push	r2
    2dc2:	3f 92       	push	r3
    2dc4:	4f 92       	push	r4
    2dc6:	5f 92       	push	r5
    2dc8:	6f 92       	push	r6
    2dca:	7f 92       	push	r7
    2dcc:	8f 92       	push	r8
    2dce:	9f 92       	push	r9
    2dd0:	af 92       	push	r10
    2dd2:	bf 92       	push	r11
    2dd4:	cf 92       	push	r12
    2dd6:	df 92       	push	r13
    2dd8:	ef 92       	push	r14
    2dda:	ff 92       	push	r15
    2ddc:	0f 93       	push	r16
    2dde:	1f 93       	push	r17
    2de0:	2f 93       	push	r18
    2de2:	3f 93       	push	r19
    2de4:	4f 93       	push	r20
    2de6:	5f 93       	push	r21
    2de8:	6f 93       	push	r22
    2dea:	7f 93       	push	r23
    2dec:	8f 93       	push	r24
    2dee:	9f 93       	push	r25
    2df0:	af 93       	push	r26
    2df2:	bf 93       	push	r27
    2df4:	cf 93       	push	r28
    2df6:	df 93       	push	r29
    2df8:	ef 93       	push	r30
    2dfa:	ff 93       	push	r31
    2dfc:	a0 91 46 02 	lds	r26, 0x0246	; 0x800246 <pxCurrentTCB>
    2e00:	b0 91 47 02 	lds	r27, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    2e04:	0d b6       	in	r0, 0x3d	; 61
    2e06:	0d 92       	st	X+, r0
    2e08:	0e b6       	in	r0, 0x3e	; 62
    2e0a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2e0c:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2e10:	a0 91 46 02 	lds	r26, 0x0246	; 0x800246 <pxCurrentTCB>
    2e14:	b0 91 47 02 	lds	r27, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    2e18:	cd 91       	ld	r28, X+
    2e1a:	cd bf       	out	0x3d, r28	; 61
    2e1c:	dd 91       	ld	r29, X+
    2e1e:	de bf       	out	0x3e, r29	; 62
    2e20:	ff 91       	pop	r31
    2e22:	ef 91       	pop	r30
    2e24:	df 91       	pop	r29
    2e26:	cf 91       	pop	r28
    2e28:	bf 91       	pop	r27
    2e2a:	af 91       	pop	r26
    2e2c:	9f 91       	pop	r25
    2e2e:	8f 91       	pop	r24
    2e30:	7f 91       	pop	r23
    2e32:	6f 91       	pop	r22
    2e34:	5f 91       	pop	r21
    2e36:	4f 91       	pop	r20
    2e38:	3f 91       	pop	r19
    2e3a:	2f 91       	pop	r18
    2e3c:	1f 91       	pop	r17
    2e3e:	0f 91       	pop	r16
    2e40:	ff 90       	pop	r15
    2e42:	ef 90       	pop	r14
    2e44:	df 90       	pop	r13
    2e46:	cf 90       	pop	r12
    2e48:	bf 90       	pop	r11
    2e4a:	af 90       	pop	r10
    2e4c:	9f 90       	pop	r9
    2e4e:	8f 90       	pop	r8
    2e50:	7f 90       	pop	r7
    2e52:	6f 90       	pop	r6
    2e54:	5f 90       	pop	r5
    2e56:	4f 90       	pop	r4
    2e58:	3f 90       	pop	r3
    2e5a:	2f 90       	pop	r2
    2e5c:	1f 90       	pop	r1
    2e5e:	0f 90       	pop	r0
    2e60:	0f be       	out	0x3f, r0	; 63
    2e62:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2e64:	08 95       	ret

00002e66 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2e66:	0f 92       	push	r0
    2e68:	0f b6       	in	r0, 0x3f	; 63
    2e6a:	f8 94       	cli
    2e6c:	0f 92       	push	r0
    2e6e:	1f 92       	push	r1
    2e70:	11 24       	eor	r1, r1
    2e72:	2f 92       	push	r2
    2e74:	3f 92       	push	r3
    2e76:	4f 92       	push	r4
    2e78:	5f 92       	push	r5
    2e7a:	6f 92       	push	r6
    2e7c:	7f 92       	push	r7
    2e7e:	8f 92       	push	r8
    2e80:	9f 92       	push	r9
    2e82:	af 92       	push	r10
    2e84:	bf 92       	push	r11
    2e86:	cf 92       	push	r12
    2e88:	df 92       	push	r13
    2e8a:	ef 92       	push	r14
    2e8c:	ff 92       	push	r15
    2e8e:	0f 93       	push	r16
    2e90:	1f 93       	push	r17
    2e92:	2f 93       	push	r18
    2e94:	3f 93       	push	r19
    2e96:	4f 93       	push	r20
    2e98:	5f 93       	push	r21
    2e9a:	6f 93       	push	r22
    2e9c:	7f 93       	push	r23
    2e9e:	8f 93       	push	r24
    2ea0:	9f 93       	push	r25
    2ea2:	af 93       	push	r26
    2ea4:	bf 93       	push	r27
    2ea6:	cf 93       	push	r28
    2ea8:	df 93       	push	r29
    2eaa:	ef 93       	push	r30
    2eac:	ff 93       	push	r31
    2eae:	a0 91 46 02 	lds	r26, 0x0246	; 0x800246 <pxCurrentTCB>
    2eb2:	b0 91 47 02 	lds	r27, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    2eb6:	0d b6       	in	r0, 0x3d	; 61
    2eb8:	0d 92       	st	X+, r0
    2eba:	0e b6       	in	r0, 0x3e	; 62
    2ebc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2ebe:	0e 94 ee 09 	call	0x13dc	; 0x13dc <xTaskIncrementTick>
    2ec2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2ec4:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2ec8:	a0 91 46 02 	lds	r26, 0x0246	; 0x800246 <pxCurrentTCB>
    2ecc:	b0 91 47 02 	lds	r27, 0x0247	; 0x800247 <pxCurrentTCB+0x1>
    2ed0:	cd 91       	ld	r28, X+
    2ed2:	cd bf       	out	0x3d, r28	; 61
    2ed4:	dd 91       	ld	r29, X+
    2ed6:	de bf       	out	0x3e, r29	; 62
    2ed8:	ff 91       	pop	r31
    2eda:	ef 91       	pop	r30
    2edc:	df 91       	pop	r29
    2ede:	cf 91       	pop	r28
    2ee0:	bf 91       	pop	r27
    2ee2:	af 91       	pop	r26
    2ee4:	9f 91       	pop	r25
    2ee6:	8f 91       	pop	r24
    2ee8:	7f 91       	pop	r23
    2eea:	6f 91       	pop	r22
    2eec:	5f 91       	pop	r21
    2eee:	4f 91       	pop	r20
    2ef0:	3f 91       	pop	r19
    2ef2:	2f 91       	pop	r18
    2ef4:	1f 91       	pop	r17
    2ef6:	0f 91       	pop	r16
    2ef8:	ff 90       	pop	r15
    2efa:	ef 90       	pop	r14
    2efc:	df 90       	pop	r13
    2efe:	cf 90       	pop	r12
    2f00:	bf 90       	pop	r11
    2f02:	af 90       	pop	r10
    2f04:	9f 90       	pop	r9
    2f06:	8f 90       	pop	r8
    2f08:	7f 90       	pop	r7
    2f0a:	6f 90       	pop	r6
    2f0c:	5f 90       	pop	r5
    2f0e:	4f 90       	pop	r4
    2f10:	3f 90       	pop	r3
    2f12:	2f 90       	pop	r2
    2f14:	1f 90       	pop	r1
    2f16:	0f 90       	pop	r0
    2f18:	0f be       	out	0x3f, r0	; 63
    2f1a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2f1c:	08 95       	ret

00002f1e <__vector_11>:
	 */
	//void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	//void SIG_OUTPUT_COMPARE1A( void )
    ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
    2f1e:	0e 94 33 17 	call	0x2e66	; 0x2e66 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2f22:	18 95       	reti

00002f24 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2f24:	0f 93       	push	r16
    2f26:	1f 93       	push	r17
    2f28:	cf 93       	push	r28
    2f2a:	df 93       	push	r29
    2f2c:	1f 92       	push	r1
    2f2e:	cd b7       	in	r28, 0x3d	; 61
    2f30:	de b7       	in	r29, 0x3e	; 62
    2f32:	8c 01       	movw	r16, r24
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2f34:	fc 01       	movw	r30, r24
    2f36:	80 8d       	ldd	r24, Z+24	; 0x18
    2f38:	91 8d       	ldd	r25, Z+25	; 0x19
    2f3a:	8e 36       	cpi	r24, 0x6E	; 110
    2f3c:	f1 e0       	ldi	r31, 0x01	; 1
    2f3e:	9f 07       	cpc	r25, r31
    2f40:	b1 f0       	breq	.+44     	; 0x2f6e <prvFlashCoRoutine+0x4a>
    2f42:	8f 36       	cpi	r24, 0x6F	; 111
    2f44:	21 e0       	ldi	r18, 0x01	; 1
    2f46:	92 07       	cpc	r25, r18
    2f48:	51 f1       	breq	.+84     	; 0x2f9e <prvFlashCoRoutine+0x7a>
    2f4a:	89 2b       	or	r24, r25
    2f4c:	61 f5       	brne	.+88     	; 0x2fa6 <prvFlashCoRoutine+0x82>
	( void ) uxIndex;

	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
    2f4e:	4f ef       	ldi	r20, 0xFF	; 255
    2f50:	5f ef       	ldi	r21, 0xFF	; 255
    2f52:	be 01       	movw	r22, r28
    2f54:	6f 5f       	subi	r22, 0xFF	; 255
    2f56:	7f 4f       	sbci	r23, 0xFF	; 255
    2f58:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <xFlashQueue>
    2f5c:	90 91 ca 06 	lds	r25, 0x06CA	; 0x8006ca <xFlashQueue+0x1>
    2f60:	0e 94 f5 12 	call	0x25ea	; 0x25ea <xQueueCRReceive>
    2f64:	8c 3f       	cpi	r24, 0xFC	; 252
    2f66:	71 f4       	brne	.+28     	; 0x2f84 <prvFlashCoRoutine+0x60>
    2f68:	8e e6       	ldi	r24, 0x6E	; 110
    2f6a:	91 e0       	ldi	r25, 0x01	; 1
    2f6c:	0f c0       	rjmp	.+30     	; 0x2f8c <prvFlashCoRoutine+0x68>
    2f6e:	40 e0       	ldi	r20, 0x00	; 0
    2f70:	50 e0       	ldi	r21, 0x00	; 0
    2f72:	be 01       	movw	r22, r28
    2f74:	6f 5f       	subi	r22, 0xFF	; 255
    2f76:	7f 4f       	sbci	r23, 0xFF	; 255
    2f78:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <xFlashQueue>
    2f7c:	90 91 ca 06 	lds	r25, 0x06CA	; 0x8006ca <xFlashQueue+0x1>
    2f80:	0e 94 f5 12 	call	0x25ea	; 0x25ea <xQueueCRReceive>
    2f84:	8b 3f       	cpi	r24, 0xFB	; 251
    2f86:	31 f4       	brne	.+12     	; 0x2f94 <prvFlashCoRoutine+0x70>
    2f88:	8f e6       	ldi	r24, 0x6F	; 111
    2f8a:	91 e0       	ldi	r25, 0x01	; 1
    2f8c:	f8 01       	movw	r30, r16
    2f8e:	91 8f       	std	Z+25, r25	; 0x19
    2f90:	80 8f       	std	Z+24, r24	; 0x18
    2f92:	09 c0       	rjmp	.+18     	; 0x2fa6 <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    2f94:	81 30       	cpi	r24, 0x01	; 1
    2f96:	19 f0       	breq	.+6      	; 0x2f9e <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    2f98:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <xCoRoutineFlashStatus>
    2f9c:	d8 cf       	rjmp	.-80     	; 0x2f4e <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    2f9e:	89 81       	ldd	r24, Y+1	; 0x01
    2fa0:	0e 94 af 00 	call	0x15e	; 0x15e <vParTestToggleLED>
    2fa4:	d4 cf       	rjmp	.-88     	; 0x2f4e <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2fa6:	0f 90       	pop	r0
    2fa8:	df 91       	pop	r29
    2faa:	cf 91       	pop	r28
    2fac:	1f 91       	pop	r17
    2fae:	0f 91       	pop	r16
    2fb0:	08 95       	ret

00002fb2 <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2fb2:	0f 93       	push	r16
    2fb4:	1f 93       	push	r17
    2fb6:	cf 93       	push	r28
    2fb8:	df 93       	push	r29
    2fba:	1f 92       	push	r1
    2fbc:	cd b7       	in	r28, 0x3d	; 61
    2fbe:	de b7       	in	r29, 0x3e	; 62
    2fc0:	8c 01       	movw	r16, r24
    2fc2:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2fc4:	fc 01       	movw	r30, r24
    2fc6:	80 8d       	ldd	r24, Z+24	; 0x18
    2fc8:	91 8d       	ldd	r25, Z+25	; 0x19
    2fca:	8e 32       	cpi	r24, 0x2E	; 46
    2fcc:	f1 e0       	ldi	r31, 0x01	; 1
    2fce:	9f 07       	cpc	r25, r31
    2fd0:	d9 f0       	breq	.+54     	; 0x3008 <prvFixedDelayCoRoutine+0x56>
    2fd2:	18 f4       	brcc	.+6      	; 0x2fda <prvFixedDelayCoRoutine+0x28>
    2fd4:	89 2b       	or	r24, r25
    2fd6:	41 f0       	breq	.+16     	; 0x2fe8 <prvFixedDelayCoRoutine+0x36>
    2fd8:	3e c0       	rjmp	.+124    	; 0x3056 <prvFixedDelayCoRoutine+0xa4>
    2fda:	8f 32       	cpi	r24, 0x2F	; 47
    2fdc:	e1 e0       	ldi	r30, 0x01	; 1
    2fde:	9e 07       	cpc	r25, r30
    2fe0:	39 f1       	breq	.+78     	; 0x3030 <prvFixedDelayCoRoutine+0x7e>
    2fe2:	82 34       	cpi	r24, 0x42	; 66
    2fe4:	91 40       	sbci	r25, 0x01	; 1
    2fe6:	b9 f5       	brne	.+110    	; 0x3056 <prvFixedDelayCoRoutine+0xa4>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    2fe8:	40 e0       	ldi	r20, 0x00	; 0
    2fea:	50 e0       	ldi	r21, 0x00	; 0
    2fec:	be 01       	movw	r22, r28
    2fee:	6f 5f       	subi	r22, 0xFF	; 255
    2ff0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ff2:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <xFlashQueue>
    2ff6:	90 91 ca 06 	lds	r25, 0x06CA	; 0x8006ca <xFlashQueue+0x1>
    2ffa:	0e 94 be 12 	call	0x257c	; 0x257c <xQueueCRSend>
    2ffe:	8c 3f       	cpi	r24, 0xFC	; 252
    3000:	71 f4       	brne	.+28     	; 0x301e <prvFixedDelayCoRoutine+0x6c>
    3002:	8e e2       	ldi	r24, 0x2E	; 46
    3004:	91 e0       	ldi	r25, 0x01	; 1
    3006:	24 c0       	rjmp	.+72     	; 0x3050 <prvFixedDelayCoRoutine+0x9e>
    3008:	40 e0       	ldi	r20, 0x00	; 0
    300a:	50 e0       	ldi	r21, 0x00	; 0
    300c:	be 01       	movw	r22, r28
    300e:	6f 5f       	subi	r22, 0xFF	; 255
    3010:	7f 4f       	sbci	r23, 0xFF	; 255
    3012:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <xFlashQueue>
    3016:	90 91 ca 06 	lds	r25, 0x06CA	; 0x8006ca <xFlashQueue+0x1>
    301a:	0e 94 be 12 	call	0x257c	; 0x257c <xQueueCRSend>
    301e:	8b 3f       	cpi	r24, 0xFB	; 251
    3020:	19 f4       	brne	.+6      	; 0x3028 <prvFixedDelayCoRoutine+0x76>
    3022:	8f e2       	ldi	r24, 0x2F	; 47
    3024:	91 e0       	ldi	r25, 0x01	; 1
    3026:	14 c0       	rjmp	.+40     	; 0x3050 <prvFixedDelayCoRoutine+0x9e>

		if( xResult != pdPASS )
    3028:	81 30       	cpi	r24, 0x01	; 1
    302a:	11 f0       	breq	.+4      	; 0x3030 <prvFixedDelayCoRoutine+0x7e>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    302c:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <xCoRoutineFlashStatus>
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    3030:	e9 81       	ldd	r30, Y+1	; 0x01
    3032:	f0 e0       	ldi	r31, 0x00	; 0
    3034:	ee 0f       	add	r30, r30
    3036:	ff 1f       	adc	r31, r31
    3038:	ec 5c       	subi	r30, 0xCC	; 204
    303a:	fe 4f       	sbci	r31, 0xFE	; 254
    303c:	80 81       	ld	r24, Z
    303e:	91 81       	ldd	r25, Z+1	; 0x01
    3040:	00 97       	sbiw	r24, 0x00	; 0
    3042:	21 f0       	breq	.+8      	; 0x304c <prvFixedDelayCoRoutine+0x9a>
    3044:	60 e0       	ldi	r22, 0x00	; 0
    3046:	70 e0       	ldi	r23, 0x00	; 0
    3048:	0e 94 9d 14 	call	0x293a	; 0x293a <vCoRoutineAddToDelayedList>
    304c:	82 e4       	ldi	r24, 0x42	; 66
    304e:	91 e0       	ldi	r25, 0x01	; 1
    3050:	f8 01       	movw	r30, r16
    3052:	91 8f       	std	Z+25, r25	; 0x19
    3054:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    3056:	0f 90       	pop	r0
    3058:	df 91       	pop	r29
    305a:	cf 91       	pop	r28
    305c:	1f 91       	pop	r17
    305e:	0f 91       	pop	r16
    3060:	08 95       	ret

00003062 <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    3062:	cf 93       	push	r28
    3064:	df 93       	push	r29
    3066:	d8 2f       	mov	r29, r24
    3068:	89 30       	cpi	r24, 0x09	; 9
    306a:	08 f0       	brcs	.+2      	; 0x306e <vStartFlashCoRoutines+0xc>
    306c:	d8 e0       	ldi	r29, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    306e:	40 e0       	ldi	r20, 0x00	; 0
    3070:	61 e0       	ldi	r22, 0x01	; 1
    3072:	81 e0       	ldi	r24, 0x01	; 1
    3074:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <xQueueGenericCreate>
    3078:	90 93 ca 06 	sts	0x06CA, r25	; 0x8006ca <xFlashQueue+0x1>
    307c:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <xFlashQueue>

	if( xFlashQueue )
    3080:	89 2b       	or	r24, r25
    3082:	99 f0       	breq	.+38     	; 0x30aa <vStartFlashCoRoutines+0x48>
    3084:	c0 e0       	ldi	r28, 0x00	; 0
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    3086:	cd 17       	cp	r28, r29
    3088:	41 f0       	breq	.+16     	; 0x309a <vStartFlashCoRoutines+0x38>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    308a:	4c 2f       	mov	r20, r28
    308c:	60 e0       	ldi	r22, 0x00	; 0
    308e:	89 ed       	ldi	r24, 0xD9	; 217
    3090:	97 e1       	ldi	r25, 0x17	; 23
    3092:	0e 94 2b 14 	call	0x2856	; 0x2856 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    3096:	cf 5f       	subi	r28, 0xFF	; 255
    3098:	f6 cf       	rjmp	.-20     	; 0x3086 <vStartFlashCoRoutines+0x24>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    309a:	40 e0       	ldi	r20, 0x00	; 0
    309c:	61 e0       	ldi	r22, 0x01	; 1
    309e:	82 e9       	ldi	r24, 0x92	; 146
    30a0:	97 e1       	ldi	r25, 0x17	; 23
	}
}
    30a2:	df 91       	pop	r29
    30a4:	cf 91       	pop	r28
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    30a6:	0c 94 2b 14 	jmp	0x2856	; 0x2856 <xCoRoutineCreate>
	}
}
    30aa:	df 91       	pop	r29
    30ac:	cf 91       	pop	r28
    30ae:	08 95       	ret

000030b0 <xAreFlashCoRoutinesStillRunning>:
BaseType_t xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    30b0:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <xCoRoutineFlashStatus>
    30b4:	08 95       	ret

000030b6 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    30b6:	cf 93       	push	r28
    30b8:	df 93       	push	r29
    30ba:	00 d0       	rcall	.+0      	; 0x30bc <vCompeteingIntMathTask+0x6>
    30bc:	00 d0       	rcall	.+0      	; 0x30be <vCompeteingIntMathTask+0x8>
    30be:	cd b7       	in	r28, 0x3d	; 61
    30c0:	de b7       	in	r29, 0x3e	; 62
    30c2:	7c 01       	movw	r14, r24
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    30c4:	00 e0       	ldi	r16, 0x00	; 0
    30c6:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    30c8:	8b e7       	ldi	r24, 0x7B	; 123
    30ca:	88 2e       	mov	r8, r24
    30cc:	91 2c       	mov	r9, r1
    30ce:	a1 2c       	mov	r10, r1
    30d0:	b1 2c       	mov	r11, r1
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
    30d2:	97 e0       	ldi	r25, 0x07	; 7
    30d4:	49 2e       	mov	r4, r25
    30d6:	51 2c       	mov	r5, r1
    30d8:	61 2c       	mov	r6, r1
    30da:	71 2c       	mov	r7, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    30dc:	dd 24       	eor	r13, r13
    30de:	d3 94       	inc	r13
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    30e0:	89 82       	std	Y+1, r8	; 0x01
    30e2:	9a 82       	std	Y+2, r9	; 0x02
    30e4:	ab 82       	std	Y+3, r10	; 0x03
    30e6:	bc 82       	std	Y+4, r11	; 0x04
		lValue += intgCONST2;
    30e8:	89 81       	ldd	r24, Y+1	; 0x01
    30ea:	9a 81       	ldd	r25, Y+2	; 0x02
    30ec:	ab 81       	ldd	r26, Y+3	; 0x03
    30ee:	bc 81       	ldd	r27, Y+4	; 0x04
    30f0:	89 5b       	subi	r24, 0xB9	; 185
    30f2:	9b 46       	sbci	r25, 0x6B	; 107
    30f4:	ac 4f       	sbci	r26, 0xFC	; 252
    30f6:	bf 4f       	sbci	r27, 0xFF	; 255
    30f8:	89 83       	std	Y+1, r24	; 0x01
    30fa:	9a 83       	std	Y+2, r25	; 0x02
    30fc:	ab 83       	std	Y+3, r26	; 0x03
    30fe:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    3100:	29 81       	ldd	r18, Y+1	; 0x01
    3102:	3a 81       	ldd	r19, Y+2	; 0x02
    3104:	4b 81       	ldd	r20, Y+3	; 0x03
    3106:	5c 81       	ldd	r21, Y+4	; 0x04
    3108:	ad ef       	ldi	r26, 0xFD	; 253
    310a:	bf ef       	ldi	r27, 0xFF	; 255
    310c:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <__mulohisi3>
    3110:	69 83       	std	Y+1, r22	; 0x01
    3112:	7a 83       	std	Y+2, r23	; 0x02
    3114:	8b 83       	std	Y+3, r24	; 0x03
    3116:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    3118:	69 81       	ldd	r22, Y+1	; 0x01
    311a:	7a 81       	ldd	r23, Y+2	; 0x02
    311c:	8b 81       	ldd	r24, Y+3	; 0x03
    311e:	9c 81       	ldd	r25, Y+4	; 0x04
    3120:	a3 01       	movw	r20, r6
    3122:	92 01       	movw	r18, r4
    3124:	0e 94 ba 2c 	call	0x5974	; 0x5974 <__divmodsi4>
    3128:	29 83       	std	Y+1, r18	; 0x01
    312a:	3a 83       	std	Y+2, r19	; 0x02
    312c:	4b 83       	std	Y+3, r20	; 0x03
    312e:	5c 83       	std	Y+4, r21	; 0x04

		/* If the calculation is found to be incorrect we stop setting the
		TaskHasExecuted variable so the check task can see an error has
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    3130:	89 81       	ldd	r24, Y+1	; 0x01
    3132:	9a 81       	ldd	r25, Y+2	; 0x02
    3134:	ab 81       	ldd	r26, Y+3	; 0x03
    3136:	bc 81       	ldd	r27, Y+4	; 0x04
    3138:	8b 31       	cpi	r24, 0x1B	; 27
    313a:	97 47       	sbci	r25, 0x77	; 119
    313c:	ae 4f       	sbci	r26, 0xFE	; 254
    313e:	bf 4f       	sbci	r27, 0xFF	; 255
    3140:	19 f0       	breq	.+6      	; 0x3148 <vCompeteingIntMathTask+0x92>
    3142:	01 e0       	ldi	r16, 0x01	; 1
    3144:	10 e0       	ldi	r17, 0x00	; 0
    3146:	cc cf       	rjmp	.-104    	; 0x30e0 <vCompeteingIntMathTask+0x2a>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    3148:	01 15       	cp	r16, r1
    314a:	11 05       	cpc	r17, r1
    314c:	d1 f7       	brne	.-12     	; 0x3142 <vCompeteingIntMathTask+0x8c>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    314e:	0f b6       	in	r0, 0x3f	; 63
    3150:	f8 94       	cli
    3152:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    3154:	f7 01       	movw	r30, r14
    3156:	d0 82       	st	Z, r13
			portEXIT_CRITICAL();
    3158:	0f 90       	pop	r0
    315a:	0f be       	out	0x3f, r0	; 63
    315c:	c1 cf       	rjmp	.-126    	; 0x30e0 <vCompeteingIntMathTask+0x2a>

0000315e <vStartIntegerMathTasks>:
static BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    315e:	ef 92       	push	r14
    3160:	ff 92       	push	r15
    3162:	0f 93       	push	r16
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    3164:	e1 2c       	mov	r14, r1
    3166:	f1 2c       	mov	r15, r1
    3168:	08 2f       	mov	r16, r24
    316a:	2b ec       	ldi	r18, 0xCB	; 203
    316c:	36 e0       	ldi	r19, 0x06	; 6
    316e:	45 e5       	ldi	r20, 0x55	; 85
    3170:	50 e0       	ldi	r21, 0x00	; 0
    3172:	60 e1       	ldi	r22, 0x10	; 16
    3174:	72 e0       	ldi	r23, 0x02	; 2
    3176:	8b e5       	ldi	r24, 0x5B	; 91
    3178:	98 e1       	ldi	r25, 0x18	; 24
    317a:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
	}
}
    317e:	0f 91       	pop	r16
    3180:	ff 90       	pop	r15
    3182:	ef 90       	pop	r14
    3184:	08 95       	ret

00003186 <xAreIntegerMathsTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
BaseType_t xReturn = pdTRUE;
    3186:	81 e0       	ldi	r24, 0x01	; 1
    3188:	90 91 cb 06 	lds	r25, 0x06CB	; 0x8006cb <xTaskCheck>
    318c:	91 11       	cpse	r25, r1
    318e:	01 c0       	rjmp	.+2      	; 0x3192 <xAreIntegerMathsTaskStillRunning+0xc>
    3190:	80 e0       	ldi	r24, 0x00	; 0
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    3192:	10 92 cb 06 	sts	0x06CB, r1	; 0x8006cb <xTaskCheck>
	}

	return xReturn;
}
    3196:	08 95       	ret

00003198 <vPolledQueueProducer>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    3198:	cf 93       	push	r28
    319a:	df 93       	push	r29
    319c:	00 d0       	rcall	.+0      	; 0x319e <vPolledQueueProducer+0x6>
    319e:	cd b7       	in	r28, 0x3d	; 61
    31a0:	de b7       	in	r29, 0x3e	; 62
    31a2:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    31a4:	1a 82       	std	Y+2, r1	; 0x02
    31a6:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xError = pdFALSE, xLoop;
    31a8:	00 e0       	ldi	r16, 0x00	; 0
    31aa:	13 e0       	ldi	r17, 0x03	; 3
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    31ac:	20 e0       	ldi	r18, 0x00	; 0
    31ae:	40 e0       	ldi	r20, 0x00	; 0
    31b0:	50 e0       	ldi	r21, 0x00	; 0
    31b2:	be 01       	movw	r22, r28
    31b4:	6f 5f       	subi	r22, 0xFF	; 255
    31b6:	7f 4f       	sbci	r23, 0xFF	; 255
    31b8:	f7 01       	movw	r30, r14
    31ba:	80 81       	ld	r24, Z
    31bc:	91 81       	ldd	r25, Z+1	; 0x01
    31be:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <xQueueGenericSend>
    31c2:	81 30       	cpi	r24, 0x01	; 1
    31c4:	91 f4       	brne	.+36     	; 0x31ea <vPolledQueueProducer+0x52>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    31c6:	01 11       	cpse	r16, r1
    31c8:	0a c0       	rjmp	.+20     	; 0x31de <vPolledQueueProducer+0x46>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    31ca:	0f b6       	in	r0, 0x3f	; 63
    31cc:	f8 94       	cli
    31ce:	0f 92       	push	r0
						xPollingProducerCount++;
    31d0:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <xPollingProducerCount>
    31d4:	8f 5f       	subi	r24, 0xFF	; 255
    31d6:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <xPollingProducerCount>
					portEXIT_CRITICAL();
    31da:	0f 90       	pop	r0
    31dc:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    31de:	89 81       	ldd	r24, Y+1	; 0x01
    31e0:	9a 81       	ldd	r25, Y+2	; 0x02
    31e2:	01 96       	adiw	r24, 0x01	; 1
    31e4:	9a 83       	std	Y+2, r25	; 0x02
    31e6:	89 83       	std	Y+1, r24	; 0x01
    31e8:	01 c0       	rjmp	.+2      	; 0x31ec <vPolledQueueProducer+0x54>
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    31ea:	01 e0       	ldi	r16, 0x01	; 1
    31ec:	11 50       	subi	r17, 0x01	; 1
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    31ee:	f1 f6       	brne	.-68     	; 0x31ac <vPolledQueueProducer+0x14>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    31f0:	84 e1       	ldi	r24, 0x14	; 20
    31f2:	90 e0       	ldi	r25, 0x00	; 0
    31f4:	0e 94 40 0b 	call	0x1680	; 0x1680 <vTaskDelay>
	}
    31f8:	d8 cf       	rjmp	.-80     	; 0x31aa <vPolledQueueProducer+0x12>

000031fa <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    31fa:	cf 93       	push	r28
    31fc:	df 93       	push	r29
    31fe:	00 d0       	rcall	.+0      	; 0x3200 <vPolledQueueConsumer+0x6>
    3200:	cd b7       	in	r28, 0x3d	; 61
    3202:	de b7       	in	r29, 0x3e	; 62
    3204:	6c 01       	movw	r12, r24
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE;
    3206:	f1 2c       	mov	r15, r1
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    3208:	00 e0       	ldi	r16, 0x00	; 0
    320a:	10 e0       	ldi	r17, 0x00	; 0
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    320c:	f6 01       	movw	r30, r12
    320e:	80 81       	ld	r24, Z
    3210:	91 81       	ldd	r25, Z+1	; 0x01
    3212:	0e 94 9a 12 	call	0x2534	; 0x2534 <uxQueueMessagesWaiting>
    3216:	88 23       	and	r24, r24
    3218:	21 f1       	breq	.+72     	; 0x3262 <vPolledQueueConsumer+0x68>
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    321a:	40 e0       	ldi	r20, 0x00	; 0
    321c:	50 e0       	ldi	r21, 0x00	; 0
    321e:	be 01       	movw	r22, r28
    3220:	6f 5f       	subi	r22, 0xFF	; 255
    3222:	7f 4f       	sbci	r23, 0xFF	; 255
    3224:	f6 01       	movw	r30, r12
    3226:	80 81       	ld	r24, Z
    3228:	91 81       	ldd	r25, Z+1	; 0x01
    322a:	0e 94 aa 10 	call	0x2154	; 0x2154 <xQueueReceive>
    322e:	81 30       	cpi	r24, 0x01	; 1
    3230:	69 f7       	brne	.-38     	; 0x320c <vPolledQueueConsumer+0x12>
			{
				if( usData != usExpectedValue )
    3232:	89 81       	ldd	r24, Y+1	; 0x01
    3234:	9a 81       	ldd	r25, Y+2	; 0x02
    3236:	08 17       	cp	r16, r24
    3238:	19 07       	cpc	r17, r25
    323a:	69 f4       	brne	.+26     	; 0x3256 <vPolledQueueConsumer+0x5c>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    323c:	f1 10       	cpse	r15, r1
    323e:	0e c0       	rjmp	.+28     	; 0x325c <vPolledQueueConsumer+0x62>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    3240:	0f b6       	in	r0, 0x3f	; 63
    3242:	f8 94       	cli
    3244:	0f 92       	push	r0
							xPollingConsumerCount++;
    3246:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <xPollingConsumerCount>
    324a:	8f 5f       	subi	r24, 0xFF	; 255
    324c:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <xPollingConsumerCount>
						portEXIT_CRITICAL();
    3250:	0f 90       	pop	r0
    3252:	0f be       	out	0x3f, r0	; 63
    3254:	03 c0       	rjmp	.+6      	; 0x325c <vPolledQueueConsumer+0x62>
    3256:	8c 01       	movw	r16, r24
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    3258:	ff 24       	eor	r15, r15
    325a:	f3 94       	inc	r15
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    325c:	0f 5f       	subi	r16, 0xFF	; 255
    325e:	1f 4f       	sbci	r17, 0xFF	; 255
    3260:	d5 cf       	rjmp	.-86     	; 0x320c <vPolledQueueConsumer+0x12>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    3262:	82 e1       	ldi	r24, 0x12	; 18
    3264:	90 e0       	ldi	r25, 0x00	; 0
    3266:	0e 94 40 0b 	call	0x1680	; 0x1680 <vTaskDelay>
	}
    326a:	d0 cf       	rjmp	.-96     	; 0x320c <vPolledQueueConsumer+0x12>

0000326c <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    326c:	ef 92       	push	r14
    326e:	ff 92       	push	r15
    3270:	0f 93       	push	r16
    3272:	cf 93       	push	r28
    3274:	c8 2f       	mov	r28, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    3276:	40 e0       	ldi	r20, 0x00	; 0
    3278:	62 e0       	ldi	r22, 0x02	; 2
    327a:	8a e0       	ldi	r24, 0x0A	; 10
    327c:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <xQueueGenericCreate>
    3280:	90 93 cd 06 	sts	0x06CD, r25	; 0x8006cd <xPolledQueue.2207+0x1>
    3284:	80 93 cc 06 	sts	0x06CC, r24	; 0x8006cc <xPolledQueue.2207>

	if( xPolledQueue != NULL )
    3288:	89 2b       	or	r24, r25
    328a:	b9 f0       	breq	.+46     	; 0x32ba <vStartPolledQueueTasks+0x4e>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    328c:	e1 2c       	mov	r14, r1
    328e:	f1 2c       	mov	r15, r1
    3290:	0c 2f       	mov	r16, r28
    3292:	2c ec       	ldi	r18, 0xCC	; 204
    3294:	36 e0       	ldi	r19, 0x06	; 6
    3296:	45 e5       	ldi	r20, 0x55	; 85
    3298:	50 e0       	ldi	r21, 0x00	; 0
    329a:	68 e1       	ldi	r22, 0x18	; 24
    329c:	72 e0       	ldi	r23, 0x02	; 2
    329e:	8d ef       	ldi	r24, 0xFD	; 253
    32a0:	98 e1       	ldi	r25, 0x18	; 24
    32a2:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    32a6:	2c ec       	ldi	r18, 0xCC	; 204
    32a8:	36 e0       	ldi	r19, 0x06	; 6
    32aa:	45 e5       	ldi	r20, 0x55	; 85
    32ac:	50 e0       	ldi	r21, 0x00	; 0
    32ae:	60 e2       	ldi	r22, 0x20	; 32
    32b0:	72 e0       	ldi	r23, 0x02	; 2
    32b2:	8c ec       	ldi	r24, 0xCC	; 204
    32b4:	98 e1       	ldi	r25, 0x18	; 24
    32b6:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
	}
}
    32ba:	cf 91       	pop	r28
    32bc:	0f 91       	pop	r16
    32be:	ff 90       	pop	r15
    32c0:	ef 90       	pop	r14
    32c2:	08 95       	ret

000032c4 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    32c4:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <xPollingConsumerCount>
    32c8:	88 23       	and	r24, r24
    32ca:	29 f0       	breq	.+10     	; 0x32d6 <xArePollingQueuesStillRunning+0x12>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    32cc:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <xPollingProducerCount>
	  )
	{
		xReturn = pdFALSE;
    32d0:	81 e0       	ldi	r24, 0x01	; 1
    32d2:	91 11       	cpse	r25, r1
    32d4:	01 c0       	rjmp	.+2      	; 0x32d8 <xArePollingQueuesStillRunning+0x14>
    32d6:	80 e0       	ldi	r24, 0x00	; 0
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    32d8:	10 92 cf 06 	sts	0x06CF, r1	; 0x8006cf <xPollingConsumerCount>
	xPollingProducerCount = pollqINITIAL_VALUE;
    32dc:	10 92 ce 06 	sts	0x06CE, r1	; 0x8006ce <xPollingProducerCount>

	return xReturn;
}
    32e0:	08 95       	ret

000032e2 <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    32e2:	cf 93       	push	r28
    32e4:	df 93       	push	r29
    32e6:	1f 92       	push	r1
    32e8:	cd b7       	in	r28, 0x3d	; 61
    32ea:	de b7       	in	r29, 0x3e	; 62
signed char cExpectedByte, cByteRxed;
BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
    32ec:	00 e0       	ldi	r16, 0x00	; 0

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    32ee:	11 e4       	ldi	r17, 0x41	; 65
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    32f0:	4f ef       	ldi	r20, 0xFF	; 255
    32f2:	5f ef       	ldi	r21, 0xFF	; 255
    32f4:	be 01       	movw	r22, r28
    32f6:	6f 5f       	subi	r22, 0xFF	; 255
    32f8:	7f 4f       	sbci	r23, 0xFF	; 255
    32fa:	80 e0       	ldi	r24, 0x00	; 0
    32fc:	90 e0       	ldi	r25, 0x00	; 0
    32fe:	0e 94 1c 01 	call	0x238	; 0x238 <xSerialGetChar>
    3302:	88 23       	and	r24, r24
    3304:	41 f0       	breq	.+16     	; 0x3316 <vComRxTask+0x34>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    3306:	89 81       	ldd	r24, Y+1	; 0x01
    3308:	81 13       	cpse	r24, r17
    330a:	0a c0       	rjmp	.+20     	; 0x3320 <vComRxTask+0x3e>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    330c:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxBaseLED>
    3310:	8f 5f       	subi	r24, 0xFF	; 255
    3312:	0e 94 af 00 	call	0x15e	; 0x15e <vParTestToggleLED>
    3316:	1f 5f       	subi	r17, 0xFF	; 255

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    3318:	19 35       	cpi	r17, 0x59	; 89
    331a:	51 f7       	brne	.-44     	; 0x32f0 <vComRxTask+0xe>
    331c:	10 e0       	ldi	r17, 0x00	; 0
    331e:	01 c0       	rjmp	.+2      	; 0x3322 <vComRxTask+0x40>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
				}
				else
				{
					xResyncRequired = pdTRUE;
    3320:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    3322:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxBaseLED>
    3326:	60 e0       	ldi	r22, 0x00	; 0
    3328:	8f 5f       	subi	r24, 0xFF	; 255
    332a:	0e 94 8b 00 	call	0x116	; 0x116 <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    332e:	11 30       	cpi	r17, 0x01	; 1
    3330:	79 f4       	brne	.+30     	; 0x3350 <vComRxTask+0x6e>
		{
			while( cByteRxed != comLAST_BYTE )
    3332:	89 81       	ldd	r24, Y+1	; 0x01
    3334:	88 35       	cpi	r24, 0x58	; 88
    3336:	51 f0       	breq	.+20     	; 0x334c <vComRxTask+0x6a>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    3338:	4f ef       	ldi	r20, 0xFF	; 255
    333a:	5f ef       	ldi	r21, 0xFF	; 255
    333c:	be 01       	movw	r22, r28
    333e:	6f 5f       	subi	r22, 0xFF	; 255
    3340:	7f 4f       	sbci	r23, 0xFF	; 255
    3342:	80 e0       	ldi	r24, 0x00	; 0
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	0e 94 1c 01 	call	0x238	; 0x238 <xSerialGetChar>
    334a:	f3 cf       	rjmp	.-26     	; 0x3332 <vComRxTask+0x50>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    334c:	0f 5f       	subi	r16, 0xFF	; 255
    334e:	cf cf       	rjmp	.-98     	; 0x32ee <vComRxTask+0xc>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    3350:	02 30       	cpi	r16, 0x02	; 2
    3352:	6c f6       	brge	.-102    	; 0x32ee <vComRxTask+0xc>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    3354:	80 91 d0 06 	lds	r24, 0x06D0	; 0x8006d0 <uxRxLoops>
    3358:	8f 5f       	subi	r24, 0xFF	; 255
    335a:	80 93 d0 06 	sts	0x06D0, r24	; 0x8006d0 <uxRxLoops>
    335e:	c7 cf       	rjmp	.-114    	; 0x32ee <vComRxTask+0xc>

00003360 <vComTxTask>:
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    3360:	06 e9       	ldi	r16, 0x96	; 150
    3362:	10 e0       	ldi	r17, 0x00	; 0

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    3364:	c1 e4       	ldi	r28, 0x41	; 65
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    3366:	40 e0       	ldi	r20, 0x00	; 0
    3368:	50 e0       	ldi	r21, 0x00	; 0
    336a:	6c 2f       	mov	r22, r28
    336c:	80 e0       	ldi	r24, 0x00	; 0
    336e:	90 e0       	ldi	r25, 0x00	; 0
    3370:	0e 94 28 01 	call	0x250	; 0x250 <xSerialPutChar>
    3374:	81 30       	cpi	r24, 0x01	; 1
    3376:	21 f4       	brne	.+8      	; 0x3380 <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    3378:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxBaseLED>
    337c:	0e 94 af 00 	call	0x15e	; 0x15e <vParTestToggleLED>
    3380:	cf 5f       	subi	r28, 0xFF	; 255

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    3382:	c9 35       	cpi	r28, 0x59	; 89
    3384:	81 f7       	brne	.-32     	; 0x3366 <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    3386:	60 e0       	ldi	r22, 0x00	; 0
    3388:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxBaseLED>
    338c:	0e 94 8b 00 	call	0x116	; 0x116 <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    3390:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <xTaskGetTickCount>
    3394:	03 96       	adiw	r24, 0x03	; 3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    3396:	b8 01       	movw	r22, r16
    3398:	0e 94 84 2c 	call	0x5908	; 0x5908 <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    339c:	82 33       	cpi	r24, 0x32	; 50
    339e:	91 05       	cpc	r25, r1
    33a0:	10 f4       	brcc	.+4      	; 0x33a6 <vComTxTask+0x46>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
    33a2:	82 e3       	ldi	r24, 0x32	; 50
    33a4:	90 e0       	ldi	r25, 0x00	; 0
		}

		vTaskDelay( xTimeToWait );
    33a6:	0e 94 40 0b 	call	0x1680	; 0x1680 <vTaskDelay>
	}
    33aa:	dc cf       	rjmp	.-72     	; 0x3364 <vComTxTask+0x4>

000033ac <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    33ac:	ef 92       	push	r14
    33ae:	ff 92       	push	r15
    33b0:	0f 93       	push	r16
    33b2:	cf 93       	push	r28
    33b4:	c8 2f       	mov	r28, r24
    33b6:	cb 01       	movw	r24, r22
    33b8:	ba 01       	movw	r22, r20
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    33ba:	20 93 d1 06 	sts	0x06D1, r18	; 0x8006d1 <uxBaseLED>
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    33be:	48 e1       	ldi	r20, 0x18	; 24
    33c0:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    33c4:	0f ef       	ldi	r16, 0xFF	; 255
    33c6:	0c 0f       	add	r16, r28
    33c8:	e1 2c       	mov	r14, r1
    33ca:	f1 2c       	mov	r15, r1
    33cc:	20 e0       	ldi	r18, 0x00	; 0
    33ce:	30 e0       	ldi	r19, 0x00	; 0
    33d0:	45 e5       	ldi	r20, 0x55	; 85
    33d2:	50 e0       	ldi	r21, 0x00	; 0
    33d4:	68 e2       	ldi	r22, 0x28	; 40
    33d6:	72 e0       	ldi	r23, 0x02	; 2
    33d8:	80 eb       	ldi	r24, 0xB0	; 176
    33da:	99 e1       	ldi	r25, 0x19	; 25
    33dc:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    33e0:	0c 2f       	mov	r16, r28
    33e2:	20 e0       	ldi	r18, 0x00	; 0
    33e4:	30 e0       	ldi	r19, 0x00	; 0
    33e6:	45 e5       	ldi	r20, 0x55	; 85
    33e8:	50 e0       	ldi	r21, 0x00	; 0
    33ea:	6e e2       	ldi	r22, 0x2E	; 46
    33ec:	72 e0       	ldi	r23, 0x02	; 2
    33ee:	81 e7       	ldi	r24, 0x71	; 113
    33f0:	99 e1       	ldi	r25, 0x19	; 25
    33f2:	0e 94 4f 08 	call	0x109e	; 0x109e <xTaskCreate>
}
    33f6:	cf 91       	pop	r28
    33f8:	0f 91       	pop	r16
    33fa:	ff 90       	pop	r15
    33fc:	ef 90       	pop	r14
    33fe:	08 95       	ret

00003400 <xAreComTestTasksStillRunning>:
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    3400:	90 91 d0 06 	lds	r25, 0x06D0	; 0x8006d0 <uxRxLoops>
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    3404:	10 92 d0 06 	sts	0x06D0, r1	; 0x8006d0 <uxRxLoops>

	return xReturn;
    3408:	81 e0       	ldi	r24, 0x01	; 1
    340a:	91 11       	cpse	r25, r1
    340c:	01 c0       	rjmp	.+2      	; 0x3410 <xAreComTestTasksStillRunning+0x10>
    340e:	80 e0       	ldi	r24, 0x00	; 0
}
    3410:	08 95       	ret

00003412 <close>:
   while(getSn_SR(sn) == SOCK_CLOSED);
   return (int8_t)sn;
}	   

int8_t close(uint8_t sn)
{
    3412:	8f 92       	push	r8
    3414:	9f 92       	push	r9
    3416:	af 92       	push	r10
    3418:	bf 92       	push	r11
    341a:	cf 92       	push	r12
    341c:	df 92       	push	r13
    341e:	ef 92       	push	r14
    3420:	ff 92       	push	r15
    3422:	0f 93       	push	r16
    3424:	1f 93       	push	r17
    3426:	cf 93       	push	r28
    3428:	df 93       	push	r29
	CHECK_SOCKNUM();
    342a:	89 30       	cpi	r24, 0x09	; 9
    342c:	08 f0       	brcs	.+2      	; 0x3430 <close+0x1e>
    342e:	59 c0       	rjmp	.+178    	; 0x34e2 <close+0xd0>
    3430:	f8 2e       	mov	r15, r24
      while(getSn_CR(sn) != 0);
      while(getSn_SR(sn) != SOCK_UDP);
      sendto(sn,destip,1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0.1).
   };   
#endif 
	setSn_CR(sn,Sn_CR_CLOSE);
    3432:	08 2f       	mov	r16, r24
    3434:	10 e0       	ldi	r17, 0x00	; 0
    3436:	e8 01       	movw	r28, r16
    3438:	95 e0       	ldi	r25, 0x05	; 5
    343a:	cc 0f       	add	r28, r28
    343c:	dd 1f       	adc	r29, r29
    343e:	9a 95       	dec	r25
    3440:	e1 f7       	brne	.-8      	; 0x343a <close+0x28>
    3442:	28 96       	adiw	r28, 0x08	; 8
    3444:	4e 01       	movw	r8, r28
    3446:	93 94       	inc	r9
    3448:	09 2c       	mov	r0, r9
    344a:	00 0c       	add	r0, r0
    344c:	aa 08       	sbc	r10, r10
    344e:	bb 08       	sbc	r11, r11
    3450:	40 e1       	ldi	r20, 0x10	; 16
    3452:	c5 01       	movw	r24, r10
    3454:	b4 01       	movw	r22, r8
    3456:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   /* wait to process the command... */
	while( getSn_CR(sn) );
    345a:	c5 01       	movw	r24, r10
    345c:	b4 01       	movw	r22, r8
    345e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3462:	81 11       	cpse	r24, r1
    3464:	fa cf       	rjmp	.-12     	; 0x345a <close+0x48>
	/* clear all interrupt of the socket. */
	setSn_IR(sn, 0xFF);
    3466:	be 01       	movw	r22, r28
    3468:	7e 5f       	subi	r23, 0xFE	; 254
    346a:	07 2e       	mov	r0, r23
    346c:	00 0c       	add	r0, r0
    346e:	88 0b       	sbc	r24, r24
    3470:	99 0b       	sbc	r25, r25
    3472:	4f e1       	ldi	r20, 0x1F	; 31
    3474:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
	//A20150401 : Release the sock_io_mode of socket n.
	sock_io_mode &= ~(1<<sn);
    3478:	81 e0       	ldi	r24, 0x01	; 1
    347a:	90 e0       	ldi	r25, 0x00	; 0
    347c:	02 c0       	rjmp	.+4      	; 0x3482 <close+0x70>
    347e:	88 0f       	add	r24, r24
    3480:	99 1f       	adc	r25, r25
    3482:	fa 94       	dec	r15
    3484:	e2 f7       	brpl	.-8      	; 0x347e <close+0x6c>
    3486:	80 95       	com	r24
    3488:	90 95       	com	r25
    348a:	20 91 ec 06 	lds	r18, 0x06EC	; 0x8006ec <sock_io_mode>
    348e:	30 91 ed 06 	lds	r19, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    3492:	28 23       	and	r18, r24
    3494:	39 23       	and	r19, r25
    3496:	30 93 ed 06 	sts	0x06ED, r19	; 0x8006ed <sock_io_mode+0x1>
    349a:	20 93 ec 06 	sts	0x06EC, r18	; 0x8006ec <sock_io_mode>
	//
	sock_is_sending &= ~(1<<sn);
    349e:	20 91 ea 06 	lds	r18, 0x06EA	; 0x8006ea <sock_is_sending>
    34a2:	30 91 eb 06 	lds	r19, 0x06EB	; 0x8006eb <sock_is_sending+0x1>
    34a6:	82 23       	and	r24, r18
    34a8:	93 23       	and	r25, r19
    34aa:	90 93 eb 06 	sts	0x06EB, r25	; 0x8006eb <sock_is_sending+0x1>
    34ae:	80 93 ea 06 	sts	0x06EA, r24	; 0x8006ea <sock_is_sending>
	sock_remained_size[sn] = 0;
    34b2:	f8 01       	movw	r30, r16
    34b4:	ee 0f       	add	r30, r30
    34b6:	ff 1f       	adc	r31, r31
    34b8:	e6 52       	subi	r30, 0x26	; 38
    34ba:	f9 4f       	sbci	r31, 0xF9	; 249
    34bc:	11 82       	std	Z+1, r1	; 0x01
    34be:	10 82       	st	Z, r1
	sock_pack_info[sn] = 0;
    34c0:	f8 01       	movw	r30, r16
    34c2:	ee 52       	subi	r30, 0x2E	; 46
    34c4:	f9 4f       	sbci	r31, 0xF9	; 249
    34c6:	10 82       	st	Z, r1
	while(getSn_SR(sn) != SOCK_CLOSED);
    34c8:	dd 5f       	subi	r29, 0xFD	; 253
    34ca:	6e 01       	movw	r12, r28
    34cc:	dd 0f       	add	r29, r29
    34ce:	ee 08       	sbc	r14, r14
    34d0:	ff 08       	sbc	r15, r15
    34d2:	c7 01       	movw	r24, r14
    34d4:	b6 01       	movw	r22, r12
    34d6:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    34da:	81 11       	cpse	r24, r1
    34dc:	fa cf       	rjmp	.-12     	; 0x34d2 <close+0xc0>
	return SOCK_OK;
    34de:	81 e0       	ldi	r24, 0x01	; 1
    34e0:	01 c0       	rjmp	.+2      	; 0x34e4 <close+0xd2>
   return (int8_t)sn;
}	   

int8_t close(uint8_t sn)
{
	CHECK_SOCKNUM();
    34e2:	8f ef       	ldi	r24, 0xFF	; 255
	sock_is_sending &= ~(1<<sn);
	sock_remained_size[sn] = 0;
	sock_pack_info[sn] = 0;
	while(getSn_SR(sn) != SOCK_CLOSED);
	return SOCK_OK;
}
    34e4:	df 91       	pop	r29
    34e6:	cf 91       	pop	r28
    34e8:	1f 91       	pop	r17
    34ea:	0f 91       	pop	r16
    34ec:	ff 90       	pop	r15
    34ee:	ef 90       	pop	r14
    34f0:	df 90       	pop	r13
    34f2:	cf 90       	pop	r12
    34f4:	bf 90       	pop	r11
    34f6:	af 90       	pop	r10
    34f8:	9f 90       	pop	r9
    34fa:	8f 90       	pop	r8
    34fc:	08 95       	ret

000034fe <socket>:
   }while(0);              \



int8_t socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag)
{
    34fe:	4f 92       	push	r4
    3500:	5f 92       	push	r5
    3502:	6f 92       	push	r6
    3504:	7f 92       	push	r7
    3506:	8f 92       	push	r8
    3508:	9f 92       	push	r9
    350a:	af 92       	push	r10
    350c:	bf 92       	push	r11
    350e:	cf 92       	push	r12
    3510:	df 92       	push	r13
    3512:	ef 92       	push	r14
    3514:	ff 92       	push	r15
    3516:	0f 93       	push	r16
    3518:	1f 93       	push	r17
    351a:	cf 93       	push	r28
    351c:	df 93       	push	r29
    351e:	00 d0       	rcall	.+0      	; 0x3520 <socket+0x22>
    3520:	00 d0       	rcall	.+0      	; 0x3522 <socket+0x24>
    3522:	cd b7       	in	r28, 0x3d	; 61
    3524:	de b7       	in	r29, 0x3e	; 62
    3526:	18 2f       	mov	r17, r24
    3528:	76 2e       	mov	r7, r22
    352a:	4a 01       	movw	r8, r20
    352c:	02 2f       	mov	r16, r18
	CHECK_SOCKNUM();
    352e:	89 30       	cpi	r24, 0x09	; 9
    3530:	08 f0       	brcs	.+2      	; 0x3534 <socket+0x36>
    3532:	c7 c0       	rjmp	.+398    	; 0x36c2 <socket+0x1c4>
	switch(protocol)
    3534:	21 e0       	ldi	r18, 0x01	; 1
    3536:	62 17       	cp	r22, r18
    3538:	39 f0       	breq	.+14     	; 0x3548 <socket+0x4a>
    353a:	62 17       	cp	r22, r18
    353c:	08 f4       	brcc	.+2      	; 0x3540 <socket+0x42>
    353e:	c3 c0       	rjmp	.+390    	; 0x36c6 <socket+0x1c8>
    3540:	34 e0       	ldi	r19, 0x04	; 4
    3542:	36 17       	cp	r19, r22
    3544:	b0 f4       	brcc	.+44     	; 0x3572 <socket+0x74>
    3546:	bf c0       	rjmp	.+382    	; 0x36c6 <socket+0x1c8>
		    /*
            uint8_t taddr[4];
            getSIPR(taddr);
            */
            uint32_t taddr;
            getSIPR((uint8_t*)&taddr);
    3548:	24 e0       	ldi	r18, 0x04	; 4
    354a:	30 e0       	ldi	r19, 0x00	; 0
    354c:	ae 01       	movw	r20, r28
    354e:	4f 5f       	subi	r20, 0xFF	; 255
    3550:	5f 4f       	sbci	r21, 0xFF	; 255
    3552:	60 e0       	ldi	r22, 0x00	; 0
    3554:	7f e0       	ldi	r23, 0x0F	; 15
    3556:	80 e0       	ldi	r24, 0x00	; 0
    3558:	90 e0       	ldi	r25, 0x00	; 0
    355a:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
            if(taddr == 0) return SOCKERR_SOCKINIT;
    355e:	89 81       	ldd	r24, Y+1	; 0x01
    3560:	9a 81       	ldd	r25, Y+2	; 0x02
    3562:	ab 81       	ldd	r26, Y+3	; 0x03
    3564:	bc 81       	ldd	r27, Y+4	; 0x04
    3566:	89 2b       	or	r24, r25
    3568:	8a 2b       	or	r24, r26
    356a:	8b 2b       	or	r24, r27
    356c:	11 f4       	brne	.+4      	; 0x3572 <socket+0x74>
    356e:	8d ef       	ldi	r24, 0xFD	; 253
    3570:	ad c0       	rjmp	.+346    	; 0x36cc <socket+0x1ce>
      default :
         return SOCKERR_SOCKMODE;
	}
	//M20150601 : For SF_TCP_ALIGN & W5300
	//if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
    3572:	02 fd       	sbrc	r16, 2
    3574:	aa c0       	rjmp	.+340    	; 0x36ca <socket+0x1cc>
#if _WIZCHIP_ == 5200
   if(flag & 0x10) return SOCKERR_SOCKFLAG;
#endif
	   
	if(flag != 0)
    3576:	00 23       	and	r16, r16
    3578:	99 f0       	breq	.+38     	; 0x35a0 <socket+0xa2>
	{
   	switch(protocol)
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	78 16       	cp	r7, r24
    357e:	21 f0       	breq	.+8      	; 0x3588 <socket+0x8a>
    3580:	22 e0       	ldi	r18, 0x02	; 2
    3582:	72 16       	cp	r7, r18
    3584:	29 f0       	breq	.+10     	; 0x3590 <socket+0x92>
    3586:	0c c0       	rjmp	.+24     	; 0x35a0 <socket+0xa2>
   	   case Sn_MR_TCP:
   		  //M20150601 :  For SF_TCP_ALIGN & W5300
          #if _WIZCHIP_ == 5300
   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK|SF_TCP_ALIGN))==0) return SOCKERR_SOCKFLAG;
          #else
   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
    3588:	80 2f       	mov	r24, r16
    358a:	81 72       	andi	r24, 0x21	; 33
    358c:	49 f4       	brne	.+18     	; 0x35a0 <socket+0xa2>
    358e:	9d c0       	rjmp	.+314    	; 0x36ca <socket+0x1cc>
          #endif

   	      break;
   	   case Sn_MR_UDP:
   	      if(flag & SF_IGMP_VER2)
    3590:	05 ff       	sbrs	r16, 5
    3592:	02 c0       	rjmp	.+4      	; 0x3598 <socket+0x9a>
   	      {
   	         if((flag & SF_MULTI_ENABLE)==0) return SOCKERR_SOCKFLAG;
    3594:	07 ff       	sbrs	r16, 7
    3596:	99 c0       	rjmp	.+306    	; 0x36ca <socket+0x1cc>
   	      }
   	      #if _WIZCHIP_ == 5500
      	      if(flag & SF_UNI_BLOCK)
    3598:	04 ff       	sbrs	r16, 4
    359a:	02 c0       	rjmp	.+4      	; 0x35a0 <socket+0xa2>
      	      {
      	         if((flag & SF_MULTI_ENABLE) == 0) return SOCKERR_SOCKFLAG;
    359c:	07 ff       	sbrs	r16, 7
    359e:	95 c0       	rjmp	.+298    	; 0x36ca <socket+0x1cc>
   	      break;
   	   default:
   	      break;
   	}
   }
	close(sn);
    35a0:	81 2f       	mov	r24, r17
    35a2:	0e 94 09 1a 	call	0x3412	; 0x3412 <close>
	//M20150601
	#if _WIZCHIP_ == 5300
	   setSn_MR(sn, ((uint16_t)(protocol | (flag & 0xF0))) | (((uint16_t)(flag & 0x02)) << 7) );
    #else
	   setSn_MR(sn, (protocol | (flag & 0xF0)));
    35a6:	a1 2e       	mov	r10, r17
    35a8:	b1 2c       	mov	r11, r1
    35aa:	c5 01       	movw	r24, r10
    35ac:	25 e0       	ldi	r18, 0x05	; 5
    35ae:	88 0f       	add	r24, r24
    35b0:	99 1f       	adc	r25, r25
    35b2:	2a 95       	dec	r18
    35b4:	e1 f7       	brne	.-8      	; 0x35ae <socket+0xb0>
    35b6:	9c 01       	movw	r18, r24
    35b8:	28 5f       	subi	r18, 0xF8	; 248
    35ba:	3f 4f       	sbci	r19, 0xFF	; 255
    35bc:	69 01       	movw	r12, r18
    35be:	40 2f       	mov	r20, r16
    35c0:	40 7f       	andi	r20, 0xF0	; 240
    35c2:	47 29       	or	r20, r7
    35c4:	b9 01       	movw	r22, r18
    35c6:	33 0f       	add	r19, r19
    35c8:	88 0b       	sbc	r24, r24
    35ca:	99 0b       	sbc	r25, r25
    35cc:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    #endif
	if(!port)
    35d0:	81 14       	cp	r8, r1
    35d2:	91 04       	cpc	r9, r1
    35d4:	81 f4       	brne	.+32     	; 0x35f6 <socket+0xf8>
	{
	   port = sock_any_port++;
    35d6:	80 90 02 01 	lds	r8, 0x0102	; 0x800102 <sock_any_port>
    35da:	90 90 03 01 	lds	r9, 0x0103	; 0x800103 <sock_any_port+0x1>
    35de:	c4 01       	movw	r24, r8
    35e0:	01 96       	adiw	r24, 0x01	; 1
	   if(sock_any_port == 0xFFF0) sock_any_port = SOCK_ANY_PORT_NUM;
    35e2:	80 3f       	cpi	r24, 0xF0	; 240
    35e4:	3f ef       	ldi	r19, 0xFF	; 255
    35e6:	93 07       	cpc	r25, r19
    35e8:	11 f4       	brne	.+4      	; 0x35ee <socket+0xf0>
    35ea:	80 e0       	ldi	r24, 0x00	; 0
    35ec:	90 ec       	ldi	r25, 0xC0	; 192
    35ee:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <sock_any_port+0x1>
    35f2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <sock_any_port>
	}
   setSn_PORT(sn,port);	
    35f6:	b6 01       	movw	r22, r12
    35f8:	7c 5f       	subi	r23, 0xFC	; 252
    35fa:	07 2e       	mov	r0, r23
    35fc:	00 0c       	add	r0, r0
    35fe:	88 0b       	sbc	r24, r24
    3600:	99 0b       	sbc	r25, r25
    3602:	49 2d       	mov	r20, r9
    3604:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    3608:	b6 01       	movw	r22, r12
    360a:	7b 5f       	subi	r23, 0xFB	; 251
    360c:	07 2e       	mov	r0, r23
    360e:	00 0c       	add	r0, r0
    3610:	88 0b       	sbc	r24, r24
    3612:	99 0b       	sbc	r25, r25
    3614:	48 2d       	mov	r20, r8
    3616:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   setSn_CR(sn,Sn_CR_OPEN);
    361a:	26 01       	movw	r4, r12
    361c:	53 94       	inc	r5
    361e:	05 2c       	mov	r0, r5
    3620:	00 0c       	add	r0, r0
    3622:	66 08       	sbc	r6, r6
    3624:	77 08       	sbc	r7, r7
    3626:	41 e0       	ldi	r20, 0x01	; 1
    3628:	c3 01       	movw	r24, r6
    362a:	b2 01       	movw	r22, r4
    362c:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   while(getSn_CR(sn));
    3630:	c3 01       	movw	r24, r6
    3632:	b2 01       	movw	r22, r4
    3634:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3638:	81 11       	cpse	r24, r1
    363a:	fa cf       	rjmp	.-12     	; 0x3630 <socket+0x132>
   //A20150401 : For release the previous sock_io_mode
   sock_io_mode &= ~(1 <<sn);
    363c:	81 e0       	ldi	r24, 0x01	; 1
    363e:	90 e0       	ldi	r25, 0x00	; 0
    3640:	01 2e       	mov	r0, r17
    3642:	02 c0       	rjmp	.+4      	; 0x3648 <socket+0x14a>
    3644:	88 0f       	add	r24, r24
    3646:	99 1f       	adc	r25, r25
    3648:	0a 94       	dec	r0
    364a:	e2 f7       	brpl	.-8      	; 0x3644 <socket+0x146>
    364c:	80 95       	com	r24
    364e:	90 95       	com	r25
   //
	sock_io_mode |= ((flag & SF_IO_NONBLOCK) << sn);   
    3650:	20 91 ec 06 	lds	r18, 0x06EC	; 0x8006ec <sock_io_mode>
    3654:	30 91 ed 06 	lds	r19, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    3658:	28 23       	and	r18, r24
    365a:	39 23       	and	r19, r25
    365c:	00 fb       	bst	r16, 0
    365e:	ee 24       	eor	r14, r14
    3660:	e0 f8       	bld	r14, 0
    3662:	f1 2c       	mov	r15, r1
    3664:	01 2e       	mov	r0, r17
    3666:	02 c0       	rjmp	.+4      	; 0x366c <socket+0x16e>
    3668:	ee 0c       	add	r14, r14
    366a:	ff 1c       	adc	r15, r15
    366c:	0a 94       	dec	r0
    366e:	e2 f7       	brpl	.-8      	; 0x3668 <socket+0x16a>
    3670:	e2 2a       	or	r14, r18
    3672:	f3 2a       	or	r15, r19
    3674:	f0 92 ed 06 	sts	0x06ED, r15	; 0x8006ed <sock_io_mode+0x1>
    3678:	e0 92 ec 06 	sts	0x06EC, r14	; 0x8006ec <sock_io_mode>
   sock_is_sending &= ~(1<<sn);
    367c:	20 91 ea 06 	lds	r18, 0x06EA	; 0x8006ea <sock_is_sending>
    3680:	30 91 eb 06 	lds	r19, 0x06EB	; 0x8006eb <sock_is_sending+0x1>
    3684:	82 23       	and	r24, r18
    3686:	93 23       	and	r25, r19
    3688:	90 93 eb 06 	sts	0x06EB, r25	; 0x8006eb <sock_is_sending+0x1>
    368c:	80 93 ea 06 	sts	0x06EA, r24	; 0x8006ea <sock_is_sending>
   sock_remained_size[sn] = 0;
    3690:	f5 01       	movw	r30, r10
    3692:	ee 0f       	add	r30, r30
    3694:	ff 1f       	adc	r31, r31
    3696:	e6 52       	subi	r30, 0x26	; 38
    3698:	f9 4f       	sbci	r31, 0xF9	; 249
    369a:	11 82       	std	Z+1, r1	; 0x01
    369c:	10 82       	st	Z, r1
   //M20150601 : repalce 0 with PACK_COMPLETED
   //sock_pack_info[sn] = 0;
   sock_pack_info[sn] = PACK_COMPLETED;
    369e:	f5 01       	movw	r30, r10
    36a0:	ee 52       	subi	r30, 0x2E	; 46
    36a2:	f9 4f       	sbci	r31, 0xF9	; 249
    36a4:	10 82       	st	Z, r1
   //
   while(getSn_SR(sn) == SOCK_CLOSED);
    36a6:	2d ef       	ldi	r18, 0xFD	; 253
    36a8:	d2 1a       	sub	r13, r18
    36aa:	0d 2c       	mov	r0, r13
    36ac:	00 0c       	add	r0, r0
    36ae:	ee 08       	sbc	r14, r14
    36b0:	ff 08       	sbc	r15, r15
    36b2:	c7 01       	movw	r24, r14
    36b4:	b6 01       	movw	r22, r12
    36b6:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    36ba:	88 23       	and	r24, r24
    36bc:	d1 f3       	breq	.-12     	; 0x36b2 <socket+0x1b4>
   return (int8_t)sn;
    36be:	81 2f       	mov	r24, r17
    36c0:	05 c0       	rjmp	.+10     	; 0x36cc <socket+0x1ce>



int8_t socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag)
{
	CHECK_SOCKNUM();
    36c2:	8f ef       	ldi	r24, 0xFF	; 255
    36c4:	03 c0       	rjmp	.+6      	; 0x36cc <socket+0x1ce>
   #if ( _WIZCHIP_ < 5200 )
      case Sn_MR_PPPoE :
         break;
   #endif
      default :
         return SOCKERR_SOCKMODE;
    36c6:	8b ef       	ldi	r24, 0xFB	; 251
    36c8:	01 c0       	rjmp	.+2      	; 0x36cc <socket+0x1ce>
	}
	//M20150601 : For SF_TCP_ALIGN & W5300
	//if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
    36ca:	8a ef       	ldi	r24, 0xFA	; 250
   //sock_pack_info[sn] = 0;
   sock_pack_info[sn] = PACK_COMPLETED;
   //
   while(getSn_SR(sn) == SOCK_CLOSED);
   return (int8_t)sn;
}	   
    36cc:	0f 90       	pop	r0
    36ce:	0f 90       	pop	r0
    36d0:	0f 90       	pop	r0
    36d2:	0f 90       	pop	r0
    36d4:	df 91       	pop	r29
    36d6:	cf 91       	pop	r28
    36d8:	1f 91       	pop	r17
    36da:	0f 91       	pop	r16
    36dc:	ff 90       	pop	r15
    36de:	ef 90       	pop	r14
    36e0:	df 90       	pop	r13
    36e2:	cf 90       	pop	r12
    36e4:	bf 90       	pop	r11
    36e6:	af 90       	pop	r10
    36e8:	9f 90       	pop	r9
    36ea:	8f 90       	pop	r8
    36ec:	7f 90       	pop	r7
    36ee:	6f 90       	pop	r6
    36f0:	5f 90       	pop	r5
    36f2:	4f 90       	pop	r4
    36f4:	08 95       	ret

000036f6 <listen>:
	while(getSn_SR(sn) != SOCK_CLOSED);
	return SOCK_OK;
}

int8_t listen(uint8_t sn)
{
    36f6:	8f 92       	push	r8
    36f8:	9f 92       	push	r9
    36fa:	af 92       	push	r10
    36fc:	bf 92       	push	r11
    36fe:	cf 92       	push	r12
    3700:	df 92       	push	r13
    3702:	ef 92       	push	r14
    3704:	ff 92       	push	r15
    3706:	cf 93       	push	r28
	CHECK_SOCKNUM();
    3708:	89 30       	cpi	r24, 0x09	; 9
    370a:	08 f0       	brcs	.+2      	; 0x370e <listen+0x18>
    370c:	41 c0       	rjmp	.+130    	; 0x3790 <listen+0x9a>
    370e:	c8 2f       	mov	r28, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    3710:	84 e0       	ldi	r24, 0x04	; 4
    3712:	c8 9f       	mul	r28, r24
    3714:	60 01       	movw	r12, r0
    3716:	11 24       	eor	r1, r1
    3718:	8f ef       	ldi	r24, 0xFF	; 255
    371a:	c8 1a       	sub	r12, r24
    371c:	d8 0a       	sbc	r13, r24
    371e:	83 e0       	ldi	r24, 0x03	; 3
    3720:	cc 0c       	add	r12, r12
    3722:	dd 1c       	adc	r13, r13
    3724:	8a 95       	dec	r24
    3726:	e1 f7       	brne	.-8      	; 0x3720 <listen+0x2a>
    3728:	b6 01       	movw	r22, r12
    372a:	0d 2c       	mov	r0, r13
    372c:	00 0c       	add	r0, r0
    372e:	88 0b       	sbc	r24, r24
    3730:	99 0b       	sbc	r25, r25
    3732:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3736:	8f 70       	andi	r24, 0x0F	; 15
    3738:	81 30       	cpi	r24, 0x01	; 1
    373a:	61 f5       	brne	.+88     	; 0x3794 <listen+0x9e>
	CHECK_SOCKINIT();
    373c:	46 01       	movw	r8, r12
    373e:	8d ef       	ldi	r24, 0xFD	; 253
    3740:	98 1a       	sub	r9, r24
    3742:	09 2c       	mov	r0, r9
    3744:	00 0c       	add	r0, r0
    3746:	aa 08       	sbc	r10, r10
    3748:	bb 08       	sbc	r11, r11
    374a:	c5 01       	movw	r24, r10
    374c:	b4 01       	movw	r22, r8
    374e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3752:	83 31       	cpi	r24, 0x13	; 19
    3754:	09 f5       	brne	.+66     	; 0x3798 <listen+0xa2>
	setSn_CR(sn,Sn_CR_LISTEN);
    3756:	d3 94       	inc	r13
    3758:	0d 2c       	mov	r0, r13
    375a:	00 0c       	add	r0, r0
    375c:	ee 08       	sbc	r14, r14
    375e:	ff 08       	sbc	r15, r15
    3760:	42 e0       	ldi	r20, 0x02	; 2
    3762:	c7 01       	movw	r24, r14
    3764:	b6 01       	movw	r22, r12
    3766:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
	while(getSn_CR(sn));
    376a:	c7 01       	movw	r24, r14
    376c:	b6 01       	movw	r22, r12
    376e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3772:	81 11       	cpse	r24, r1
    3774:	fa cf       	rjmp	.-12     	; 0x376a <listen+0x74>
   while(getSn_SR(sn) != SOCK_LISTEN)
    3776:	c5 01       	movw	r24, r10
    3778:	b4 01       	movw	r22, r8
    377a:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    377e:	84 31       	cpi	r24, 0x14	; 20
    3780:	29 f0       	breq	.+10     	; 0x378c <listen+0x96>
   {
         close(sn);
    3782:	8c 2f       	mov	r24, r28
    3784:	0e 94 09 1a 	call	0x3412	; 0x3412 <close>
         return SOCKERR_SOCKCLOSED;
    3788:	8c ef       	ldi	r24, 0xFC	; 252
    378a:	07 c0       	rjmp	.+14     	; 0x379a <listen+0xa4>
   }
   return SOCK_OK;
    378c:	81 e0       	ldi	r24, 0x01	; 1
    378e:	05 c0       	rjmp	.+10     	; 0x379a <listen+0xa4>
	return SOCK_OK;
}

int8_t listen(uint8_t sn)
{
	CHECK_SOCKNUM();
    3790:	8f ef       	ldi	r24, 0xFF	; 255
    3792:	03 c0       	rjmp	.+6      	; 0x379a <listen+0xa4>
   CHECK_SOCKMODE(Sn_MR_TCP);
    3794:	8b ef       	ldi	r24, 0xFB	; 251
    3796:	01 c0       	rjmp	.+2      	; 0x379a <listen+0xa4>
	CHECK_SOCKINIT();
    3798:	8d ef       	ldi	r24, 0xFD	; 253
   {
         close(sn);
         return SOCKERR_SOCKCLOSED;
   }
   return SOCK_OK;
}
    379a:	cf 91       	pop	r28
    379c:	ff 90       	pop	r15
    379e:	ef 90       	pop	r14
    37a0:	df 90       	pop	r13
    37a2:	cf 90       	pop	r12
    37a4:	bf 90       	pop	r11
    37a6:	af 90       	pop	r10
    37a8:	9f 90       	pop	r9
    37aa:	8f 90       	pop	r8
    37ac:	08 95       	ret

000037ae <connect>:


int8_t connect(uint8_t sn, uint8_t * addr, uint16_t port)
{
    37ae:	7f 92       	push	r7
    37b0:	8f 92       	push	r8
    37b2:	9f 92       	push	r9
    37b4:	af 92       	push	r10
    37b6:	bf 92       	push	r11
    37b8:	cf 92       	push	r12
    37ba:	df 92       	push	r13
    37bc:	ef 92       	push	r14
    37be:	ff 92       	push	r15
    37c0:	0f 93       	push	r16
    37c2:	1f 93       	push	r17
    37c4:	cf 93       	push	r28
    37c6:	df 93       	push	r29
   CHECK_SOCKNUM();
    37c8:	89 30       	cpi	r24, 0x09	; 9
    37ca:	08 f0       	brcs	.+2      	; 0x37ce <connect+0x20>
    37cc:	b5 c0       	rjmp	.+362    	; 0x3938 <connect+0x18a>
    37ce:	6a 01       	movw	r12, r20
    37d0:	7b 01       	movw	r14, r22
    37d2:	78 2e       	mov	r7, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    37d4:	84 e0       	ldi	r24, 0x04	; 4
    37d6:	78 9e       	mul	r7, r24
    37d8:	e0 01       	movw	r28, r0
    37da:	11 24       	eor	r1, r1
    37dc:	21 96       	adiw	r28, 0x01	; 1
    37de:	53 e0       	ldi	r21, 0x03	; 3
    37e0:	cc 0f       	add	r28, r28
    37e2:	dd 1f       	adc	r29, r29
    37e4:	5a 95       	dec	r21
    37e6:	e1 f7       	brne	.-8      	; 0x37e0 <connect+0x32>
    37e8:	be 01       	movw	r22, r28
    37ea:	0d 2e       	mov	r0, r29
    37ec:	00 0c       	add	r0, r0
    37ee:	88 0b       	sbc	r24, r24
    37f0:	99 0b       	sbc	r25, r25
    37f2:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    37f6:	8f 70       	andi	r24, 0x0F	; 15
    37f8:	81 30       	cpi	r24, 0x01	; 1
    37fa:	09 f0       	breq	.+2      	; 0x37fe <connect+0x50>
    37fc:	9f c0       	rjmp	.+318    	; 0x393c <connect+0x18e>
   CHECK_SOCKINIT();
    37fe:	4e 01       	movw	r8, r28
    3800:	ed ef       	ldi	r30, 0xFD	; 253
    3802:	9e 1a       	sub	r9, r30
    3804:	09 2c       	mov	r0, r9
    3806:	00 0c       	add	r0, r0
    3808:	aa 08       	sbc	r10, r10
    380a:	bb 08       	sbc	r11, r11
    380c:	c5 01       	movw	r24, r10
    380e:	b4 01       	movw	r22, r8
    3810:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3814:	83 31       	cpi	r24, 0x13	; 19
    3816:	09 f0       	breq	.+2      	; 0x381a <connect+0x6c>
    3818:	93 c0       	rjmp	.+294    	; 0x3940 <connect+0x192>
   //M20140501 : For avoiding fatal error on memory align mismatched
   //if( *((uint32_t*)addr) == 0xFFFFFFFF || *((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   {
      uint32_t taddr;
      taddr = ((uint32_t)addr[0] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
    381a:	f7 01       	movw	r30, r14
    381c:	00 81       	ld	r16, Z
    381e:	10 e0       	ldi	r17, 0x00	; 0
    3820:	20 e0       	ldi	r18, 0x00	; 0
    3822:	30 e0       	ldi	r19, 0x00	; 0
    3824:	32 2f       	mov	r19, r18
    3826:	21 2f       	mov	r18, r17
    3828:	10 2f       	mov	r17, r16
    382a:	00 27       	eor	r16, r16
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
    382c:	81 81       	ldd	r24, Z+1	; 0x01
    382e:	08 0f       	add	r16, r24
    3830:	11 1d       	adc	r17, r1
    3832:	21 1d       	adc	r18, r1
    3834:	31 1d       	adc	r19, r1
    3836:	32 2f       	mov	r19, r18
    3838:	21 2f       	mov	r18, r17
    383a:	10 2f       	mov	r17, r16
    383c:	00 27       	eor	r16, r16
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
      if( taddr == 0xFFFFFFFF || taddr == 0) return SOCKERR_IPINVALID;
    383e:	82 81       	ldd	r24, Z+2	; 0x02
    3840:	08 0f       	add	r16, r24
    3842:	11 1d       	adc	r17, r1
    3844:	21 1d       	adc	r18, r1
    3846:	31 1d       	adc	r19, r1
    3848:	32 2f       	mov	r19, r18
    384a:	21 2f       	mov	r18, r17
    384c:	10 2f       	mov	r17, r16
    384e:	00 27       	eor	r16, r16
    3850:	83 81       	ldd	r24, Z+3	; 0x03
    3852:	90 e0       	ldi	r25, 0x00	; 0
    3854:	a0 e0       	ldi	r26, 0x00	; 0
    3856:	b0 e0       	ldi	r27, 0x00	; 0
    3858:	01 97       	sbiw	r24, 0x01	; 1
    385a:	a1 09       	sbc	r26, r1
    385c:	b1 09       	sbc	r27, r1
    385e:	08 0f       	add	r16, r24
    3860:	19 1f       	adc	r17, r25
    3862:	2a 1f       	adc	r18, r26
    3864:	3b 1f       	adc	r19, r27
    3866:	0e 3f       	cpi	r16, 0xFE	; 254
    3868:	1f 4f       	sbci	r17, 0xFF	; 255
    386a:	2f 4f       	sbci	r18, 0xFF	; 255
    386c:	3f 4f       	sbci	r19, 0xFF	; 255
    386e:	08 f0       	brcs	.+2      	; 0x3872 <connect+0xc4>
    3870:	69 c0       	rjmp	.+210    	; 0x3944 <connect+0x196>
   }
   //
	
	if(port == 0) return SOCKERR_PORTZERO;
    3872:	c1 14       	cp	r12, r1
    3874:	d1 04       	cpc	r13, r1
    3876:	09 f4       	brne	.+2      	; 0x387a <connect+0xcc>
    3878:	67 c0       	rjmp	.+206    	; 0x3948 <connect+0x19a>
	setSn_DIPR(sn,addr);
    387a:	be 01       	movw	r22, r28
    387c:	74 5f       	subi	r23, 0xF4	; 244
    387e:	07 2e       	mov	r0, r23
    3880:	00 0c       	add	r0, r0
    3882:	88 0b       	sbc	r24, r24
    3884:	99 0b       	sbc	r25, r25
    3886:	24 e0       	ldi	r18, 0x04	; 4
    3888:	30 e0       	ldi	r19, 0x00	; 0
    388a:	a7 01       	movw	r20, r14
    388c:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
	setSn_DPORT(sn,port);
    3890:	be 01       	movw	r22, r28
    3892:	70 5f       	subi	r23, 0xF0	; 240
    3894:	07 2e       	mov	r0, r23
    3896:	00 0c       	add	r0, r0
    3898:	88 0b       	sbc	r24, r24
    389a:	99 0b       	sbc	r25, r25
    389c:	4d 2d       	mov	r20, r13
    389e:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    38a2:	be 01       	movw	r22, r28
    38a4:	7f 5e       	subi	r23, 0xEF	; 239
    38a6:	07 2e       	mov	r0, r23
    38a8:	00 0c       	add	r0, r0
    38aa:	88 0b       	sbc	r24, r24
    38ac:	99 0b       	sbc	r25, r25
    38ae:	4c 2d       	mov	r20, r12
    38b0:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
	setSn_CR(sn,Sn_CR_CONNECT);
    38b4:	6e 01       	movw	r12, r28
    38b6:	d3 94       	inc	r13
    38b8:	0d 2c       	mov	r0, r13
    38ba:	00 0c       	add	r0, r0
    38bc:	ee 08       	sbc	r14, r14
    38be:	ff 08       	sbc	r15, r15
    38c0:	44 e0       	ldi	r20, 0x04	; 4
    38c2:	c7 01       	movw	r24, r14
    38c4:	b6 01       	movw	r22, r12
    38c6:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   while(getSn_CR(sn));
    38ca:	c7 01       	movw	r24, r14
    38cc:	b6 01       	movw	r22, r12
    38ce:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    38d2:	81 11       	cpse	r24, r1
    38d4:	fa cf       	rjmp	.-12     	; 0x38ca <connect+0x11c>
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    38d6:	81 e0       	ldi	r24, 0x01	; 1
    38d8:	90 e0       	ldi	r25, 0x00	; 0
    38da:	02 c0       	rjmp	.+4      	; 0x38e0 <connect+0x132>
    38dc:	88 0f       	add	r24, r24
    38de:	99 1f       	adc	r25, r25
    38e0:	7a 94       	dec	r7
    38e2:	e2 f7       	brpl	.-8      	; 0x38dc <connect+0x12e>
    38e4:	20 91 ec 06 	lds	r18, 0x06EC	; 0x8006ec <sock_io_mode>
    38e8:	30 91 ed 06 	lds	r19, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    38ec:	82 23       	and	r24, r18
    38ee:	93 23       	and	r25, r19
    38f0:	89 2b       	or	r24, r25
    38f2:	61 f5       	brne	.+88     	; 0x394c <connect+0x19e>
   while(getSn_SR(sn) != SOCK_ESTABLISHED)
   {
		if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    38f4:	de 5f       	subi	r29, 0xFE	; 254
    38f6:	6e 01       	movw	r12, r28
    38f8:	dd 0f       	add	r29, r29
    38fa:	ee 08       	sbc	r14, r14
    38fc:	ff 08       	sbc	r15, r15
	setSn_DIPR(sn,addr);
	setSn_DPORT(sn,port);
	setSn_CR(sn,Sn_CR_CONNECT);
   while(getSn_CR(sn));
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
   while(getSn_SR(sn) != SOCK_ESTABLISHED)
    38fe:	c5 01       	movw	r24, r10
    3900:	b4 01       	movw	r22, r8
    3902:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3906:	87 31       	cpi	r24, 0x17	; 23
    3908:	a9 f0       	breq	.+42     	; 0x3934 <connect+0x186>
   {
		if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    390a:	c7 01       	movw	r24, r14
    390c:	b6 01       	movw	r22, r12
    390e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3912:	83 ff       	sbrs	r24, 3
    3914:	07 c0       	rjmp	.+14     	; 0x3924 <connect+0x176>
		{
			setSn_IR(sn, Sn_IR_TIMEOUT);
    3916:	48 e0       	ldi	r20, 0x08	; 8
    3918:	c7 01       	movw	r24, r14
    391a:	b6 01       	movw	r22, r12
    391c:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
            return SOCKERR_TIMEOUT;
    3920:	83 ef       	ldi	r24, 0xF3	; 243
    3922:	15 c0       	rjmp	.+42     	; 0x394e <connect+0x1a0>
		}

		if (getSn_SR(sn) == SOCK_CLOSED)
    3924:	c5 01       	movw	r24, r10
    3926:	b4 01       	movw	r22, r8
    3928:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    392c:	81 11       	cpse	r24, r1
    392e:	e7 cf       	rjmp	.-50     	; 0x38fe <connect+0x150>
		{
			return SOCKERR_SOCKCLOSED;
    3930:	8c ef       	ldi	r24, 0xFC	; 252
    3932:	0d c0       	rjmp	.+26     	; 0x394e <connect+0x1a0>
		}
	}
   
   return SOCK_OK;
    3934:	81 e0       	ldi	r24, 0x01	; 1
    3936:	0b c0       	rjmp	.+22     	; 0x394e <connect+0x1a0>
}


int8_t connect(uint8_t sn, uint8_t * addr, uint16_t port)
{
   CHECK_SOCKNUM();
    3938:	8f ef       	ldi	r24, 0xFF	; 255
    393a:	09 c0       	rjmp	.+18     	; 0x394e <connect+0x1a0>
   CHECK_SOCKMODE(Sn_MR_TCP);
    393c:	8b ef       	ldi	r24, 0xFB	; 251
    393e:	07 c0       	rjmp	.+14     	; 0x394e <connect+0x1a0>
   CHECK_SOCKINIT();
    3940:	8d ef       	ldi	r24, 0xFD	; 253
    3942:	05 c0       	rjmp	.+10     	; 0x394e <connect+0x1a0>
      uint32_t taddr;
      taddr = ((uint32_t)addr[0] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
      if( taddr == 0xFFFFFFFF || taddr == 0) return SOCKERR_IPINVALID;
    3944:	84 ef       	ldi	r24, 0xF4	; 244
    3946:	03 c0       	rjmp	.+6      	; 0x394e <connect+0x1a0>
   }
   //
	
	if(port == 0) return SOCKERR_PORTZERO;
    3948:	85 ef       	ldi	r24, 0xF5	; 245
    394a:	01 c0       	rjmp	.+2      	; 0x394e <connect+0x1a0>
	setSn_DIPR(sn,addr);
	setSn_DPORT(sn,port);
	setSn_CR(sn,Sn_CR_CONNECT);
   while(getSn_CR(sn));
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    394c:	80 e0       	ldi	r24, 0x00	; 0
			return SOCKERR_SOCKCLOSED;
		}
	}
   
   return SOCK_OK;
}
    394e:	df 91       	pop	r29
    3950:	cf 91       	pop	r28
    3952:	1f 91       	pop	r17
    3954:	0f 91       	pop	r16
    3956:	ff 90       	pop	r15
    3958:	ef 90       	pop	r14
    395a:	df 90       	pop	r13
    395c:	cf 90       	pop	r12
    395e:	bf 90       	pop	r11
    3960:	af 90       	pop	r10
    3962:	9f 90       	pop	r9
    3964:	8f 90       	pop	r8
    3966:	7f 90       	pop	r7
    3968:	08 95       	ret

0000396a <disconnect>:

int8_t disconnect(uint8_t sn)
{
    396a:	8f 92       	push	r8
    396c:	9f 92       	push	r9
    396e:	af 92       	push	r10
    3970:	bf 92       	push	r11
    3972:	cf 92       	push	r12
    3974:	df 92       	push	r13
    3976:	ef 92       	push	r14
    3978:	ff 92       	push	r15
    397a:	cf 93       	push	r28
   CHECK_SOCKNUM();
    397c:	89 30       	cpi	r24, 0x09	; 9
    397e:	08 f0       	brcs	.+2      	; 0x3982 <disconnect+0x18>
    3980:	66 c0       	rjmp	.+204    	; 0x3a4e <disconnect+0xe4>
    3982:	c8 2f       	mov	r28, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    3984:	84 e0       	ldi	r24, 0x04	; 4
    3986:	c8 9f       	mul	r28, r24
    3988:	60 01       	movw	r12, r0
    398a:	11 24       	eor	r1, r1
    398c:	8f ef       	ldi	r24, 0xFF	; 255
    398e:	c8 1a       	sub	r12, r24
    3990:	d8 0a       	sbc	r13, r24
    3992:	83 e0       	ldi	r24, 0x03	; 3
    3994:	cc 0c       	add	r12, r12
    3996:	dd 1c       	adc	r13, r13
    3998:	8a 95       	dec	r24
    399a:	e1 f7       	brne	.-8      	; 0x3994 <disconnect+0x2a>
    399c:	b6 01       	movw	r22, r12
    399e:	0d 2c       	mov	r0, r13
    39a0:	00 0c       	add	r0, r0
    39a2:	88 0b       	sbc	r24, r24
    39a4:	99 0b       	sbc	r25, r25
    39a6:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    39aa:	8f 70       	andi	r24, 0x0F	; 15
    39ac:	81 30       	cpi	r24, 0x01	; 1
    39ae:	09 f0       	breq	.+2      	; 0x39b2 <disconnect+0x48>
    39b0:	50 c0       	rjmp	.+160    	; 0x3a52 <disconnect+0xe8>
	setSn_CR(sn,Sn_CR_DISCON);
    39b2:	46 01       	movw	r8, r12
    39b4:	93 94       	inc	r9
    39b6:	09 2c       	mov	r0, r9
    39b8:	00 0c       	add	r0, r0
    39ba:	aa 08       	sbc	r10, r10
    39bc:	bb 08       	sbc	r11, r11
    39be:	48 e0       	ldi	r20, 0x08	; 8
    39c0:	c5 01       	movw	r24, r10
    39c2:	b4 01       	movw	r22, r8
    39c4:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
	/* wait to process the command... */
	while(getSn_CR(sn));
    39c8:	c5 01       	movw	r24, r10
    39ca:	b4 01       	movw	r22, r8
    39cc:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    39d0:	81 11       	cpse	r24, r1
    39d2:	fa cf       	rjmp	.-12     	; 0x39c8 <disconnect+0x5e>
	sock_is_sending &= ~(1<<sn);
    39d4:	81 e0       	ldi	r24, 0x01	; 1
    39d6:	90 e0       	ldi	r25, 0x00	; 0
    39d8:	0c 2e       	mov	r0, r28
    39da:	02 c0       	rjmp	.+4      	; 0x39e0 <disconnect+0x76>
    39dc:	88 0f       	add	r24, r24
    39de:	99 1f       	adc	r25, r25
    39e0:	0a 94       	dec	r0
    39e2:	e2 f7       	brpl	.-8      	; 0x39dc <disconnect+0x72>
    39e4:	9c 01       	movw	r18, r24
    39e6:	20 95       	com	r18
    39e8:	30 95       	com	r19
    39ea:	40 91 ea 06 	lds	r20, 0x06EA	; 0x8006ea <sock_is_sending>
    39ee:	50 91 eb 06 	lds	r21, 0x06EB	; 0x8006eb <sock_is_sending+0x1>
    39f2:	24 23       	and	r18, r20
    39f4:	35 23       	and	r19, r21
    39f6:	30 93 eb 06 	sts	0x06EB, r19	; 0x8006eb <sock_is_sending+0x1>
    39fa:	20 93 ea 06 	sts	0x06EA, r18	; 0x8006ea <sock_is_sending>
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    39fe:	20 91 ec 06 	lds	r18, 0x06EC	; 0x8006ec <sock_io_mode>
    3a02:	30 91 ed 06 	lds	r19, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    3a06:	82 23       	and	r24, r18
    3a08:	93 23       	and	r25, r19
    3a0a:	89 2b       	or	r24, r25
    3a0c:	21 f5       	brne	.+72     	; 0x3a56 <disconnect+0xec>
	while(getSn_SR(sn) != SOCK_CLOSED)
    3a0e:	46 01       	movw	r8, r12
    3a10:	8d ef       	ldi	r24, 0xFD	; 253
    3a12:	98 1a       	sub	r9, r24
    3a14:	09 2c       	mov	r0, r9
    3a16:	00 0c       	add	r0, r0
    3a18:	aa 08       	sbc	r10, r10
    3a1a:	bb 08       	sbc	r11, r11
	{
	   if(getSn_IR(sn) & Sn_IR_TIMEOUT)
    3a1c:	8e ef       	ldi	r24, 0xFE	; 254
    3a1e:	d8 1a       	sub	r13, r24
    3a20:	0d 2c       	mov	r0, r13
    3a22:	00 0c       	add	r0, r0
    3a24:	ee 08       	sbc	r14, r14
    3a26:	ff 08       	sbc	r15, r15
	setSn_CR(sn,Sn_CR_DISCON);
	/* wait to process the command... */
	while(getSn_CR(sn));
	sock_is_sending &= ~(1<<sn);
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
	while(getSn_SR(sn) != SOCK_CLOSED)
    3a28:	c5 01       	movw	r24, r10
    3a2a:	b4 01       	movw	r22, r8
    3a2c:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3a30:	88 23       	and	r24, r24
    3a32:	59 f0       	breq	.+22     	; 0x3a4a <disconnect+0xe0>
	{
	   if(getSn_IR(sn) & Sn_IR_TIMEOUT)
    3a34:	c7 01       	movw	r24, r14
    3a36:	b6 01       	movw	r22, r12
    3a38:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3a3c:	83 ff       	sbrs	r24, 3
    3a3e:	f4 cf       	rjmp	.-24     	; 0x3a28 <disconnect+0xbe>
	   {
	      close(sn);
    3a40:	8c 2f       	mov	r24, r28
    3a42:	0e 94 09 1a 	call	0x3412	; 0x3412 <close>
	      return SOCKERR_TIMEOUT;
    3a46:	83 ef       	ldi	r24, 0xF3	; 243
    3a48:	07 c0       	rjmp	.+14     	; 0x3a58 <disconnect+0xee>
	   }
	}
	return SOCK_OK;
    3a4a:	81 e0       	ldi	r24, 0x01	; 1
    3a4c:	05 c0       	rjmp	.+10     	; 0x3a58 <disconnect+0xee>
   return SOCK_OK;
}

int8_t disconnect(uint8_t sn)
{
   CHECK_SOCKNUM();
    3a4e:	8f ef       	ldi	r24, 0xFF	; 255
    3a50:	03 c0       	rjmp	.+6      	; 0x3a58 <disconnect+0xee>
   CHECK_SOCKMODE(Sn_MR_TCP);
    3a52:	8b ef       	ldi	r24, 0xFB	; 251
    3a54:	01 c0       	rjmp	.+2      	; 0x3a58 <disconnect+0xee>
	setSn_CR(sn,Sn_CR_DISCON);
	/* wait to process the command... */
	while(getSn_CR(sn));
	sock_is_sending &= ~(1<<sn);
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    3a56:	80 e0       	ldi	r24, 0x00	; 0
	      close(sn);
	      return SOCKERR_TIMEOUT;
	   }
	}
	return SOCK_OK;
}
    3a58:	cf 91       	pop	r28
    3a5a:	ff 90       	pop	r15
    3a5c:	ef 90       	pop	r14
    3a5e:	df 90       	pop	r13
    3a60:	cf 90       	pop	r12
    3a62:	bf 90       	pop	r11
    3a64:	af 90       	pop	r10
    3a66:	9f 90       	pop	r9
    3a68:	8f 90       	pop	r8
    3a6a:	08 95       	ret

00003a6c <send>:

int32_t send(uint8_t sn, uint8_t * buf, uint16_t len)
{
    3a6c:	2f 92       	push	r2
    3a6e:	3f 92       	push	r3
    3a70:	4f 92       	push	r4
    3a72:	5f 92       	push	r5
    3a74:	7f 92       	push	r7
    3a76:	8f 92       	push	r8
    3a78:	9f 92       	push	r9
    3a7a:	af 92       	push	r10
    3a7c:	bf 92       	push	r11
    3a7e:	cf 92       	push	r12
    3a80:	df 92       	push	r13
    3a82:	ef 92       	push	r14
    3a84:	ff 92       	push	r15
    3a86:	0f 93       	push	r16
    3a88:	1f 93       	push	r17
    3a8a:	cf 93       	push	r28
    3a8c:	df 93       	push	r29
    3a8e:	00 d0       	rcall	.+0      	; 0x3a90 <send+0x24>
    3a90:	00 d0       	rcall	.+0      	; 0x3a92 <send+0x26>
    3a92:	cd b7       	in	r28, 0x3d	; 61
    3a94:	de b7       	in	r29, 0x3e	; 62
   uint8_t tmp=0;
   uint16_t freesize=0;
   
   CHECK_SOCKNUM();
    3a96:	89 30       	cpi	r24, 0x09	; 9
    3a98:	08 f0       	brcs	.+2      	; 0x3a9c <send+0x30>
    3a9a:	ce c0       	rjmp	.+412    	; 0x3c38 <send+0x1cc>
    3a9c:	5c 83       	std	Y+4, r21	; 0x04
    3a9e:	4b 83       	std	Y+3, r20	; 0x03
    3aa0:	7a 83       	std	Y+2, r23	; 0x02
    3aa2:	69 83       	std	Y+1, r22	; 0x01
    3aa4:	78 2e       	mov	r7, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    3aa6:	24 e0       	ldi	r18, 0x04	; 4
    3aa8:	82 9f       	mul	r24, r18
    3aaa:	80 01       	movw	r16, r0
    3aac:	11 24       	eor	r1, r1
    3aae:	0f 5f       	subi	r16, 0xFF	; 255
    3ab0:	1f 4f       	sbci	r17, 0xFF	; 255
    3ab2:	33 e0       	ldi	r19, 0x03	; 3
    3ab4:	00 0f       	add	r16, r16
    3ab6:	11 1f       	adc	r17, r17
    3ab8:	3a 95       	dec	r19
    3aba:	e1 f7       	brne	.-8      	; 0x3ab4 <send+0x48>
    3abc:	b8 01       	movw	r22, r16
    3abe:	01 2e       	mov	r0, r17
    3ac0:	00 0c       	add	r0, r0
    3ac2:	88 0b       	sbc	r24, r24
    3ac4:	99 0b       	sbc	r25, r25
    3ac6:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3aca:	8f 70       	andi	r24, 0x0F	; 15
    3acc:	81 30       	cpi	r24, 0x01	; 1
    3ace:	09 f0       	breq	.+2      	; 0x3ad2 <send+0x66>
    3ad0:	b7 c0       	rjmp	.+366    	; 0x3c40 <send+0x1d4>
   CHECK_SOCKDATA();
    3ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad6:	89 2b       	or	r24, r25
    3ad8:	09 f4       	brne	.+2      	; 0x3adc <send+0x70>
    3ada:	b7 c0       	rjmp	.+366    	; 0x3c4a <send+0x1de>
   tmp = getSn_SR(sn);
    3adc:	48 01       	movw	r8, r16
    3ade:	9d ef       	ldi	r25, 0xFD	; 253
    3ae0:	99 1a       	sub	r9, r25
    3ae2:	09 2c       	mov	r0, r9
    3ae4:	00 0c       	add	r0, r0
    3ae6:	aa 08       	sbc	r10, r10
    3ae8:	bb 08       	sbc	r11, r11
    3aea:	c5 01       	movw	r24, r10
    3aec:	b4 01       	movw	r22, r8
    3aee:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   if(tmp != SOCK_ESTABLISHED && tmp != SOCK_CLOSE_WAIT) return SOCKERR_SOCKSTATUS;
    3af2:	87 31       	cpi	r24, 0x17	; 23
    3af4:	19 f0       	breq	.+6      	; 0x3afc <send+0x90>
    3af6:	8c 31       	cpi	r24, 0x1C	; 28
    3af8:	09 f0       	breq	.+2      	; 0x3afc <send+0x90>
    3afa:	ac c0       	rjmp	.+344    	; 0x3c54 <send+0x1e8>
   if( sock_is_sending & (1<<sn) )
    3afc:	81 e0       	ldi	r24, 0x01	; 1
    3afe:	90 e0       	ldi	r25, 0x00	; 0
    3b00:	7c 01       	movw	r14, r24
    3b02:	07 2c       	mov	r0, r7
    3b04:	02 c0       	rjmp	.+4      	; 0x3b0a <send+0x9e>
    3b06:	ee 0c       	add	r14, r14
    3b08:	ff 1c       	adc	r15, r15
    3b0a:	0a 94       	dec	r0
    3b0c:	e2 f7       	brpl	.-8      	; 0x3b06 <send+0x9a>
    3b0e:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <sock_is_sending>
    3b12:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <sock_is_sending+0x1>
    3b16:	8e 21       	and	r24, r14
    3b18:	9f 21       	and	r25, r15
    3b1a:	89 2b       	or	r24, r25
    3b1c:	71 f1       	breq	.+92     	; 0x3b7a <send+0x10e>
   {
      tmp = getSn_IR(sn);
    3b1e:	18 01       	movw	r2, r16
    3b20:	2e ef       	ldi	r18, 0xFE	; 254
    3b22:	32 1a       	sub	r3, r18
    3b24:	03 2c       	mov	r0, r3
    3b26:	00 0c       	add	r0, r0
    3b28:	44 08       	sbc	r4, r4
    3b2a:	55 08       	sbc	r5, r5
    3b2c:	c2 01       	movw	r24, r4
    3b2e:	b1 01       	movw	r22, r2
    3b30:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
      if(tmp & Sn_IR_SENDOK)
    3b34:	84 ff       	sbrs	r24, 4
    3b36:	13 c0       	rjmp	.+38     	; 0x3b5e <send+0xf2>
      {
         setSn_IR(sn, Sn_IR_SENDOK);
    3b38:	40 e1       	ldi	r20, 0x10	; 16
    3b3a:	c2 01       	movw	r24, r4
    3b3c:	b1 01       	movw	r22, r2
    3b3e:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
               setSn_CR(sn,Sn_CR_SEND);
               while(getSn_CR(sn));
               return SOCK_BUSY;
            }
         #endif
         sock_is_sending &= ~(1<<sn);         
    3b42:	20 91 ea 06 	lds	r18, 0x06EA	; 0x8006ea <sock_is_sending>
    3b46:	30 91 eb 06 	lds	r19, 0x06EB	; 0x8006eb <sock_is_sending+0x1>
    3b4a:	c7 01       	movw	r24, r14
    3b4c:	80 95       	com	r24
    3b4e:	90 95       	com	r25
    3b50:	82 23       	and	r24, r18
    3b52:	93 23       	and	r25, r19
    3b54:	90 93 eb 06 	sts	0x06EB, r25	; 0x8006eb <sock_is_sending+0x1>
    3b58:	80 93 ea 06 	sts	0x06EA, r24	; 0x8006ea <sock_is_sending>
    3b5c:	0e c0       	rjmp	.+28     	; 0x3b7a <send+0x10e>
      }
      else if(tmp & Sn_IR_TIMEOUT)
    3b5e:	83 fd       	sbrc	r24, 3
    3b60:	04 c0       	rjmp	.+8      	; 0x3b6a <send+0xfe>
      {
         close(sn);
         return SOCKERR_TIMEOUT;
      }
      else return SOCK_BUSY;
    3b62:	60 e0       	ldi	r22, 0x00	; 0
    3b64:	70 e0       	ldi	r23, 0x00	; 0
    3b66:	cb 01       	movw	r24, r22
    3b68:	79 c0       	rjmp	.+242    	; 0x3c5c <send+0x1f0>
         #endif
         sock_is_sending &= ~(1<<sn);         
      }
      else if(tmp & Sn_IR_TIMEOUT)
      {
         close(sn);
    3b6a:	87 2d       	mov	r24, r7
    3b6c:	0e 94 09 1a 	call	0x3412	; 0x3412 <close>
         return SOCKERR_TIMEOUT;
    3b70:	63 ef       	ldi	r22, 0xF3	; 243
    3b72:	7f ef       	ldi	r23, 0xFF	; 255
    3b74:	8f ef       	ldi	r24, 0xFF	; 255
    3b76:	9f ef       	ldi	r25, 0xFF	; 255
    3b78:	71 c0       	rjmp	.+226    	; 0x3c5c <send+0x1f0>
      }
      else return SOCK_BUSY;
   }
   freesize = getSn_TxMAX(sn);
    3b7a:	b8 01       	movw	r22, r16
    3b7c:	71 5e       	subi	r23, 0xE1	; 225
    3b7e:	07 2e       	mov	r0, r23
    3b80:	00 0c       	add	r0, r0
    3b82:	88 0b       	sbc	r24, r24
    3b84:	99 0b       	sbc	r25, r25
    3b86:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3b8a:	90 e0       	ldi	r25, 0x00	; 0
    3b8c:	98 2f       	mov	r25, r24
    3b8e:	88 27       	eor	r24, r24
    3b90:	99 0f       	add	r25, r25
    3b92:	99 0f       	add	r25, r25
    3b94:	2b 81       	ldd	r18, Y+3	; 0x03
    3b96:	3c 81       	ldd	r19, Y+4	; 0x04
    3b98:	82 17       	cp	r24, r18
    3b9a:	93 07       	cpc	r25, r19
    3b9c:	10 f4       	brcc	.+4      	; 0x3ba2 <send+0x136>
    3b9e:	9c 83       	std	Y+4, r25	; 0x04
    3ba0:	8b 83       	std	Y+3, r24	; 0x03
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
    3ba2:	87 2d       	mov	r24, r7
    3ba4:	0e 94 5e 2a 	call	0x54bc	; 0x54bc <getSn_TX_FSR>
    3ba8:	6c 01       	movw	r12, r24
      tmp = getSn_SR(sn);
    3baa:	c5 01       	movw	r24, r10
    3bac:	b4 01       	movw	r22, r8
    3bae:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
      if ((tmp != SOCK_ESTABLISHED) && (tmp != SOCK_CLOSE_WAIT))
    3bb2:	87 31       	cpi	r24, 0x17	; 23
    3bb4:	31 f0       	breq	.+12     	; 0x3bc2 <send+0x156>
    3bb6:	8c 31       	cpi	r24, 0x1C	; 28
    3bb8:	21 f0       	breq	.+8      	; 0x3bc2 <send+0x156>
      {
         close(sn);
    3bba:	87 2d       	mov	r24, r7
    3bbc:	0e 94 09 1a 	call	0x3412	; 0x3412 <close>
    3bc0:	49 c0       	rjmp	.+146    	; 0x3c54 <send+0x1e8>
         return SOCKERR_SOCKSTATUS;
      }
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    3bc2:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <sock_io_mode>
    3bc6:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    3bca:	8e 21       	and	r24, r14
    3bcc:	9f 21       	and	r25, r15
    3bce:	89 2b       	or	r24, r25
    3bd0:	31 f0       	breq	.+12     	; 0x3bde <send+0x172>
    3bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    3bd6:	c8 16       	cp	r12, r24
    3bd8:	d9 06       	cpc	r13, r25
    3bda:	30 f4       	brcc	.+12     	; 0x3be8 <send+0x17c>
    3bdc:	c2 cf       	rjmp	.-124    	; 0x3b62 <send+0xf6>
      if(len <= freesize) break;
    3bde:	2b 81       	ldd	r18, Y+3	; 0x03
    3be0:	3c 81       	ldd	r19, Y+4	; 0x04
    3be2:	c2 16       	cp	r12, r18
    3be4:	d3 06       	cpc	r13, r19
    3be6:	e8 f2       	brcs	.-70     	; 0x3ba2 <send+0x136>
   }
   wiz_send_data(sn, buf, len);
    3be8:	4b 81       	ldd	r20, Y+3	; 0x03
    3bea:	5c 81       	ldd	r21, Y+4	; 0x04
    3bec:	69 81       	ldd	r22, Y+1	; 0x01
    3bee:	7a 81       	ldd	r23, Y+2	; 0x02
    3bf0:	87 2d       	mov	r24, r7
    3bf2:	0e 94 0e 2b 	call	0x561c	; 0x561c <wiz_send_data>

   #if _WIZCHIP_ == 5300
      setSn_TX_WRSR(sn,len);
   #endif
   
   setSn_CR(sn,Sn_CR_SEND);
    3bf6:	48 01       	movw	r8, r16
    3bf8:	93 94       	inc	r9
    3bfa:	09 2c       	mov	r0, r9
    3bfc:	00 0c       	add	r0, r0
    3bfe:	aa 08       	sbc	r10, r10
    3c00:	bb 08       	sbc	r11, r11
    3c02:	40 e2       	ldi	r20, 0x20	; 32
    3c04:	c5 01       	movw	r24, r10
    3c06:	b4 01       	movw	r22, r8
    3c08:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   /* wait to process the command... */
   while(getSn_CR(sn));
    3c0c:	c5 01       	movw	r24, r10
    3c0e:	b4 01       	movw	r22, r8
    3c10:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3c14:	81 11       	cpse	r24, r1
    3c16:	fa cf       	rjmp	.-12     	; 0x3c0c <send+0x1a0>
   sock_is_sending |= (1 << sn);
    3c18:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <sock_is_sending>
    3c1c:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <sock_is_sending+0x1>
    3c20:	e8 2a       	or	r14, r24
    3c22:	f9 2a       	or	r15, r25
    3c24:	f0 92 eb 06 	sts	0x06EB, r15	; 0x8006eb <sock_is_sending+0x1>
    3c28:	e0 92 ea 06 	sts	0x06EA, r14	; 0x8006ea <sock_is_sending>
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    3c2c:	2b 81       	ldd	r18, Y+3	; 0x03
    3c2e:	3c 81       	ldd	r19, Y+4	; 0x04
    3c30:	b9 01       	movw	r22, r18
    3c32:	80 e0       	ldi	r24, 0x00	; 0
    3c34:	90 e0       	ldi	r25, 0x00	; 0
    3c36:	12 c0       	rjmp	.+36     	; 0x3c5c <send+0x1f0>
int32_t send(uint8_t sn, uint8_t * buf, uint16_t len)
{
   uint8_t tmp=0;
   uint16_t freesize=0;
   
   CHECK_SOCKNUM();
    3c38:	6f ef       	ldi	r22, 0xFF	; 255
    3c3a:	7f ef       	ldi	r23, 0xFF	; 255
    3c3c:	cb 01       	movw	r24, r22
    3c3e:	0e c0       	rjmp	.+28     	; 0x3c5c <send+0x1f0>
   CHECK_SOCKMODE(Sn_MR_TCP);
    3c40:	6b ef       	ldi	r22, 0xFB	; 251
    3c42:	7f ef       	ldi	r23, 0xFF	; 255
    3c44:	8f ef       	ldi	r24, 0xFF	; 255
    3c46:	9f ef       	ldi	r25, 0xFF	; 255
    3c48:	09 c0       	rjmp	.+18     	; 0x3c5c <send+0x1f0>
   CHECK_SOCKDATA();
    3c4a:	62 ef       	ldi	r22, 0xF2	; 242
    3c4c:	7f ef       	ldi	r23, 0xFF	; 255
    3c4e:	8f ef       	ldi	r24, 0xFF	; 255
    3c50:	9f ef       	ldi	r25, 0xFF	; 255
    3c52:	04 c0       	rjmp	.+8      	; 0x3c5c <send+0x1f0>
   tmp = getSn_SR(sn);
   if(tmp != SOCK_ESTABLISHED && tmp != SOCK_CLOSE_WAIT) return SOCKERR_SOCKSTATUS;
    3c54:	69 ef       	ldi	r22, 0xF9	; 249
    3c56:	7f ef       	ldi	r23, 0xFF	; 255
    3c58:	8f ef       	ldi	r24, 0xFF	; 255
    3c5a:	9f ef       	ldi	r25, 0xFF	; 255
   while(getSn_CR(sn));
   sock_is_sending |= (1 << sn);
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
}
    3c5c:	0f 90       	pop	r0
    3c5e:	0f 90       	pop	r0
    3c60:	0f 90       	pop	r0
    3c62:	0f 90       	pop	r0
    3c64:	df 91       	pop	r29
    3c66:	cf 91       	pop	r28
    3c68:	1f 91       	pop	r17
    3c6a:	0f 91       	pop	r16
    3c6c:	ff 90       	pop	r15
    3c6e:	ef 90       	pop	r14
    3c70:	df 90       	pop	r13
    3c72:	cf 90       	pop	r12
    3c74:	bf 90       	pop	r11
    3c76:	af 90       	pop	r10
    3c78:	9f 90       	pop	r9
    3c7a:	8f 90       	pop	r8
    3c7c:	7f 90       	pop	r7
    3c7e:	5f 90       	pop	r5
    3c80:	4f 90       	pop	r4
    3c82:	3f 90       	pop	r3
    3c84:	2f 90       	pop	r2
    3c86:	08 95       	ret

00003c88 <recv>:


int32_t recv(uint8_t sn, uint8_t * buf, uint16_t len)
{
    3c88:	2f 92       	push	r2
    3c8a:	3f 92       	push	r3
    3c8c:	4f 92       	push	r4
    3c8e:	5f 92       	push	r5
    3c90:	6f 92       	push	r6
    3c92:	7f 92       	push	r7
    3c94:	8f 92       	push	r8
    3c96:	9f 92       	push	r9
    3c98:	af 92       	push	r10
    3c9a:	bf 92       	push	r11
    3c9c:	cf 92       	push	r12
    3c9e:	df 92       	push	r13
    3ca0:	ef 92       	push	r14
    3ca2:	ff 92       	push	r15
    3ca4:	0f 93       	push	r16
    3ca6:	1f 93       	push	r17
    3ca8:	cf 93       	push	r28
    3caa:	df 93       	push	r29
    3cac:	00 d0       	rcall	.+0      	; 0x3cae <recv+0x26>
    3cae:	00 d0       	rcall	.+0      	; 0x3cb0 <recv+0x28>
    3cb0:	00 d0       	rcall	.+0      	; 0x3cb2 <recv+0x2a>
    3cb2:	cd b7       	in	r28, 0x3d	; 61
    3cb4:	de b7       	in	r29, 0x3e	; 62
#if   _WIZCHIP_ == 5300
   uint8_t head[2];
   uint16_t mr;
#endif
//
   CHECK_SOCKNUM();
    3cb6:	89 30       	cpi	r24, 0x09	; 9
    3cb8:	08 f0       	brcs	.+2      	; 0x3cbc <recv+0x34>
    3cba:	b5 c0       	rjmp	.+362    	; 0x3e26 <recv+0x19e>
    3cbc:	2a 01       	movw	r4, r20
    3cbe:	7c 83       	std	Y+4, r23	; 0x04
    3cc0:	6b 83       	std	Y+3, r22	; 0x03
    3cc2:	38 2e       	mov	r3, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    3cc4:	24 e0       	ldi	r18, 0x04	; 4
    3cc6:	82 9f       	mul	r24, r18
    3cc8:	80 01       	movw	r16, r0
    3cca:	11 24       	eor	r1, r1
    3ccc:	0f 5f       	subi	r16, 0xFF	; 255
    3cce:	1f 4f       	sbci	r17, 0xFF	; 255
    3cd0:	43 e0       	ldi	r20, 0x03	; 3
    3cd2:	00 0f       	add	r16, r16
    3cd4:	11 1f       	adc	r17, r17
    3cd6:	4a 95       	dec	r20
    3cd8:	e1 f7       	brne	.-8      	; 0x3cd2 <recv+0x4a>
    3cda:	b8 01       	movw	r22, r16
    3cdc:	01 2e       	mov	r0, r17
    3cde:	00 0c       	add	r0, r0
    3ce0:	88 0b       	sbc	r24, r24
    3ce2:	99 0b       	sbc	r25, r25
    3ce4:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3ce8:	8f 70       	andi	r24, 0x0F	; 15
    3cea:	81 30       	cpi	r24, 0x01	; 1
    3cec:	09 f0       	breq	.+2      	; 0x3cf0 <recv+0x68>
    3cee:	9f c0       	rjmp	.+318    	; 0x3e2e <recv+0x1a6>
   CHECK_SOCKDATA();
    3cf0:	41 14       	cp	r4, r1
    3cf2:	51 04       	cpc	r5, r1
    3cf4:	09 f4       	brne	.+2      	; 0x3cf8 <recv+0x70>
    3cf6:	a0 c0       	rjmp	.+320    	; 0x3e38 <recv+0x1b0>
   
   recvsize = getSn_RxMAX(sn);
    3cf8:	b8 01       	movw	r22, r16
    3cfa:	72 5e       	subi	r23, 0xE2	; 226
    3cfc:	07 2e       	mov	r0, r23
    3cfe:	00 0c       	add	r0, r0
    3d00:	88 0b       	sbc	r24, r24
    3d02:	99 0b       	sbc	r25, r25
    3d04:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3d08:	28 2e       	mov	r2, r24
            {
               close(sn);
               return SOCKERR_SOCKSTATUS;
            }
         }
         if((sock_io_mode & (1<<sn)) && (recvsize == 0)) return SOCK_BUSY;
    3d0a:	81 e0       	ldi	r24, 0x01	; 1
    3d0c:	90 e0       	ldi	r25, 0x00	; 0
    3d0e:	9c 01       	movw	r18, r24
    3d10:	03 2c       	mov	r0, r3
    3d12:	02 c0       	rjmp	.+4      	; 0x3d18 <recv+0x90>
    3d14:	22 0f       	add	r18, r18
    3d16:	33 1f       	adc	r19, r19
    3d18:	0a 94       	dec	r0
    3d1a:	e2 f7       	brpl	.-8      	; 0x3d14 <recv+0x8c>
    3d1c:	3a 83       	std	Y+2, r19	; 0x02
    3d1e:	29 83       	std	Y+1, r18	; 0x01
#endif
//
      while(1)
      {
         recvsize = getSn_RX_RSR(sn);
         tmp = getSn_SR(sn);
    3d20:	68 01       	movw	r12, r16
    3d22:	3d ef       	ldi	r19, 0xFD	; 253
    3d24:	d3 1a       	sub	r13, r19
    3d26:	0d 2c       	mov	r0, r13
    3d28:	00 0c       	add	r0, r0
    3d2a:	ee 08       	sbc	r14, r14
    3d2c:	ff 08       	sbc	r15, r15
         if (tmp != SOCK_ESTABLISHED)
         {
            if(tmp == SOCK_CLOSE_WAIT)
            {
               if(recvsize != 0) break;
               else if(getSn_TX_FSR(sn) == getSn_TxMAX(sn))
    3d2e:	48 01       	movw	r8, r16
    3d30:	81 ee       	ldi	r24, 0xE1	; 225
    3d32:	98 1a       	sub	r9, r24
    3d34:	09 2c       	mov	r0, r9
    3d36:	00 0c       	add	r0, r0
    3d38:	aa 08       	sbc	r10, r10
    3d3a:	bb 08       	sbc	r11, r11
   {
#endif
//
      while(1)
      {
         recvsize = getSn_RX_RSR(sn);
    3d3c:	83 2d       	mov	r24, r3
    3d3e:	0e 94 b6 2a 	call	0x556c	; 0x556c <getSn_RX_RSR>
    3d42:	9e 83       	std	Y+6, r25	; 0x06
    3d44:	8d 83       	std	Y+5, r24	; 0x05
         tmp = getSn_SR(sn);
    3d46:	c7 01       	movw	r24, r14
    3d48:	b6 01       	movw	r22, r12
    3d4a:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
         if (tmp != SOCK_ESTABLISHED)
    3d4e:	87 31       	cpi	r24, 0x17	; 23
    3d50:	09 f4       	brne	.+2      	; 0x3d54 <recv+0xcc>
    3d52:	44 c0       	rjmp	.+136    	; 0x3ddc <recv+0x154>
         {
            if(tmp == SOCK_CLOSE_WAIT)
    3d54:	8c 31       	cpi	r24, 0x1C	; 28
    3d56:	d1 f5       	brne	.+116    	; 0x3dcc <recv+0x144>
            {
               if(recvsize != 0) break;
    3d58:	2d 81       	ldd	r18, Y+5	; 0x05
    3d5a:	3e 81       	ldd	r19, Y+6	; 0x06
    3d5c:	23 2b       	or	r18, r19
    3d5e:	31 f1       	breq	.+76     	; 0x3dac <recv+0x124>
//
   CHECK_SOCKNUM();
   CHECK_SOCKMODE(Sn_MR_TCP);
   CHECK_SOCKDATA();
   
   recvsize = getSn_RxMAX(sn);
    3d60:	82 2d       	mov	r24, r2
    3d62:	90 e0       	ldi	r25, 0x00	; 0
    3d64:	98 2f       	mov	r25, r24
    3d66:	88 27       	eor	r24, r24
    3d68:	99 0f       	add	r25, r25
    3d6a:	99 0f       	add	r25, r25
    3d6c:	84 15       	cp	r24, r4
    3d6e:	95 05       	cpc	r25, r5
    3d70:	08 f4       	brcc	.+2      	; 0x3d74 <recv+0xec>
    3d72:	2c 01       	movw	r4, r24
    3d74:	8d 81       	ldd	r24, Y+5	; 0x05
    3d76:	9e 81       	ldd	r25, Y+6	; 0x06
    3d78:	9a 83       	std	Y+2, r25	; 0x02
    3d7a:	89 83       	std	Y+1, r24	; 0x01
    3d7c:	48 16       	cp	r4, r24
    3d7e:	59 06       	cpc	r5, r25
    3d80:	10 f4       	brcc	.+4      	; 0x3d86 <recv+0xfe>
    3d82:	5a 82       	std	Y+2, r5	; 0x02
    3d84:	49 82       	std	Y+1, r4	; 0x01
   else sock_pack_info[sn] = PACK_COMPLETED;
   if(getSn_MR(sn) & Sn_MR_ALIGN) sock_remained_size[sn] = 0;
   //len = recvsize;
#else   
   if(recvsize < len) len = recvsize;   
   wiz_recv_data(sn, buf, len);
    3d86:	49 81       	ldd	r20, Y+1	; 0x01
    3d88:	5a 81       	ldd	r21, Y+2	; 0x02
    3d8a:	6b 81       	ldd	r22, Y+3	; 0x03
    3d8c:	7c 81       	ldd	r23, Y+4	; 0x04
    3d8e:	83 2d       	mov	r24, r3
    3d90:	0e 94 9e 2b 	call	0x573c	; 0x573c <wiz_recv_data>
   setSn_CR(sn,Sn_CR_RECV);
    3d94:	68 01       	movw	r12, r16
    3d96:	d3 94       	inc	r13
    3d98:	0d 2c       	mov	r0, r13
    3d9a:	00 0c       	add	r0, r0
    3d9c:	ee 08       	sbc	r14, r14
    3d9e:	ff 08       	sbc	r15, r15
    3da0:	40 e4       	ldi	r20, 0x40	; 64
    3da2:	c7 01       	movw	r24, r14
    3da4:	b6 01       	movw	r22, r12
    3da6:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   while(getSn_CR(sn));
    3daa:	31 c0       	rjmp	.+98     	; 0x3e0e <recv+0x186>
         if (tmp != SOCK_ESTABLISHED)
         {
            if(tmp == SOCK_CLOSE_WAIT)
            {
               if(recvsize != 0) break;
               else if(getSn_TX_FSR(sn) == getSn_TxMAX(sn))
    3dac:	83 2d       	mov	r24, r3
    3dae:	0e 94 5e 2a 	call	0x54bc	; 0x54bc <getSn_TX_FSR>
    3db2:	3c 01       	movw	r6, r24
    3db4:	c5 01       	movw	r24, r10
    3db6:	b4 01       	movw	r22, r8
    3db8:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3dbc:	90 e0       	ldi	r25, 0x00	; 0
    3dbe:	98 2f       	mov	r25, r24
    3dc0:	88 27       	eor	r24, r24
    3dc2:	99 0f       	add	r25, r25
    3dc4:	99 0f       	add	r25, r25
    3dc6:	68 16       	cp	r6, r24
    3dc8:	79 06       	cpc	r7, r25
    3dca:	41 f4       	brne	.+16     	; 0x3ddc <recv+0x154>
               {
                  close(sn);
    3dcc:	83 2d       	mov	r24, r3
    3dce:	0e 94 09 1a 	call	0x3412	; 0x3412 <close>
                  return SOCKERR_SOCKSTATUS;
    3dd2:	69 ef       	ldi	r22, 0xF9	; 249
    3dd4:	7f ef       	ldi	r23, 0xFF	; 255
    3dd6:	8f ef       	ldi	r24, 0xFF	; 255
    3dd8:	9f ef       	ldi	r25, 0xFF	; 255
    3dda:	32 c0       	rjmp	.+100    	; 0x3e40 <recv+0x1b8>
            {
               close(sn);
               return SOCKERR_SOCKSTATUS;
            }
         }
         if((sock_io_mode & (1<<sn)) && (recvsize == 0)) return SOCK_BUSY;
    3ddc:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <sock_io_mode>
    3de0:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    3de4:	29 81       	ldd	r18, Y+1	; 0x01
    3de6:	3a 81       	ldd	r19, Y+2	; 0x02
    3de8:	82 23       	and	r24, r18
    3dea:	93 23       	and	r25, r19
    3dec:	89 2b       	or	r24, r25
    3dee:	49 f0       	breq	.+18     	; 0x3e02 <recv+0x17a>
    3df0:	8d 81       	ldd	r24, Y+5	; 0x05
    3df2:	9e 81       	ldd	r25, Y+6	; 0x06
    3df4:	89 2b       	or	r24, r25
    3df6:	09 f0       	breq	.+2      	; 0x3dfa <recv+0x172>
    3df8:	b3 cf       	rjmp	.-154    	; 0x3d60 <recv+0xd8>
    3dfa:	60 e0       	ldi	r22, 0x00	; 0
    3dfc:	70 e0       	ldi	r23, 0x00	; 0
    3dfe:	cb 01       	movw	r24, r22
    3e00:	1f c0       	rjmp	.+62     	; 0x3e40 <recv+0x1b8>
         if(recvsize != 0) break;
    3e02:	2d 81       	ldd	r18, Y+5	; 0x05
    3e04:	3e 81       	ldd	r19, Y+6	; 0x06
    3e06:	23 2b       	or	r18, r19
    3e08:	09 f4       	brne	.+2      	; 0x3e0c <recv+0x184>
    3e0a:	98 cf       	rjmp	.-208    	; 0x3d3c <recv+0xb4>
    3e0c:	a9 cf       	rjmp	.-174    	; 0x3d60 <recv+0xd8>
   //len = recvsize;
#else   
   if(recvsize < len) len = recvsize;   
   wiz_recv_data(sn, buf, len);
   setSn_CR(sn,Sn_CR_RECV);
   while(getSn_CR(sn));
    3e0e:	c7 01       	movw	r24, r14
    3e10:	b6 01       	movw	r22, r12
    3e12:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3e16:	81 11       	cpse	r24, r1
    3e18:	fa cf       	rjmp	.-12     	; 0x3e0e <recv+0x186>
#endif
     
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    3e1a:	29 81       	ldd	r18, Y+1	; 0x01
    3e1c:	3a 81       	ldd	r19, Y+2	; 0x02
    3e1e:	b9 01       	movw	r22, r18
    3e20:	80 e0       	ldi	r24, 0x00	; 0
    3e22:	90 e0       	ldi	r25, 0x00	; 0
    3e24:	0d c0       	rjmp	.+26     	; 0x3e40 <recv+0x1b8>
#if   _WIZCHIP_ == 5300
   uint8_t head[2];
   uint16_t mr;
#endif
//
   CHECK_SOCKNUM();
    3e26:	6f ef       	ldi	r22, 0xFF	; 255
    3e28:	7f ef       	ldi	r23, 0xFF	; 255
    3e2a:	cb 01       	movw	r24, r22
    3e2c:	09 c0       	rjmp	.+18     	; 0x3e40 <recv+0x1b8>
   CHECK_SOCKMODE(Sn_MR_TCP);
    3e2e:	6b ef       	ldi	r22, 0xFB	; 251
    3e30:	7f ef       	ldi	r23, 0xFF	; 255
    3e32:	8f ef       	ldi	r24, 0xFF	; 255
    3e34:	9f ef       	ldi	r25, 0xFF	; 255
    3e36:	04 c0       	rjmp	.+8      	; 0x3e40 <recv+0x1b8>
   CHECK_SOCKDATA();
    3e38:	62 ef       	ldi	r22, 0xF2	; 242
    3e3a:	7f ef       	ldi	r23, 0xFF	; 255
    3e3c:	8f ef       	ldi	r24, 0xFF	; 255
    3e3e:	9f ef       	ldi	r25, 0xFF	; 255
#endif
     
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
}
    3e40:	26 96       	adiw	r28, 0x06	; 6
    3e42:	0f b6       	in	r0, 0x3f	; 63
    3e44:	f8 94       	cli
    3e46:	de bf       	out	0x3e, r29	; 62
    3e48:	0f be       	out	0x3f, r0	; 63
    3e4a:	cd bf       	out	0x3d, r28	; 61
    3e4c:	df 91       	pop	r29
    3e4e:	cf 91       	pop	r28
    3e50:	1f 91       	pop	r17
    3e52:	0f 91       	pop	r16
    3e54:	ff 90       	pop	r15
    3e56:	ef 90       	pop	r14
    3e58:	df 90       	pop	r13
    3e5a:	cf 90       	pop	r12
    3e5c:	bf 90       	pop	r11
    3e5e:	af 90       	pop	r10
    3e60:	9f 90       	pop	r9
    3e62:	8f 90       	pop	r8
    3e64:	7f 90       	pop	r7
    3e66:	6f 90       	pop	r6
    3e68:	5f 90       	pop	r5
    3e6a:	4f 90       	pop	r4
    3e6c:	3f 90       	pop	r3
    3e6e:	2f 90       	pop	r2
    3e70:	08 95       	ret

00003e72 <sendto>:

int32_t sendto(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port)
{
    3e72:	4f 92       	push	r4
    3e74:	5f 92       	push	r5
    3e76:	6f 92       	push	r6
    3e78:	7f 92       	push	r7
    3e7a:	8f 92       	push	r8
    3e7c:	9f 92       	push	r9
    3e7e:	af 92       	push	r10
    3e80:	bf 92       	push	r11
    3e82:	cf 92       	push	r12
    3e84:	df 92       	push	r13
    3e86:	ff 92       	push	r15
    3e88:	0f 93       	push	r16
    3e8a:	1f 93       	push	r17
    3e8c:	cf 93       	push	r28
    3e8e:	df 93       	push	r29
   uint8_t tmp = 0;
   uint16_t freesize = 0;
   uint32_t taddr;

   CHECK_SOCKNUM();
    3e90:	89 30       	cpi	r24, 0x09	; 9
    3e92:	08 f0       	brcs	.+2      	; 0x3e96 <sendto+0x24>
    3e94:	f8 c0       	rjmp	.+496    	; 0x4086 <sendto+0x214>
    3e96:	58 01       	movw	r10, r16
    3e98:	69 01       	movw	r12, r18
    3e9a:	8a 01       	movw	r16, r20
    3e9c:	4b 01       	movw	r8, r22
    3e9e:	f8 2e       	mov	r15, r24
   switch(getSn_MR(sn) & 0x0F)
    3ea0:	84 e0       	ldi	r24, 0x04	; 4
    3ea2:	f8 9e       	mul	r15, r24
    3ea4:	e0 01       	movw	r28, r0
    3ea6:	11 24       	eor	r1, r1
    3ea8:	21 96       	adiw	r28, 0x01	; 1
    3eaa:	63 e0       	ldi	r22, 0x03	; 3
    3eac:	cc 0f       	add	r28, r28
    3eae:	dd 1f       	adc	r29, r29
    3eb0:	6a 95       	dec	r22
    3eb2:	e1 f7       	brne	.-8      	; 0x3eac <sendto+0x3a>
    3eb4:	2e 01       	movw	r4, r28
    3eb6:	0d 2e       	mov	r0, r29
    3eb8:	00 0c       	add	r0, r0
    3eba:	66 08       	sbc	r6, r6
    3ebc:	77 08       	sbc	r7, r7
    3ebe:	c3 01       	movw	r24, r6
    3ec0:	b2 01       	movw	r22, r4
    3ec2:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3ec6:	8f 70       	andi	r24, 0x0F	; 15
    3ec8:	82 50       	subi	r24, 0x02	; 2
    3eca:	83 30       	cpi	r24, 0x03	; 3
    3ecc:	08 f0       	brcs	.+2      	; 0x3ed0 <sendto+0x5e>
    3ece:	df c0       	rjmp	.+446    	; 0x408e <sendto+0x21c>
         break;
//   #endif
      default:
         return SOCKERR_SOCKMODE;
   }
   CHECK_SOCKDATA();
    3ed0:	01 15       	cp	r16, r1
    3ed2:	11 05       	cpc	r17, r1
    3ed4:	09 f4       	brne	.+2      	; 0x3ed8 <sendto+0x66>
    3ed6:	e0 c0       	rjmp	.+448    	; 0x4098 <sendto+0x226>
   //M20140501 : For avoiding fatal error on memory align mismatched
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   //{
      //uint32_t taddr;
      taddr = ((uint32_t)addr[0]) & 0x000000FF;
      taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
    3ed8:	f6 01       	movw	r30, r12
    3eda:	80 81       	ld	r24, Z
    3edc:	90 e0       	ldi	r25, 0x00	; 0
    3ede:	a0 e0       	ldi	r26, 0x00	; 0
    3ee0:	b0 e0       	ldi	r27, 0x00	; 0
    3ee2:	ba 2f       	mov	r27, r26
    3ee4:	a9 2f       	mov	r26, r25
    3ee6:	98 2f       	mov	r25, r24
    3ee8:	88 27       	eor	r24, r24
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
    3eea:	21 81       	ldd	r18, Z+1	; 0x01
    3eec:	82 0f       	add	r24, r18
    3eee:	91 1d       	adc	r25, r1
    3ef0:	a1 1d       	adc	r26, r1
    3ef2:	b1 1d       	adc	r27, r1
    3ef4:	ba 2f       	mov	r27, r26
    3ef6:	a9 2f       	mov	r26, r25
    3ef8:	98 2f       	mov	r25, r24
    3efa:	88 27       	eor	r24, r24
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
    3efc:	22 81       	ldd	r18, Z+2	; 0x02
    3efe:	82 0f       	add	r24, r18
    3f00:	91 1d       	adc	r25, r1
    3f02:	a1 1d       	adc	r26, r1
    3f04:	b1 1d       	adc	r27, r1
    3f06:	ba 2f       	mov	r27, r26
    3f08:	a9 2f       	mov	r26, r25
    3f0a:	98 2f       	mov	r25, r24
    3f0c:	88 27       	eor	r24, r24
   //}
   //
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
    3f0e:	23 81       	ldd	r18, Z+3	; 0x03
    3f10:	82 0f       	add	r24, r18
    3f12:	91 1d       	adc	r25, r1
    3f14:	a1 1d       	adc	r26, r1
    3f16:	b1 1d       	adc	r27, r1
    3f18:	89 2b       	or	r24, r25
    3f1a:	8a 2b       	or	r24, r26
    3f1c:	8b 2b       	or	r24, r27
    3f1e:	21 f0       	breq	.+8      	; 0x3f28 <sendto+0xb6>
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    3f20:	a1 14       	cp	r10, r1
    3f22:	b1 04       	cpc	r11, r1
    3f24:	d1 f0       	breq	.+52     	; 0x3f5a <sendto+0xe8>
    3f26:	0b c0       	rjmp	.+22     	; 0x3f3e <sendto+0xcc>
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
   //}
   //
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
    3f28:	c3 01       	movw	r24, r6
    3f2a:	b2 01       	movw	r22, r4
    3f2c:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3f30:	82 fd       	sbrc	r24, 2
    3f32:	f6 cf       	rjmp	.-20     	; 0x3f20 <sendto+0xae>
    3f34:	64 ef       	ldi	r22, 0xF4	; 244
    3f36:	7f ef       	ldi	r23, 0xFF	; 255
    3f38:	8f ef       	ldi	r24, 0xFF	; 255
    3f3a:	9f ef       	ldi	r25, 0xFF	; 255
    3f3c:	bf c0       	rjmp	.+382    	; 0x40bc <sendto+0x24a>
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
   tmp = getSn_SR(sn);
    3f3e:	2e 01       	movw	r4, r28
    3f40:	fd ef       	ldi	r31, 0xFD	; 253
    3f42:	5f 1a       	sub	r5, r31
    3f44:	05 2c       	mov	r0, r5
    3f46:	00 0c       	add	r0, r0
    3f48:	66 08       	sbc	r6, r6
    3f4a:	77 08       	sbc	r7, r7
    3f4c:	c3 01       	movw	r24, r6
    3f4e:	b2 01       	movw	r22, r4
    3f50:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
//#if ( _WIZCHIP_ < 5200 )
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    3f54:	82 34       	cpi	r24, 0x42	; 66
    3f56:	61 f4       	brne	.+24     	; 0x3f70 <sendto+0xfe>
    3f58:	0f c0       	rjmp	.+30     	; 0x3f78 <sendto+0x106>
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
   //}
   //
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    3f5a:	c3 01       	movw	r24, r6
    3f5c:	b2 01       	movw	r22, r4
    3f5e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3f62:	82 fd       	sbrc	r24, 2
    3f64:	ec cf       	rjmp	.-40     	; 0x3f3e <sendto+0xcc>
    3f66:	65 ef       	ldi	r22, 0xF5	; 245
    3f68:	7f ef       	ldi	r23, 0xFF	; 255
    3f6a:	8f ef       	ldi	r24, 0xFF	; 255
    3f6c:	9f ef       	ldi	r25, 0xFF	; 255
    3f6e:	a6 c0       	rjmp	.+332    	; 0x40bc <sendto+0x24a>
   tmp = getSn_SR(sn);
//#if ( _WIZCHIP_ < 5200 )
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    3f70:	8f 7e       	andi	r24, 0xEF	; 239
    3f72:	82 32       	cpi	r24, 0x22	; 34
    3f74:	09 f0       	breq	.+2      	; 0x3f78 <sendto+0x106>
    3f76:	95 c0       	rjmp	.+298    	; 0x40a2 <sendto+0x230>
//#else
//   if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
//#endif
      
   setSn_DIPR(sn,addr);
    3f78:	be 01       	movw	r22, r28
    3f7a:	74 5f       	subi	r23, 0xF4	; 244
    3f7c:	07 2e       	mov	r0, r23
    3f7e:	00 0c       	add	r0, r0
    3f80:	88 0b       	sbc	r24, r24
    3f82:	99 0b       	sbc	r25, r25
    3f84:	24 e0       	ldi	r18, 0x04	; 4
    3f86:	30 e0       	ldi	r19, 0x00	; 0
    3f88:	a6 01       	movw	r20, r12
    3f8a:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   setSn_DPORT(sn,port);      
    3f8e:	be 01       	movw	r22, r28
    3f90:	70 5f       	subi	r23, 0xF0	; 240
    3f92:	07 2e       	mov	r0, r23
    3f94:	00 0c       	add	r0, r0
    3f96:	88 0b       	sbc	r24, r24
    3f98:	99 0b       	sbc	r25, r25
    3f9a:	4b 2d       	mov	r20, r11
    3f9c:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    3fa0:	be 01       	movw	r22, r28
    3fa2:	7f 5e       	subi	r23, 0xEF	; 239
    3fa4:	07 2e       	mov	r0, r23
    3fa6:	00 0c       	add	r0, r0
    3fa8:	88 0b       	sbc	r24, r24
    3faa:	99 0b       	sbc	r25, r25
    3fac:	4a 2d       	mov	r20, r10
    3fae:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   freesize = getSn_TxMAX(sn);
    3fb2:	be 01       	movw	r22, r28
    3fb4:	71 5e       	subi	r23, 0xE1	; 225
    3fb6:	07 2e       	mov	r0, r23
    3fb8:	00 0c       	add	r0, r0
    3fba:	88 0b       	sbc	r24, r24
    3fbc:	99 0b       	sbc	r25, r25
    3fbe:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3fc2:	90 e0       	ldi	r25, 0x00	; 0
    3fc4:	98 2f       	mov	r25, r24
    3fc6:	88 27       	eor	r24, r24
    3fc8:	99 0f       	add	r25, r25
    3fca:	99 0f       	add	r25, r25
    3fcc:	80 17       	cp	r24, r16
    3fce:	91 07       	cpc	r25, r17
    3fd0:	08 f4       	brcc	.+2      	; 0x3fd4 <sendto+0x162>
    3fd2:	8c 01       	movw	r16, r24
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    3fd4:	81 e0       	ldi	r24, 0x01	; 1
    3fd6:	90 e0       	ldi	r25, 0x00	; 0
    3fd8:	5c 01       	movw	r10, r24
    3fda:	0f 2c       	mov	r0, r15
    3fdc:	02 c0       	rjmp	.+4      	; 0x3fe2 <sendto+0x170>
    3fde:	aa 0c       	add	r10, r10
    3fe0:	bb 1c       	adc	r11, r11
    3fe2:	0a 94       	dec	r0
    3fe4:	e2 f7       	brpl	.-8      	; 0x3fde <sendto+0x16c>
   setSn_DPORT(sn,port);      
   freesize = getSn_TxMAX(sn);
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
    3fe6:	8f 2d       	mov	r24, r15
    3fe8:	0e 94 5e 2a 	call	0x54bc	; 0x54bc <getSn_TX_FSR>
    3fec:	6c 01       	movw	r12, r24
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    3fee:	c3 01       	movw	r24, r6
    3ff0:	b2 01       	movw	r22, r4
    3ff2:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    3ff6:	88 23       	and	r24, r24
    3ff8:	09 f4       	brne	.+2      	; 0x3ffc <sendto+0x18a>
    3ffa:	58 c0       	rjmp	.+176    	; 0x40ac <sendto+0x23a>
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    3ffc:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <sock_io_mode>
    4000:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    4004:	8a 21       	and	r24, r10
    4006:	9b 21       	and	r25, r11
    4008:	89 2b       	or	r24, r25
    400a:	21 f0       	breq	.+8      	; 0x4014 <sendto+0x1a2>
    400c:	c0 16       	cp	r12, r16
    400e:	d1 06       	cpc	r13, r17
    4010:	20 f4       	brcc	.+8      	; 0x401a <sendto+0x1a8>
    4012:	51 c0       	rjmp	.+162    	; 0x40b6 <sendto+0x244>
      if(len <= freesize) break;
    4014:	c0 16       	cp	r12, r16
    4016:	d1 06       	cpc	r13, r17
    4018:	30 f3       	brcs	.-52     	; 0x3fe6 <sendto+0x174>
   };
	wiz_send_data(sn, buf, len);
    401a:	a8 01       	movw	r20, r16
    401c:	b4 01       	movw	r22, r8
    401e:	8f 2d       	mov	r24, r15
    4020:	0e 94 0e 2b 	call	0x561c	; 0x561c <wiz_send_data>
//A20150601 : For W5300
#if _WIZCHIP_ == 5300
   setSn_TX_WRSR(sn, len);
#endif
//   
	setSn_CR(sn,Sn_CR_SEND);
    4024:	4e 01       	movw	r8, r28
    4026:	93 94       	inc	r9
    4028:	09 2c       	mov	r0, r9
    402a:	00 0c       	add	r0, r0
    402c:	aa 08       	sbc	r10, r10
    402e:	bb 08       	sbc	r11, r11
    4030:	40 e2       	ldi	r20, 0x20	; 32
    4032:	c5 01       	movw	r24, r10
    4034:	b4 01       	movw	r22, r8
    4036:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
	/* wait to process the command... */
	while(getSn_CR(sn));
    403a:	c5 01       	movw	r24, r10
    403c:	b4 01       	movw	r22, r8
    403e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4042:	81 11       	cpse	r24, r1
    4044:	fa cf       	rjmp	.-12     	; 0x403a <sendto+0x1c8>
   while(1)
   {
      tmp = getSn_IR(sn);
    4046:	de 5f       	subi	r29, 0xFE	; 254
    4048:	4e 01       	movw	r8, r28
    404a:	dd 0f       	add	r29, r29
    404c:	aa 08       	sbc	r10, r10
    404e:	bb 08       	sbc	r11, r11
    4050:	c5 01       	movw	r24, r10
    4052:	b4 01       	movw	r22, r8
    4054:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
      if(tmp & Sn_IR_SENDOK)
    4058:	84 ff       	sbrs	r24, 4
    405a:	09 c0       	rjmp	.+18     	; 0x406e <sendto+0x1fc>
      {
         setSn_IR(sn, Sn_IR_SENDOK);
    405c:	40 e1       	ldi	r20, 0x10	; 16
    405e:	c5 01       	movw	r24, r10
    4060:	b4 01       	movw	r22, r8
    4062:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
      if(taddr) setSUBR((uint8_t*)&taddr);
   #endif
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    4066:	b8 01       	movw	r22, r16
    4068:	80 e0       	ldi	r24, 0x00	; 0
    406a:	90 e0       	ldi	r25, 0x00	; 0
    406c:	27 c0       	rjmp	.+78     	; 0x40bc <sendto+0x24a>
         setSn_IR(sn, Sn_IR_SENDOK);
         break;
      }
      //M:20131104
      //else if(tmp & Sn_IR_TIMEOUT) return SOCKERR_TIMEOUT;
      else if(tmp & Sn_IR_TIMEOUT)
    406e:	83 ff       	sbrs	r24, 3
    4070:	ef cf       	rjmp	.-34     	; 0x4050 <sendto+0x1de>
      {
         setSn_IR(sn, Sn_IR_TIMEOUT);
    4072:	48 e0       	ldi	r20, 0x08	; 8
    4074:	c5 01       	movw	r24, r10
    4076:	b4 01       	movw	r22, r8
    4078:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
         //len = (uint16_t)SOCKERR_TIMEOUT;
         //break;
         #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
            if(taddr) setSUBR((uint8_t*)&taddr);
         #endif
         return SOCKERR_TIMEOUT;
    407c:	63 ef       	ldi	r22, 0xF3	; 243
    407e:	7f ef       	ldi	r23, 0xFF	; 255
    4080:	8f ef       	ldi	r24, 0xFF	; 255
    4082:	9f ef       	ldi	r25, 0xFF	; 255
    4084:	1b c0       	rjmp	.+54     	; 0x40bc <sendto+0x24a>
{
   uint8_t tmp = 0;
   uint16_t freesize = 0;
   uint32_t taddr;

   CHECK_SOCKNUM();
    4086:	6f ef       	ldi	r22, 0xFF	; 255
    4088:	7f ef       	ldi	r23, 0xFF	; 255
    408a:	cb 01       	movw	r24, r22
    408c:	17 c0       	rjmp	.+46     	; 0x40bc <sendto+0x24a>
//   #if ( _WIZCHIP_ < 5200 )
      case Sn_MR_IPRAW:
         break;
//   #endif
      default:
         return SOCKERR_SOCKMODE;
    408e:	6b ef       	ldi	r22, 0xFB	; 251
    4090:	7f ef       	ldi	r23, 0xFF	; 255
    4092:	8f ef       	ldi	r24, 0xFF	; 255
    4094:	9f ef       	ldi	r25, 0xFF	; 255
    4096:	12 c0       	rjmp	.+36     	; 0x40bc <sendto+0x24a>
   }
   CHECK_SOCKDATA();
    4098:	62 ef       	ldi	r22, 0xF2	; 242
    409a:	7f ef       	ldi	r23, 0xFF	; 255
    409c:	8f ef       	ldi	r24, 0xFF	; 255
    409e:	9f ef       	ldi	r25, 0xFF	; 255
    40a0:	0d c0       	rjmp	.+26     	; 0x40bc <sendto+0x24a>
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
   tmp = getSn_SR(sn);
//#if ( _WIZCHIP_ < 5200 )
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    40a2:	69 ef       	ldi	r22, 0xF9	; 249
    40a4:	7f ef       	ldi	r23, 0xFF	; 255
    40a6:	8f ef       	ldi	r24, 0xFF	; 255
    40a8:	9f ef       	ldi	r25, 0xFF	; 255
    40aa:	08 c0       	rjmp	.+16     	; 0x40bc <sendto+0x24a>
   freesize = getSn_TxMAX(sn);
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    40ac:	6c ef       	ldi	r22, 0xFC	; 252
    40ae:	7f ef       	ldi	r23, 0xFF	; 255
    40b0:	8f ef       	ldi	r24, 0xFF	; 255
    40b2:	9f ef       	ldi	r25, 0xFF	; 255
    40b4:	03 c0       	rjmp	.+6      	; 0x40bc <sendto+0x24a>
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    40b6:	60 e0       	ldi	r22, 0x00	; 0
    40b8:	70 e0       	ldi	r23, 0x00	; 0
    40ba:	cb 01       	movw	r24, r22
      if(taddr) setSUBR((uint8_t*)&taddr);
   #endif
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
}
    40bc:	df 91       	pop	r29
    40be:	cf 91       	pop	r28
    40c0:	1f 91       	pop	r17
    40c2:	0f 91       	pop	r16
    40c4:	ff 90       	pop	r15
    40c6:	df 90       	pop	r13
    40c8:	cf 90       	pop	r12
    40ca:	bf 90       	pop	r11
    40cc:	af 90       	pop	r10
    40ce:	9f 90       	pop	r9
    40d0:	8f 90       	pop	r8
    40d2:	7f 90       	pop	r7
    40d4:	6f 90       	pop	r6
    40d6:	5f 90       	pop	r5
    40d8:	4f 90       	pop	r4
    40da:	08 95       	ret

000040dc <recvfrom>:



int32_t recvfrom(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port)
{
    40dc:	2f 92       	push	r2
    40de:	3f 92       	push	r3
    40e0:	4f 92       	push	r4
    40e2:	5f 92       	push	r5
    40e4:	6f 92       	push	r6
    40e6:	7f 92       	push	r7
    40e8:	8f 92       	push	r8
    40ea:	9f 92       	push	r9
    40ec:	af 92       	push	r10
    40ee:	bf 92       	push	r11
    40f0:	cf 92       	push	r12
    40f2:	df 92       	push	r13
    40f4:	ef 92       	push	r14
    40f6:	ff 92       	push	r15
    40f8:	0f 93       	push	r16
    40fa:	1f 93       	push	r17
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	cd b7       	in	r28, 0x3d	; 61
    4102:	de b7       	in	r29, 0x3e	; 62
    4104:	60 97       	sbiw	r28, 0x10	; 16
    4106:	0f b6       	in	r0, 0x3f	; 63
    4108:	f8 94       	cli
    410a:	de bf       	out	0x3e, r29	; 62
    410c:	0f be       	out	0x3f, r0	; 63
    410e:	cd bf       	out	0x3d, r28	; 61
#endif
//   
   uint8_t  head[8];
	uint16_t pack_len=0;

   CHECK_SOCKNUM();
    4110:	89 30       	cpi	r24, 0x09	; 9
    4112:	08 f0       	brcs	.+2      	; 0x4116 <recvfrom+0x3a>
    4114:	65 c1       	rjmp	.+714    	; 0x43e0 <recvfrom+0x304>
    4116:	18 8b       	std	Y+16, r17	; 0x10
    4118:	0f 87       	std	Y+15, r16	; 0x0f
    411a:	59 01       	movw	r10, r18
    411c:	4a 01       	movw	r8, r20
    411e:	7e 87       	std	Y+14, r23	; 0x0e
    4120:	6d 87       	std	Y+13, r22	; 0x0d
    4122:	78 2e       	mov	r7, r24
//A20150601
#if _WIZCHIP_ == 5300
   mr1 = getMR();
#endif   

   switch((mr=getSn_MR(sn)) & 0x0F)
    4124:	c8 2e       	mov	r12, r24
    4126:	d1 2c       	mov	r13, r1
    4128:	c6 01       	movw	r24, r12
    412a:	75 e0       	ldi	r23, 0x05	; 5
    412c:	88 0f       	add	r24, r24
    412e:	99 1f       	adc	r25, r25
    4130:	7a 95       	dec	r23
    4132:	e1 f7       	brne	.-8      	; 0x412c <recvfrom+0x50>
    4134:	9c 01       	movw	r18, r24
    4136:	28 5f       	subi	r18, 0xF8	; 248
    4138:	3f 4f       	sbci	r19, 0xFF	; 255
    413a:	3a 87       	std	Y+10, r19	; 0x0a
    413c:	29 87       	std	Y+9, r18	; 0x09
    413e:	b9 01       	movw	r22, r18
    4140:	33 0f       	add	r19, r19
    4142:	88 0b       	sbc	r24, r24
    4144:	99 0b       	sbc	r25, r25
    4146:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    414a:	68 2e       	mov	r6, r24
    414c:	8f 70       	andi	r24, 0x0F	; 15
    414e:	82 50       	subi	r24, 0x02	; 2
    4150:	83 30       	cpi	r24, 0x03	; 3
    4152:	08 f0       	brcs	.+2      	; 0x4156 <recvfrom+0x7a>
    4154:	49 c1       	rjmp	.+658    	; 0x43e8 <recvfrom+0x30c>
         break;
   #endif
      default:
         return SOCKERR_SOCKMODE;
   }
   CHECK_SOCKDATA();
    4156:	81 14       	cp	r8, r1
    4158:	91 04       	cpc	r9, r1
    415a:	09 f4       	brne	.+2      	; 0x415e <recvfrom+0x82>
    415c:	4a c1       	rjmp	.+660    	; 0x43f2 <recvfrom+0x316>
   if(sock_remained_size[sn] == 0)
    415e:	76 01       	movw	r14, r12
    4160:	ee 0c       	add	r14, r14
    4162:	ff 1c       	adc	r15, r15
    4164:	f7 01       	movw	r30, r14
    4166:	e6 52       	subi	r30, 0x26	; 38
    4168:	f9 4f       	sbci	r31, 0xF9	; 249
    416a:	80 81       	ld	r24, Z
    416c:	91 81       	ldd	r25, Z+1	; 0x01
    416e:	89 2b       	or	r24, r25
    4170:	81 f5       	brne	.+96     	; 0x41d2 <recvfrom+0xf6>
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
         if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
    4172:	81 e0       	ldi	r24, 0x01	; 1
    4174:	90 e0       	ldi	r25, 0x00	; 0
    4176:	fc 01       	movw	r30, r24
    4178:	07 2c       	mov	r0, r7
    417a:	02 c0       	rjmp	.+4      	; 0x4180 <recvfrom+0xa4>
    417c:	ee 0f       	add	r30, r30
    417e:	ff 1f       	adc	r31, r31
    4180:	0a 94       	dec	r0
    4182:	e2 f7       	brpl	.-8      	; 0x417c <recvfrom+0xa0>
    4184:	fc 87       	std	Y+12, r31	; 0x0c
    4186:	eb 87       	std	Y+11, r30	; 0x0b
   if(sock_remained_size[sn] == 0)
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    4188:	29 84       	ldd	r2, Y+9	; 0x09
    418a:	3a 84       	ldd	r3, Y+10	; 0x0a
    418c:	fd ef       	ldi	r31, 0xFD	; 253
    418e:	3f 1a       	sub	r3, r31
    4190:	03 2c       	mov	r0, r3
    4192:	00 0c       	add	r0, r0
    4194:	44 08       	sbc	r4, r4
    4196:	55 08       	sbc	r5, r5
   CHECK_SOCKDATA();
   if(sock_remained_size[sn] == 0)
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
    4198:	87 2d       	mov	r24, r7
    419a:	0e 94 b6 2a 	call	0x556c	; 0x556c <getSn_RX_RSR>
    419e:	8c 01       	movw	r16, r24
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    41a0:	c2 01       	movw	r24, r4
    41a2:	b1 01       	movw	r22, r2
    41a4:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    41a8:	88 23       	and	r24, r24
    41aa:	09 f4       	brne	.+2      	; 0x41ae <recvfrom+0xd2>
    41ac:	27 c1       	rjmp	.+590    	; 0x43fc <recvfrom+0x320>
         if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
    41ae:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <sock_io_mode>
    41b2:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    41b6:	2b 85       	ldd	r18, Y+11	; 0x0b
    41b8:	3c 85       	ldd	r19, Y+12	; 0x0c
    41ba:	82 23       	and	r24, r18
    41bc:	93 23       	and	r25, r19
    41be:	89 2b       	or	r24, r25
    41c0:	21 f0       	breq	.+8      	; 0x41ca <recvfrom+0xee>
    41c2:	01 15       	cp	r16, r1
    41c4:	11 05       	cpc	r17, r1
    41c6:	39 f4       	brne	.+14     	; 0x41d6 <recvfrom+0xfa>
    41c8:	1e c1       	rjmp	.+572    	; 0x4406 <recvfrom+0x32a>
         if(pack_len != 0) break;
    41ca:	01 15       	cp	r16, r1
    41cc:	11 05       	cpc	r17, r1
    41ce:	21 f3       	breq	.-56     	; 0x4198 <recvfrom+0xbc>
    41d0:	02 c0       	rjmp	.+4      	; 0x41d6 <recvfrom+0xfa>
#else   
   uint8_t  mr;
#endif
//   
   uint8_t  head[8];
	uint16_t pack_len=0;
    41d2:	00 e0       	ldi	r16, 0x00	; 0
    41d4:	10 e0       	ldi	r17, 0x00	; 0
         if(pack_len != 0) break;
      };
   }
//D20150601 : Move it to bottom
// sock_pack_info[sn] = PACK_COMPLETED;
	switch (mr & 0x07)
    41d6:	86 2d       	mov	r24, r6
    41d8:	87 70       	andi	r24, 0x07	; 7
    41da:	e9 85       	ldd	r30, Y+9	; 0x09
    41dc:	fa 85       	ldd	r31, Y+10	; 0x0a
    41de:	f3 95       	inc	r31
    41e0:	fa 87       	std	Y+10, r31	; 0x0a
    41e2:	e9 87       	std	Y+9, r30	; 0x09
    41e4:	83 30       	cpi	r24, 0x03	; 3
    41e6:	09 f4       	brne	.+2      	; 0x41ea <recvfrom+0x10e>
    41e8:	7f c0       	rjmp	.+254    	; 0x42e8 <recvfrom+0x20c>
    41ea:	84 30       	cpi	r24, 0x04	; 4
    41ec:	09 f4       	brne	.+2      	; 0x41f0 <recvfrom+0x114>
    41ee:	41 c0       	rjmp	.+130    	; 0x4272 <recvfrom+0x196>
    41f0:	82 30       	cpi	r24, 0x02	; 2
    41f2:	09 f0       	breq	.+2      	; 0x41f6 <recvfrom+0x11a>
    41f4:	c4 c0       	rjmp	.+392    	; 0x437e <recvfrom+0x2a2>
	{
	   case Sn_MR_UDP :
	      if(sock_remained_size[sn] == 0)
    41f6:	f7 01       	movw	r30, r14
    41f8:	e6 52       	subi	r30, 0x26	; 38
    41fa:	f9 4f       	sbci	r31, 0xF9	; 249
    41fc:	80 81       	ld	r24, Z
    41fe:	91 81       	ldd	r25, Z+1	; 0x01
    4200:	89 2b       	or	r24, r25
    4202:	09 f0       	breq	.+2      	; 0x4206 <recvfrom+0x12a>
    4204:	ab c0       	rjmp	.+342    	; 0x435c <recvfrom+0x280>
	      {
   			wiz_recv_data(sn, head, 8);
    4206:	48 e0       	ldi	r20, 0x08	; 8
    4208:	50 e0       	ldi	r21, 0x00	; 0
    420a:	be 01       	movw	r22, r28
    420c:	6f 5f       	subi	r22, 0xFF	; 255
    420e:	7f 4f       	sbci	r23, 0xFF	; 255
    4210:	87 2d       	mov	r24, r7
    4212:	0e 94 9e 2b 	call	0x573c	; 0x573c <wiz_recv_data>
   			setSn_CR(sn,Sn_CR_RECV);
    4216:	29 85       	ldd	r18, Y+9	; 0x09
    4218:	3a 85       	ldd	r19, Y+10	; 0x0a
    421a:	19 01       	movw	r2, r18
    421c:	33 0f       	add	r19, r19
    421e:	44 08       	sbc	r4, r4
    4220:	55 08       	sbc	r5, r5
    4222:	40 e4       	ldi	r20, 0x40	; 64
    4224:	c2 01       	movw	r24, r4
    4226:	b1 01       	movw	r22, r2
    4228:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   			while(getSn_CR(sn));
    422c:	c2 01       	movw	r24, r4
    422e:	b1 01       	movw	r22, r2
    4230:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4234:	81 11       	cpse	r24, r1
    4236:	fa cf       	rjmp	.-12     	; 0x422c <recvfrom+0x150>
      			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[6];
   		   }
            else
            {
         #endif
               addr[0] = head[0];
    4238:	89 81       	ldd	r24, Y+1	; 0x01
    423a:	f5 01       	movw	r30, r10
    423c:	80 83       	st	Z, r24
      			addr[1] = head[1];
    423e:	8a 81       	ldd	r24, Y+2	; 0x02
    4240:	81 83       	std	Z+1, r24	; 0x01
      			addr[2] = head[2];
    4242:	8b 81       	ldd	r24, Y+3	; 0x03
    4244:	82 83       	std	Z+2, r24	; 0x02
      			addr[3] = head[3];
    4246:	8c 81       	ldd	r24, Y+4	; 0x04
    4248:	83 83       	std	Z+3, r24	; 0x03
      			*port = head[4];
      			*port = (*port << 8) + head[5];
    424a:	8d 81       	ldd	r24, Y+5	; 0x05
    424c:	90 e0       	ldi	r25, 0x00	; 0
    424e:	98 2f       	mov	r25, r24
    4250:	88 27       	eor	r24, r24
    4252:	2e 81       	ldd	r18, Y+6	; 0x06
    4254:	82 0f       	add	r24, r18
    4256:	91 1d       	adc	r25, r1
    4258:	ef 85       	ldd	r30, Y+15	; 0x0f
    425a:	f8 89       	ldd	r31, Y+16	; 0x10
    425c:	91 83       	std	Z+1, r25	; 0x01
    425e:	80 83       	st	Z, r24
      			sock_remained_size[sn] = head[6];
      			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[7];
    4260:	f7 01       	movw	r30, r14
    4262:	e6 52       	subi	r30, 0x26	; 38
    4264:	f9 4f       	sbci	r31, 0xF9	; 249
    4266:	8f 81       	ldd	r24, Y+7	; 0x07
    4268:	90 e0       	ldi	r25, 0x00	; 0
    426a:	98 2f       	mov	r25, r24
    426c:	88 27       	eor	r24, r24
    426e:	28 85       	ldd	r18, Y+8	; 0x08
    4270:	6c c0       	rjmp	.+216    	; 0x434a <recvfrom+0x26e>
			// Need to packet length check (default 1472)
			//
   		wiz_recv_data(sn, buf, pack_len); // data copy.
			break;
	   case Sn_MR_MACRAW :
	      if(sock_remained_size[sn] == 0)
    4272:	f7 01       	movw	r30, r14
    4274:	e6 52       	subi	r30, 0x26	; 38
    4276:	f9 4f       	sbci	r31, 0xF9	; 249
    4278:	80 81       	ld	r24, Z
    427a:	91 81       	ldd	r25, Z+1	; 0x01
    427c:	89 2b       	or	r24, r25
    427e:	09 f0       	breq	.+2      	; 0x4282 <recvfrom+0x1a6>
    4280:	6d c0       	rjmp	.+218    	; 0x435c <recvfrom+0x280>
	      {
   			wiz_recv_data(sn, head, 2);
    4282:	42 e0       	ldi	r20, 0x02	; 2
    4284:	50 e0       	ldi	r21, 0x00	; 0
    4286:	be 01       	movw	r22, r28
    4288:	6f 5f       	subi	r22, 0xFF	; 255
    428a:	7f 4f       	sbci	r23, 0xFF	; 255
    428c:	87 2d       	mov	r24, r7
    428e:	0e 94 9e 2b 	call	0x573c	; 0x573c <wiz_recv_data>
   			setSn_CR(sn,Sn_CR_RECV);
    4292:	29 85       	ldd	r18, Y+9	; 0x09
    4294:	3a 85       	ldd	r19, Y+10	; 0x0a
    4296:	19 01       	movw	r2, r18
    4298:	33 0f       	add	r19, r19
    429a:	44 08       	sbc	r4, r4
    429c:	55 08       	sbc	r5, r5
    429e:	40 e4       	ldi	r20, 0x40	; 64
    42a0:	c2 01       	movw	r24, r4
    42a2:	b1 01       	movw	r22, r2
    42a4:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   			while(getSn_CR(sn));
    42a8:	c2 01       	movw	r24, r4
    42aa:	b1 01       	movw	r22, r2
    42ac:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    42b0:	81 11       	cpse	r24, r1
    42b2:	fa cf       	rjmp	.-12     	; 0x42a8 <recvfrom+0x1cc>
   			// read peer's IP address, port number & packet length
    			sock_remained_size[sn] = head[0];
   			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1] -2;
    42b4:	89 81       	ldd	r24, Y+1	; 0x01
    42b6:	90 e0       	ldi	r25, 0x00	; 0
    42b8:	38 2f       	mov	r19, r24
    42ba:	22 27       	eor	r18, r18
    42bc:	9a 81       	ldd	r25, Y+2	; 0x02
    42be:	89 2f       	mov	r24, r25
    42c0:	90 e0       	ldi	r25, 0x00	; 0
    42c2:	02 97       	sbiw	r24, 0x02	; 2
    42c4:	82 0f       	add	r24, r18
    42c6:	93 1f       	adc	r25, r19
    42c8:	f7 01       	movw	r30, r14
    42ca:	e6 52       	subi	r30, 0x26	; 38
    42cc:	f9 4f       	sbci	r31, 0xF9	; 249
    42ce:	91 83       	std	Z+1, r25	; 0x01
    42d0:	80 83       	st	Z, r24
   			if(sock_remained_size[sn] & 0x01)
   				sock_remained_size[sn] = sock_remained_size[sn] + 1 - 4;
   			else
   				sock_remained_size[sn] -= 4;
			#endif
   			if(sock_remained_size[sn] > 1514) 
    42d2:	8b 3e       	cpi	r24, 0xEB	; 235
    42d4:	95 40       	sbci	r25, 0x05	; 5
    42d6:	e8 f1       	brcs	.+122    	; 0x4352 <recvfrom+0x276>
   			{
   			   close(sn);
    42d8:	87 2d       	mov	r24, r7
    42da:	0e 94 09 1a 	call	0x3412	; 0x3412 <close>
   			   return SOCKFATAL_PACKLEN;
    42de:	67 e1       	ldi	r22, 0x17	; 23
    42e0:	7c ef       	ldi	r23, 0xFC	; 252
    42e2:	8f ef       	ldi	r24, 0xFF	; 255
    42e4:	9f ef       	ldi	r25, 0xFF	; 255
    42e6:	92 c0       	rjmp	.+292    	; 0x440c <recvfrom+0x330>
			else pack_len = sock_remained_size[sn];
			wiz_recv_data(sn,buf,pack_len);
		   break;
   //#if ( _WIZCHIP_ < 5200 )
		case Sn_MR_IPRAW:
		   if(sock_remained_size[sn] == 0)
    42e8:	f7 01       	movw	r30, r14
    42ea:	e6 52       	subi	r30, 0x26	; 38
    42ec:	f9 4f       	sbci	r31, 0xF9	; 249
    42ee:	80 81       	ld	r24, Z
    42f0:	91 81       	ldd	r25, Z+1	; 0x01
    42f2:	89 2b       	or	r24, r25
    42f4:	99 f5       	brne	.+102    	; 0x435c <recvfrom+0x280>
		   {
   			wiz_recv_data(sn, head, 6);
    42f6:	46 e0       	ldi	r20, 0x06	; 6
    42f8:	50 e0       	ldi	r21, 0x00	; 0
    42fa:	be 01       	movw	r22, r28
    42fc:	6f 5f       	subi	r22, 0xFF	; 255
    42fe:	7f 4f       	sbci	r23, 0xFF	; 255
    4300:	87 2d       	mov	r24, r7
    4302:	0e 94 9e 2b 	call	0x573c	; 0x573c <wiz_recv_data>
   			setSn_CR(sn,Sn_CR_RECV);
    4306:	89 85       	ldd	r24, Y+9	; 0x09
    4308:	9a 85       	ldd	r25, Y+10	; 0x0a
    430a:	1c 01       	movw	r2, r24
    430c:	99 0f       	add	r25, r25
    430e:	44 08       	sbc	r4, r4
    4310:	55 08       	sbc	r5, r5
    4312:	40 e4       	ldi	r20, 0x40	; 64
    4314:	c2 01       	movw	r24, r4
    4316:	b1 01       	movw	r22, r2
    4318:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   			while(getSn_CR(sn));
    431c:	c2 01       	movw	r24, r4
    431e:	b1 01       	movw	r22, r2
    4320:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4324:	81 11       	cpse	r24, r1
    4326:	fa cf       	rjmp	.-12     	; 0x431c <recvfrom+0x240>
   			addr[0] = head[0];
    4328:	89 81       	ldd	r24, Y+1	; 0x01
    432a:	f5 01       	movw	r30, r10
    432c:	80 83       	st	Z, r24
   			addr[1] = head[1];
    432e:	8a 81       	ldd	r24, Y+2	; 0x02
    4330:	81 83       	std	Z+1, r24	; 0x01
   			addr[2] = head[2];
    4332:	8b 81       	ldd	r24, Y+3	; 0x03
    4334:	82 83       	std	Z+2, r24	; 0x02
   			addr[3] = head[3];
    4336:	8c 81       	ldd	r24, Y+4	; 0x04
    4338:	83 83       	std	Z+3, r24	; 0x03
   			sock_remained_size[sn] = head[4];
   			//M20150401 : For Typing Error
   			//sock_remaiend_size[sn] = (sock_remained_size[sn] << 8) + head[5];
   			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[5];
    433a:	f7 01       	movw	r30, r14
    433c:	e6 52       	subi	r30, 0x26	; 38
    433e:	f9 4f       	sbci	r31, 0xF9	; 249
    4340:	8d 81       	ldd	r24, Y+5	; 0x05
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	98 2f       	mov	r25, r24
    4346:	88 27       	eor	r24, r24
    4348:	2e 81       	ldd	r18, Y+6	; 0x06
    434a:	82 0f       	add	r24, r18
    434c:	91 1d       	adc	r25, r1
    434e:	91 83       	std	Z+1, r25	; 0x01
    4350:	80 83       	st	Z, r24
   			sock_pack_info[sn] = PACK_FIRST;
    4352:	80 e8       	ldi	r24, 0x80	; 128
    4354:	f6 01       	movw	r30, r12
    4356:	ee 52       	subi	r30, 0x2E	; 46
    4358:	f9 4f       	sbci	r31, 0xF9	; 249
    435a:	80 83       	st	Z, r24
         }
			//
			// Need to packet length check
			//
			if(len < sock_remained_size[sn]) pack_len = len;
    435c:	f7 01       	movw	r30, r14
    435e:	e6 52       	subi	r30, 0x26	; 38
    4360:	f9 4f       	sbci	r31, 0xF9	; 249
    4362:	80 81       	ld	r24, Z
    4364:	91 81       	ldd	r25, Z+1	; 0x01
    4366:	84 01       	movw	r16, r8
    4368:	88 15       	cp	r24, r8
    436a:	99 05       	cpc	r25, r9
    436c:	08 f4       	brcc	.+2      	; 0x4370 <recvfrom+0x294>
    436e:	8c 01       	movw	r16, r24
			else pack_len = sock_remained_size[sn];
   		wiz_recv_data(sn, buf, pack_len); // data copy.
    4370:	a8 01       	movw	r20, r16
    4372:	6d 85       	ldd	r22, Y+13	; 0x0d
    4374:	7e 85       	ldd	r23, Y+14	; 0x0e
    4376:	87 2d       	mov	r24, r7
    4378:	0e 94 9e 2b 	call	0x573c	; 0x573c <wiz_recv_data>
			break;
    437c:	09 c0       	rjmp	.+18     	; 0x4390 <recvfrom+0x2b4>
   //#endif
      default:
         wiz_recv_ignore(sn, pack_len); // data copy.
    437e:	b8 01       	movw	r22, r16
    4380:	87 2d       	mov	r24, r7
    4382:	0e 94 2e 2c 	call	0x585c	; 0x585c <wiz_recv_ignore>
         sock_remained_size[sn] = pack_len;
    4386:	f7 01       	movw	r30, r14
    4388:	e6 52       	subi	r30, 0x26	; 38
    438a:	f9 4f       	sbci	r31, 0xF9	; 249
    438c:	11 83       	std	Z+1, r17	; 0x01
    438e:	00 83       	st	Z, r16
         break;
   }
	setSn_CR(sn,Sn_CR_RECV);
    4390:	29 85       	ldd	r18, Y+9	; 0x09
    4392:	3a 85       	ldd	r19, Y+10	; 0x0a
    4394:	49 01       	movw	r8, r18
    4396:	33 0f       	add	r19, r19
    4398:	aa 08       	sbc	r10, r10
    439a:	bb 08       	sbc	r11, r11
    439c:	40 e4       	ldi	r20, 0x40	; 64
    439e:	c5 01       	movw	r24, r10
    43a0:	b4 01       	movw	r22, r8
    43a2:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
	/* wait to process the command... */
	while(getSn_CR(sn)) ;
    43a6:	c5 01       	movw	r24, r10
    43a8:	b4 01       	movw	r22, r8
    43aa:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    43ae:	81 11       	cpse	r24, r1
    43b0:	fa cf       	rjmp	.-12     	; 0x43a6 <recvfrom+0x2ca>
	sock_remained_size[sn] -= pack_len;
    43b2:	f7 01       	movw	r30, r14
    43b4:	e6 52       	subi	r30, 0x26	; 38
    43b6:	f9 4f       	sbci	r31, 0xF9	; 249
    43b8:	80 81       	ld	r24, Z
    43ba:	91 81       	ldd	r25, Z+1	; 0x01
    43bc:	80 1b       	sub	r24, r16
    43be:	91 0b       	sbc	r25, r17
    43c0:	91 83       	std	Z+1, r25	; 0x01
    43c2:	80 83       	st	Z, r24
    43c4:	f6 01       	movw	r30, r12
    43c6:	ee 52       	subi	r30, 0x2E	; 46
    43c8:	f9 4f       	sbci	r31, 0xF9	; 249
	//M20150601 : 
	//if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= 0x01;
	if(sock_remained_size[sn] != 0)
    43ca:	89 2b       	or	r24, r25
    43cc:	21 f0       	breq	.+8      	; 0x43d6 <recvfrom+0x2fa>
	{
	   sock_pack_info[sn] |= PACK_REMAINED;
    43ce:	80 81       	ld	r24, Z
    43d0:	81 60       	ori	r24, 0x01	; 1
    43d2:	80 83       	st	Z, r24
    43d4:	01 c0       	rjmp	.+2      	; 0x43d8 <recvfrom+0x2fc>
   #if _WIZCHIP_ == 5300	   
	   if(pack_len & 0x01) sock_pack_info[sn] |= PACK_FIFOBYTE;
   #endif	      
	}
	else sock_pack_info[sn] = PACK_COMPLETED;
    43d6:	10 82       	st	Z, r1
   pack_len = len;
#endif
   //
   //M20150409 : Explicit Type Casting
   //return pack_len;
   return (int32_t)pack_len;
    43d8:	b8 01       	movw	r22, r16
    43da:	80 e0       	ldi	r24, 0x00	; 0
    43dc:	90 e0       	ldi	r25, 0x00	; 0
    43de:	16 c0       	rjmp	.+44     	; 0x440c <recvfrom+0x330>
#endif
//   
   uint8_t  head[8];
	uint16_t pack_len=0;

   CHECK_SOCKNUM();
    43e0:	6f ef       	ldi	r22, 0xFF	; 255
    43e2:	7f ef       	ldi	r23, 0xFF	; 255
    43e4:	cb 01       	movw	r24, r22
    43e6:	12 c0       	rjmp	.+36     	; 0x440c <recvfrom+0x330>
   #if ( _WIZCHIP_ < 5200 )         
      case Sn_MR_PPPoE:
         break;
   #endif
      default:
         return SOCKERR_SOCKMODE;
    43e8:	6b ef       	ldi	r22, 0xFB	; 251
    43ea:	7f ef       	ldi	r23, 0xFF	; 255
    43ec:	8f ef       	ldi	r24, 0xFF	; 255
    43ee:	9f ef       	ldi	r25, 0xFF	; 255
    43f0:	0d c0       	rjmp	.+26     	; 0x440c <recvfrom+0x330>
   }
   CHECK_SOCKDATA();
    43f2:	62 ef       	ldi	r22, 0xF2	; 242
    43f4:	7f ef       	ldi	r23, 0xFF	; 255
    43f6:	8f ef       	ldi	r24, 0xFF	; 255
    43f8:	9f ef       	ldi	r25, 0xFF	; 255
    43fa:	08 c0       	rjmp	.+16     	; 0x440c <recvfrom+0x330>
   if(sock_remained_size[sn] == 0)
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    43fc:	6c ef       	ldi	r22, 0xFC	; 252
    43fe:	7f ef       	ldi	r23, 0xFF	; 255
    4400:	8f ef       	ldi	r24, 0xFF	; 255
    4402:	9f ef       	ldi	r25, 0xFF	; 255
    4404:	03 c0       	rjmp	.+6      	; 0x440c <recvfrom+0x330>
         if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
    4406:	60 e0       	ldi	r22, 0x00	; 0
    4408:	70 e0       	ldi	r23, 0x00	; 0
    440a:	cb 01       	movw	r24, r22
#endif
   //
   //M20150409 : Explicit Type Casting
   //return pack_len;
   return (int32_t)pack_len;
}
    440c:	60 96       	adiw	r28, 0x10	; 16
    440e:	0f b6       	in	r0, 0x3f	; 63
    4410:	f8 94       	cli
    4412:	de bf       	out	0x3e, r29	; 62
    4414:	0f be       	out	0x3f, r0	; 63
    4416:	cd bf       	out	0x3d, r28	; 61
    4418:	df 91       	pop	r29
    441a:	cf 91       	pop	r28
    441c:	1f 91       	pop	r17
    441e:	0f 91       	pop	r16
    4420:	ff 90       	pop	r15
    4422:	ef 90       	pop	r14
    4424:	df 90       	pop	r13
    4426:	cf 90       	pop	r12
    4428:	bf 90       	pop	r11
    442a:	af 90       	pop	r10
    442c:	9f 90       	pop	r9
    442e:	8f 90       	pop	r8
    4430:	7f 90       	pop	r7
    4432:	6f 90       	pop	r6
    4434:	5f 90       	pop	r5
    4436:	4f 90       	pop	r4
    4438:	3f 90       	pop	r3
    443a:	2f 90       	pop	r2
    443c:	08 95       	ret

0000443e <ctlsocket>:


int8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg)
{
    443e:	0f 93       	push	r16
    4440:	1f 93       	push	r17
    4442:	cf 93       	push	r28
    4444:	df 93       	push	r29
   uint8_t tmp = 0;
   CHECK_SOCKNUM();
    4446:	89 30       	cpi	r24, 0x09	; 9
    4448:	08 f0       	brcs	.+2      	; 0x444c <ctlsocket+0xe>
    444a:	88 c0       	rjmp	.+272    	; 0x455c <ctlsocket+0x11e>
   switch(cstype)
    444c:	06 2f       	mov	r16, r22
    444e:	10 e0       	ldi	r17, 0x00	; 0
    4450:	08 30       	cpi	r16, 0x08	; 8
    4452:	11 05       	cpc	r17, r1
    4454:	08 f0       	brcs	.+2      	; 0x4458 <ctlsocket+0x1a>
    4456:	84 c0       	rjmp	.+264    	; 0x4560 <ctlsocket+0x122>
    4458:	ea 01       	movw	r28, r20
    445a:	68 2f       	mov	r22, r24
    445c:	f8 01       	movw	r30, r16
    445e:	ec 5c       	subi	r30, 0xCC	; 204
    4460:	ff 4f       	sbci	r31, 0xFF	; 255
    4462:	0c 94 d9 2c 	jmp	0x59b2	; 0x59b2 <__tablejump2__>
   {
      case CS_SET_IOMODE:
         tmp = *((uint8_t*)arg);
    4466:	88 81       	ld	r24, Y
         if(tmp == SOCK_IO_NONBLOCK)  sock_io_mode |= (1<<sn);
    4468:	81 30       	cpi	r24, 0x01	; 1
    446a:	71 f4       	brne	.+28     	; 0x4488 <ctlsocket+0x4a>
    446c:	81 e0       	ldi	r24, 0x01	; 1
    446e:	90 e0       	ldi	r25, 0x00	; 0
    4470:	02 c0       	rjmp	.+4      	; 0x4476 <ctlsocket+0x38>
    4472:	88 0f       	add	r24, r24
    4474:	99 1f       	adc	r25, r25
    4476:	6a 95       	dec	r22
    4478:	e2 f7       	brpl	.-8      	; 0x4472 <ctlsocket+0x34>
    447a:	20 91 ec 06 	lds	r18, 0x06EC	; 0x8006ec <sock_io_mode>
    447e:	30 91 ed 06 	lds	r19, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    4482:	82 2b       	or	r24, r18
    4484:	93 2b       	or	r25, r19
    4486:	11 c0       	rjmp	.+34     	; 0x44aa <ctlsocket+0x6c>
         else if(tmp == SOCK_IO_BLOCK) sock_io_mode &= ~(1<<sn);
    4488:	81 11       	cpse	r24, r1
    448a:	6a c0       	rjmp	.+212    	; 0x4560 <ctlsocket+0x122>
    448c:	81 e0       	ldi	r24, 0x01	; 1
    448e:	90 e0       	ldi	r25, 0x00	; 0
    4490:	02 c0       	rjmp	.+4      	; 0x4496 <ctlsocket+0x58>
    4492:	88 0f       	add	r24, r24
    4494:	99 1f       	adc	r25, r25
    4496:	6a 95       	dec	r22
    4498:	e2 f7       	brpl	.-8      	; 0x4492 <ctlsocket+0x54>
    449a:	80 95       	com	r24
    449c:	90 95       	com	r25
    449e:	20 91 ec 06 	lds	r18, 0x06EC	; 0x8006ec <sock_io_mode>
    44a2:	30 91 ed 06 	lds	r19, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    44a6:	82 23       	and	r24, r18
    44a8:	93 23       	and	r25, r19
    44aa:	90 93 ed 06 	sts	0x06ED, r25	; 0x8006ed <sock_io_mode+0x1>
    44ae:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <sock_io_mode>
    44b2:	1b c0       	rjmp	.+54     	; 0x44ea <ctlsocket+0xac>
         else return SOCKERR_ARG;
         break;
      case CS_GET_IOMODE:   
         //M20140501 : implict type casting -> explict type casting
         //*((uint8_t*)arg) = (sock_io_mode >> sn) & 0x0001;
         *((uint8_t*)arg) = (uint8_t)((sock_io_mode >> sn) & 0x0001);
    44b4:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <sock_io_mode>
    44b8:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <sock_io_mode+0x1>
    44bc:	02 c0       	rjmp	.+4      	; 0x44c2 <ctlsocket+0x84>
    44be:	96 95       	lsr	r25
    44c0:	87 95       	ror	r24
    44c2:	6a 95       	dec	r22
    44c4:	e2 f7       	brpl	.-8      	; 0x44be <ctlsocket+0x80>
    44c6:	81 70       	andi	r24, 0x01	; 1
    44c8:	47 c0       	rjmp	.+142    	; 0x4558 <ctlsocket+0x11a>
         //
         break;
      case CS_GET_MAXTXBUF:
         *((uint16_t*)arg) = getSn_TxMAX(sn);
    44ca:	80 e2       	ldi	r24, 0x20	; 32
    44cc:	68 9f       	mul	r22, r24
    44ce:	b0 01       	movw	r22, r0
    44d0:	11 24       	eor	r1, r1
    44d2:	68 5f       	subi	r22, 0xF8	; 248
    44d4:	70 4e       	sbci	r23, 0xE0	; 224
    44d6:	07 2e       	mov	r0, r23
    44d8:	00 0c       	add	r0, r0
    44da:	88 0b       	sbc	r24, r24
    44dc:	99 0b       	sbc	r25, r25
    44de:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    44e2:	88 0f       	add	r24, r24
    44e4:	88 0f       	add	r24, r24
    44e6:	18 82       	st	Y, r1
    44e8:	89 83       	std	Y+1, r24	; 0x01
         break;
   #endif
      default:
         return SOCKERR_ARG;
   }
   return SOCK_OK;
    44ea:	81 e0       	ldi	r24, 0x01	; 1
         *((uint8_t*)arg) = (uint8_t)((sock_io_mode >> sn) & 0x0001);
         //
         break;
      case CS_GET_MAXTXBUF:
         *((uint16_t*)arg) = getSn_TxMAX(sn);
         break;
    44ec:	3a c0       	rjmp	.+116    	; 0x4562 <ctlsocket+0x124>
      case CS_GET_MAXRXBUF:    
         *((uint16_t*)arg) = getSn_RxMAX(sn);
    44ee:	80 e2       	ldi	r24, 0x20	; 32
    44f0:	68 9f       	mul	r22, r24
    44f2:	b0 01       	movw	r22, r0
    44f4:	11 24       	eor	r1, r1
    44f6:	68 5f       	subi	r22, 0xF8	; 248
    44f8:	71 4e       	sbci	r23, 0xE1	; 225
    44fa:	ed cf       	rjmp	.-38     	; 0x44d6 <ctlsocket+0x98>
         break;
      case CS_CLR_INTERRUPT:
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    44fc:	48 81       	ld	r20, Y
    44fe:	40 32       	cpi	r20, 0x20	; 32
    4500:	78 f5       	brcc	.+94     	; 0x4560 <ctlsocket+0x122>
         setSn_IR(sn,*(uint8_t*)arg);
    4502:	80 e2       	ldi	r24, 0x20	; 32
    4504:	68 9f       	mul	r22, r24
    4506:	b0 01       	movw	r22, r0
    4508:	11 24       	eor	r1, r1
    450a:	68 5f       	subi	r22, 0xF8	; 248
    450c:	7d 4f       	sbci	r23, 0xFD	; 253
    450e:	10 c0       	rjmp	.+32     	; 0x4530 <ctlsocket+0xf2>
         break;
      case CS_GET_INTERRUPT:
         *((uint8_t*)arg) = getSn_IR(sn);
    4510:	80 e2       	ldi	r24, 0x20	; 32
    4512:	68 9f       	mul	r22, r24
    4514:	b0 01       	movw	r22, r0
    4516:	11 24       	eor	r1, r1
    4518:	68 5f       	subi	r22, 0xF8	; 248
    451a:	7d 4f       	sbci	r23, 0xFD	; 253
    451c:	16 c0       	rjmp	.+44     	; 0x454a <ctlsocket+0x10c>
         break;
   #if _WIZCHIP_ != 5100
      case CS_SET_INTMASK:  
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    451e:	48 81       	ld	r20, Y
    4520:	40 32       	cpi	r20, 0x20	; 32
    4522:	f0 f4       	brcc	.+60     	; 0x4560 <ctlsocket+0x122>
         setSn_IMR(sn,*(uint8_t*)arg);
    4524:	80 e2       	ldi	r24, 0x20	; 32
    4526:	68 9f       	mul	r22, r24
    4528:	b0 01       	movw	r22, r0
    452a:	11 24       	eor	r1, r1
    452c:	68 5f       	subi	r22, 0xF8	; 248
    452e:	73 4d       	sbci	r23, 0xD3	; 211
    4530:	07 2e       	mov	r0, r23
    4532:	00 0c       	add	r0, r0
    4534:	88 0b       	sbc	r24, r24
    4536:	99 0b       	sbc	r25, r25
    4538:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    453c:	d6 cf       	rjmp	.-84     	; 0x44ea <ctlsocket+0xac>
         break;
      case CS_GET_INTMASK:   
         *((uint8_t*)arg) = getSn_IMR(sn);
    453e:	80 e2       	ldi	r24, 0x20	; 32
    4540:	68 9f       	mul	r22, r24
    4542:	b0 01       	movw	r22, r0
    4544:	11 24       	eor	r1, r1
    4546:	68 5f       	subi	r22, 0xF8	; 248
    4548:	73 4d       	sbci	r23, 0xD3	; 211
    454a:	07 2e       	mov	r0, r23
    454c:	00 0c       	add	r0, r0
    454e:	88 0b       	sbc	r24, r24
    4550:	99 0b       	sbc	r25, r25
    4552:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4556:	8f 71       	andi	r24, 0x1F	; 31
    4558:	88 83       	st	Y, r24
    455a:	c7 cf       	rjmp	.-114    	; 0x44ea <ctlsocket+0xac>


int8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg)
{
   uint8_t tmp = 0;
   CHECK_SOCKNUM();
    455c:	8f ef       	ldi	r24, 0xFF	; 255
    455e:	01 c0       	rjmp	.+2      	; 0x4562 <ctlsocket+0x124>
   {
      case CS_SET_IOMODE:
         tmp = *((uint8_t*)arg);
         if(tmp == SOCK_IO_NONBLOCK)  sock_io_mode |= (1<<sn);
         else if(tmp == SOCK_IO_BLOCK) sock_io_mode &= ~(1<<sn);
         else return SOCKERR_ARG;
    4560:	86 ef       	ldi	r24, 0xF6	; 246
   #endif
      default:
         return SOCKERR_ARG;
   }
   return SOCK_OK;
}
    4562:	df 91       	pop	r29
    4564:	cf 91       	pop	r28
    4566:	1f 91       	pop	r17
    4568:	0f 91       	pop	r16
    456a:	08 95       	ret

0000456c <setsockopt>:

int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
    456c:	8f 92       	push	r8
    456e:	9f 92       	push	r9
    4570:	af 92       	push	r10
    4572:	bf 92       	push	r11
    4574:	cf 92       	push	r12
    4576:	df 92       	push	r13
    4578:	ef 92       	push	r14
    457a:	ff 92       	push	r15
    457c:	0f 93       	push	r16
    457e:	1f 93       	push	r17
    4580:	cf 93       	push	r28
    4582:	df 93       	push	r29
 // M20131220 : Remove warning
 //uint8_t tmp;
   CHECK_SOCKNUM();
    4584:	89 30       	cpi	r24, 0x09	; 9
    4586:	08 f0       	brcs	.+2      	; 0x458a <setsockopt+0x1e>
    4588:	98 c0       	rjmp	.+304    	; 0x46ba <setsockopt+0x14e>
   switch(sotype)
    458a:	06 2f       	mov	r16, r22
    458c:	10 e0       	ldi	r17, 0x00	; 0
    458e:	f8 01       	movw	r30, r16
    4590:	31 97       	sbiw	r30, 0x01	; 1
    4592:	e7 30       	cpi	r30, 0x07	; 7
    4594:	f1 05       	cpc	r31, r1
    4596:	08 f0       	brcs	.+2      	; 0x459a <setsockopt+0x2e>
    4598:	92 c0       	rjmp	.+292    	; 0x46be <setsockopt+0x152>
    459a:	ea 01       	movw	r28, r20
    459c:	e4 5c       	subi	r30, 0xC4	; 196
    459e:	ff 4f       	sbci	r31, 0xFF	; 255
    45a0:	68 2f       	mov	r22, r24
    45a2:	70 e0       	ldi	r23, 0x00	; 0
         		}
            }
         break;
   #if _WIZCHIP_ > 5100
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
    45a4:	85 e0       	ldi	r24, 0x05	; 5
    45a6:	66 0f       	add	r22, r22
    45a8:	77 1f       	adc	r23, r23
    45aa:	8a 95       	dec	r24
    45ac:	e1 f7       	brne	.-8      	; 0x45a6 <setsockopt+0x3a>
int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
 // M20131220 : Remove warning
 //uint8_t tmp;
   CHECK_SOCKNUM();
   switch(sotype)
    45ae:	0c 94 d9 2c 	jmp	0x59b2	; 0x59b2 <__tablejump2__>
   {
      case SO_TTL:
         setSn_TTL(sn,*(uint8_t*)arg);
    45b2:	68 5f       	subi	r22, 0xF8	; 248
    45b4:	79 4e       	sbci	r23, 0xE9	; 233
    45b6:	78 c0       	rjmp	.+240    	; 0x46a8 <setsockopt+0x13c>
         break;
      case SO_TOS:
         setSn_TOS(sn,*(uint8_t*)arg);
    45b8:	68 5f       	subi	r22, 0xF8	; 248
    45ba:	7a 4e       	sbci	r23, 0xEA	; 234
    45bc:	75 c0       	rjmp	.+234    	; 0x46a8 <setsockopt+0x13c>
         break;
      case SO_MSS:
         setSn_MSSR(sn,*(uint16_t*)arg);
    45be:	8b 01       	movw	r16, r22
    45c0:	08 5f       	subi	r16, 0xF8	; 248
    45c2:	1f 4f       	sbci	r17, 0xFF	; 255
    45c4:	49 81       	ldd	r20, Y+1	; 0x01
    45c6:	68 5f       	subi	r22, 0xF8	; 248
    45c8:	7d 4e       	sbci	r23, 0xED	; 237
    45ca:	07 2e       	mov	r0, r23
    45cc:	00 0c       	add	r0, r0
    45ce:	88 0b       	sbc	r24, r24
    45d0:	99 0b       	sbc	r25, r25
    45d2:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    45d6:	b8 01       	movw	r22, r16
    45d8:	7d 5e       	subi	r23, 0xED	; 237
    45da:	66 c0       	rjmp	.+204    	; 0x46a8 <setsockopt+0x13c>
         break;
      case SO_DESTIP:
         setSn_DIPR(sn, (uint8_t*)arg);
    45dc:	68 5f       	subi	r22, 0xF8	; 248
    45de:	73 4f       	sbci	r23, 0xF3	; 243
    45e0:	07 2e       	mov	r0, r23
    45e2:	00 0c       	add	r0, r0
    45e4:	88 0b       	sbc	r24, r24
    45e6:	99 0b       	sbc	r25, r25
    45e8:	24 e0       	ldi	r18, 0x04	; 4
    45ea:	30 e0       	ldi	r19, 0x00	; 0
    45ec:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
    45f0:	62 c0       	rjmp	.+196    	; 0x46b6 <setsockopt+0x14a>
         break;
      case SO_DESTPORT:
         setSn_DPORT(sn, *(uint16_t*)arg);
    45f2:	8b 01       	movw	r16, r22
    45f4:	08 5f       	subi	r16, 0xF8	; 248
    45f6:	1f 4f       	sbci	r17, 0xFF	; 255
    45f8:	49 81       	ldd	r20, Y+1	; 0x01
    45fa:	68 5f       	subi	r22, 0xF8	; 248
    45fc:	7f 4e       	sbci	r23, 0xEF	; 239
    45fe:	07 2e       	mov	r0, r23
    4600:	00 0c       	add	r0, r0
    4602:	88 0b       	sbc	r24, r24
    4604:	99 0b       	sbc	r25, r25
    4606:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    460a:	b8 01       	movw	r22, r16
    460c:	7f 5e       	subi	r23, 0xEF	; 239
    460e:	4c c0       	rjmp	.+152    	; 0x46a8 <setsockopt+0x13c>
         break;
#if _WIZCHIP_ != 5100
      case SO_KEEPALIVESEND:
         CHECK_SOCKMODE(Sn_MR_TCP);
    4610:	eb 01       	movw	r28, r22
    4612:	28 96       	adiw	r28, 0x08	; 8
    4614:	be 01       	movw	r22, r28
    4616:	0d 2e       	mov	r0, r29
    4618:	00 0c       	add	r0, r0
    461a:	88 0b       	sbc	r24, r24
    461c:	99 0b       	sbc	r25, r25
    461e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4622:	8f 70       	andi	r24, 0x0F	; 15
    4624:	81 30       	cpi	r24, 0x01	; 1
    4626:	11 f0       	breq	.+4      	; 0x462c <setsockopt+0xc0>
    4628:	8b ef       	ldi	r24, 0xFB	; 251
    462a:	4c c0       	rjmp	.+152    	; 0x46c4 <setsockopt+0x158>
         #if _WIZCHIP_ > 5200
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
    462c:	be 01       	movw	r22, r28
    462e:	71 5d       	subi	r23, 0xD1	; 209
    4630:	07 2e       	mov	r0, r23
    4632:	00 0c       	add	r0, r0
    4634:	88 0b       	sbc	r24, r24
    4636:	99 0b       	sbc	r25, r25
    4638:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    463c:	81 11       	cpse	r24, r1
    463e:	41 c0       	rjmp	.+130    	; 0x46c2 <setsockopt+0x156>
         #endif
            setSn_CR(sn,Sn_CR_SEND_KEEP);
    4640:	4e 01       	movw	r8, r28
    4642:	93 94       	inc	r9
    4644:	09 2c       	mov	r0, r9
    4646:	00 0c       	add	r0, r0
    4648:	aa 08       	sbc	r10, r10
    464a:	bb 08       	sbc	r11, r11
    464c:	42 e2       	ldi	r20, 0x22	; 34
    464e:	c5 01       	movw	r24, r10
    4650:	b4 01       	movw	r22, r8
    4652:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
            while(getSn_CR(sn) != 0)
            {
               // M20131220
         		//if ((tmp = getSn_IR(sn)) & Sn_IR_TIMEOUT)
               if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    4656:	6e 01       	movw	r12, r28
    4658:	8e ef       	ldi	r24, 0xFE	; 254
    465a:	d8 1a       	sub	r13, r24
    465c:	0d 2c       	mov	r0, r13
    465e:	00 0c       	add	r0, r0
    4660:	ee 08       	sbc	r14, r14
    4662:	ff 08       	sbc	r15, r15
         CHECK_SOCKMODE(Sn_MR_TCP);
         #if _WIZCHIP_ > 5200
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
         #endif
            setSn_CR(sn,Sn_CR_SEND_KEEP);
            while(getSn_CR(sn) != 0)
    4664:	c5 01       	movw	r24, r10
    4666:	b4 01       	movw	r22, r8
    4668:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    466c:	88 23       	and	r24, r24
    466e:	19 f1       	breq	.+70     	; 0x46b6 <setsockopt+0x14a>
            {
               // M20131220
         		//if ((tmp = getSn_IR(sn)) & Sn_IR_TIMEOUT)
               if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    4670:	c7 01       	movw	r24, r14
    4672:	b6 01       	movw	r22, r12
    4674:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4678:	83 ff       	sbrs	r24, 3
    467a:	f4 cf       	rjmp	.-24     	; 0x4664 <setsockopt+0xf8>
         		{
         			setSn_IR(sn, Sn_IR_TIMEOUT);
    467c:	48 e0       	ldi	r20, 0x08	; 8
    467e:	c7 01       	movw	r24, r14
    4680:	b6 01       	movw	r22, r12
    4682:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
                  return SOCKERR_TIMEOUT;
    4686:	83 ef       	ldi	r24, 0xF3	; 243
    4688:	1d c0       	rjmp	.+58     	; 0x46c4 <setsockopt+0x158>
         		}
            }
         break;
   #if _WIZCHIP_ > 5100
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
    468a:	8b 01       	movw	r16, r22
    468c:	08 5f       	subi	r16, 0xF8	; 248
    468e:	1f 4f       	sbci	r17, 0xFF	; 255
    4690:	b8 01       	movw	r22, r16
    4692:	01 2e       	mov	r0, r17
    4694:	00 0c       	add	r0, r0
    4696:	88 0b       	sbc	r24, r24
    4698:	99 0b       	sbc	r25, r25
    469a:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    469e:	8f 70       	andi	r24, 0x0F	; 15
    46a0:	81 30       	cpi	r24, 0x01	; 1
    46a2:	11 f6       	brne	.-124    	; 0x4628 <setsockopt+0xbc>
         setSn_KPALVTR(sn,*(uint8_t*)arg);
    46a4:	b8 01       	movw	r22, r16
    46a6:	71 5d       	subi	r23, 0xD1	; 209
    46a8:	07 2e       	mov	r0, r23
    46aa:	00 0c       	add	r0, r0
    46ac:	88 0b       	sbc	r24, r24
    46ae:	99 0b       	sbc	r25, r25
    46b0:	48 81       	ld	r20, Y
    46b2:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   #endif      
#endif   
      default:
         return SOCKERR_ARG;
   }   
   return SOCK_OK;
    46b6:	81 e0       	ldi	r24, 0x01	; 1
         break;
   #if _WIZCHIP_ > 5100
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
         setSn_KPALVTR(sn,*(uint8_t*)arg);
         break;
    46b8:	05 c0       	rjmp	.+10     	; 0x46c4 <setsockopt+0x158>

int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
 // M20131220 : Remove warning
 //uint8_t tmp;
   CHECK_SOCKNUM();
    46ba:	8f ef       	ldi	r24, 0xFF	; 255
    46bc:	03 c0       	rjmp	.+6      	; 0x46c4 <setsockopt+0x158>
         setSn_KPALVTR(sn,*(uint8_t*)arg);
         break;
   #endif      
#endif   
      default:
         return SOCKERR_ARG;
    46be:	86 ef       	ldi	r24, 0xF6	; 246
    46c0:	01 c0       	rjmp	.+2      	; 0x46c4 <setsockopt+0x158>
         break;
#if _WIZCHIP_ != 5100
      case SO_KEEPALIVESEND:
         CHECK_SOCKMODE(Sn_MR_TCP);
         #if _WIZCHIP_ > 5200
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
    46c2:	8e ef       	ldi	r24, 0xFE	; 254
#endif   
      default:
         return SOCKERR_ARG;
   }   
   return SOCK_OK;
}
    46c4:	df 91       	pop	r29
    46c6:	cf 91       	pop	r28
    46c8:	1f 91       	pop	r17
    46ca:	0f 91       	pop	r16
    46cc:	ff 90       	pop	r15
    46ce:	ef 90       	pop	r14
    46d0:	df 90       	pop	r13
    46d2:	cf 90       	pop	r12
    46d4:	bf 90       	pop	r11
    46d6:	af 90       	pop	r10
    46d8:	9f 90       	pop	r9
    46da:	8f 90       	pop	r8
    46dc:	08 95       	ret

000046de <getsockopt>:

int8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
    46de:	ef 92       	push	r14
    46e0:	ff 92       	push	r15
    46e2:	0f 93       	push	r16
    46e4:	1f 93       	push	r17
    46e6:	cf 93       	push	r28
    46e8:	df 93       	push	r29
    46ea:	c8 2f       	mov	r28, r24
   CHECK_SOCKNUM();
    46ec:	89 30       	cpi	r24, 0x09	; 9
    46ee:	08 f0       	brcs	.+2      	; 0x46f2 <getsockopt+0x14>
    46f0:	df c0       	rjmp	.+446    	; 0x48b0 <getsockopt+0x1d2>
   switch(sotype)
    46f2:	86 2f       	mov	r24, r22
    46f4:	90 e0       	ldi	r25, 0x00	; 0
    46f6:	8d 30       	cpi	r24, 0x0D	; 13
    46f8:	91 05       	cpc	r25, r1
    46fa:	08 f0       	brcs	.+2      	; 0x46fe <getsockopt+0x20>
    46fc:	db c0       	rjmp	.+438    	; 0x48b4 <getsockopt+0x1d6>
    46fe:	8a 01       	movw	r16, r20
    4700:	fc 01       	movw	r30, r24
    4702:	ed 5b       	subi	r30, 0xBD	; 189
    4704:	ff 4f       	sbci	r31, 0xFF	; 255
    4706:	0c 94 d9 2c 	jmp	0x59b2	; 0x59b2 <__tablejump2__>
   {
      case SO_FLAG:
         *(uint8_t*)arg = getSn_MR(sn) & 0xF0;
    470a:	84 e0       	ldi	r24, 0x04	; 4
    470c:	c8 9f       	mul	r28, r24
    470e:	e0 01       	movw	r28, r0
    4710:	11 24       	eor	r1, r1
    4712:	21 96       	adiw	r28, 0x01	; 1
    4714:	73 e0       	ldi	r23, 0x03	; 3
    4716:	cc 0f       	add	r28, r28
    4718:	dd 1f       	adc	r29, r29
    471a:	7a 95       	dec	r23
    471c:	e1 f7       	brne	.-8      	; 0x4716 <getsockopt+0x38>
    471e:	be 01       	movw	r22, r28
    4720:	dd 0f       	add	r29, r29
    4722:	88 0b       	sbc	r24, r24
    4724:	99 0b       	sbc	r25, r25
    4726:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    472a:	80 7f       	andi	r24, 0xF0	; 240
    472c:	bd c0       	rjmp	.+378    	; 0x48a8 <getsockopt+0x1ca>
         break;
      case SO_TTL:
         *(uint8_t*) arg = getSn_TTL(sn);
    472e:	f0 e2       	ldi	r31, 0x20	; 32
    4730:	cf 9f       	mul	r28, r31
    4732:	e0 01       	movw	r28, r0
    4734:	11 24       	eor	r1, r1
    4736:	c8 5f       	subi	r28, 0xF8	; 248
    4738:	d9 4e       	sbci	r29, 0xE9	; 233
    473a:	06 c0       	rjmp	.+12     	; 0x4748 <getsockopt+0x6a>
         break;
      case SO_TOS:
         *(uint8_t*) arg = getSn_TOS(sn);
    473c:	f0 e2       	ldi	r31, 0x20	; 32
    473e:	cf 9f       	mul	r28, r31
    4740:	e0 01       	movw	r28, r0
    4742:	11 24       	eor	r1, r1
    4744:	c8 5f       	subi	r28, 0xF8	; 248
    4746:	da 4e       	sbci	r29, 0xEA	; 234
    4748:	be 01       	movw	r22, r28
    474a:	dd 0f       	add	r29, r29
    474c:	88 0b       	sbc	r24, r24
    474e:	99 0b       	sbc	r25, r25
    4750:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4754:	a9 c0       	rjmp	.+338    	; 0x48a8 <getsockopt+0x1ca>
         break;
      case SO_MSS:   
         *(uint16_t*) arg = getSn_MSSR(sn);
    4756:	f4 e0       	ldi	r31, 0x04	; 4
    4758:	cf 9f       	mul	r28, r31
    475a:	e0 01       	movw	r28, r0
    475c:	11 24       	eor	r1, r1
    475e:	21 96       	adiw	r28, 0x01	; 1
    4760:	63 e0       	ldi	r22, 0x03	; 3
    4762:	cc 0f       	add	r28, r28
    4764:	dd 1f       	adc	r29, r29
    4766:	6a 95       	dec	r22
    4768:	e1 f7       	brne	.-8      	; 0x4762 <getsockopt+0x84>
    476a:	be 01       	movw	r22, r28
    476c:	7e 5e       	subi	r23, 0xEE	; 238
    476e:	07 2e       	mov	r0, r23
    4770:	00 0c       	add	r0, r0
    4772:	88 0b       	sbc	r24, r24
    4774:	99 0b       	sbc	r25, r25
    4776:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    477a:	f8 2e       	mov	r15, r24
    477c:	dd 5e       	subi	r29, 0xED	; 237
    477e:	23 c0       	rjmp	.+70     	; 0x47c6 <getsockopt+0xe8>
         break;
      case SO_DESTIP:
         getSn_DIPR(sn, (uint8_t*)arg);
    4780:	f0 e2       	ldi	r31, 0x20	; 32
    4782:	cf 9f       	mul	r28, r31
    4784:	e0 01       	movw	r28, r0
    4786:	11 24       	eor	r1, r1
    4788:	c8 5f       	subi	r28, 0xF8	; 248
    478a:	d3 4f       	sbci	r29, 0xF3	; 243
    478c:	be 01       	movw	r22, r28
    478e:	dd 0f       	add	r29, r29
    4790:	88 0b       	sbc	r24, r24
    4792:	99 0b       	sbc	r25, r25
    4794:	24 e0       	ldi	r18, 0x04	; 4
    4796:	30 e0       	ldi	r19, 0x00	; 0
    4798:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
    479c:	87 c0       	rjmp	.+270    	; 0x48ac <getsockopt+0x1ce>
         break;
      case SO_DESTPORT:  
         *(uint16_t*) arg = getSn_DPORT(sn);
    479e:	84 e0       	ldi	r24, 0x04	; 4
    47a0:	c8 9f       	mul	r28, r24
    47a2:	e0 01       	movw	r28, r0
    47a4:	11 24       	eor	r1, r1
    47a6:	21 96       	adiw	r28, 0x01	; 1
    47a8:	53 e0       	ldi	r21, 0x03	; 3
    47aa:	cc 0f       	add	r28, r28
    47ac:	dd 1f       	adc	r29, r29
    47ae:	5a 95       	dec	r21
    47b0:	e1 f7       	brne	.-8      	; 0x47aa <getsockopt+0xcc>
    47b2:	be 01       	movw	r22, r28
    47b4:	70 5f       	subi	r23, 0xF0	; 240
    47b6:	07 2e       	mov	r0, r23
    47b8:	00 0c       	add	r0, r0
    47ba:	88 0b       	sbc	r24, r24
    47bc:	99 0b       	sbc	r25, r25
    47be:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    47c2:	f8 2e       	mov	r15, r24
    47c4:	df 5e       	subi	r29, 0xEF	; 239
    47c6:	be 01       	movw	r22, r28
    47c8:	dd 0f       	add	r29, r29
    47ca:	88 0b       	sbc	r24, r24
    47cc:	99 0b       	sbc	r25, r25
    47ce:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    47d2:	2f 2d       	mov	r18, r15
    47d4:	30 e0       	ldi	r19, 0x00	; 0
    47d6:	32 2f       	mov	r19, r18
    47d8:	22 27       	eor	r18, r18
    47da:	28 0f       	add	r18, r24
    47dc:	31 1d       	adc	r19, r1
    47de:	f8 01       	movw	r30, r16
    47e0:	31 83       	std	Z+1, r19	; 0x01
    47e2:	20 83       	st	Z, r18
    47e4:	63 c0       	rjmp	.+198    	; 0x48ac <getsockopt+0x1ce>
         break;
   #if _WIZCHIP_ > 5200   
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
    47e6:	f4 e0       	ldi	r31, 0x04	; 4
    47e8:	cf 9f       	mul	r28, r31
    47ea:	e0 01       	movw	r28, r0
    47ec:	11 24       	eor	r1, r1
    47ee:	21 96       	adiw	r28, 0x01	; 1
    47f0:	33 e0       	ldi	r19, 0x03	; 3
    47f2:	cc 0f       	add	r28, r28
    47f4:	dd 1f       	adc	r29, r29
    47f6:	3a 95       	dec	r19
    47f8:	e1 f7       	brne	.-8      	; 0x47f2 <getsockopt+0x114>
    47fa:	be 01       	movw	r22, r28
    47fc:	0d 2e       	mov	r0, r29
    47fe:	00 0c       	add	r0, r0
    4800:	88 0b       	sbc	r24, r24
    4802:	99 0b       	sbc	r25, r25
    4804:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4808:	8f 70       	andi	r24, 0x0F	; 15
    480a:	81 30       	cpi	r24, 0x01	; 1
    480c:	11 f0       	breq	.+4      	; 0x4812 <getsockopt+0x134>
    480e:	8b ef       	ldi	r24, 0xFB	; 251
    4810:	52 c0       	rjmp	.+164    	; 0x48b6 <getsockopt+0x1d8>
         *(uint16_t*) arg = getSn_KPALVTR(sn);
    4812:	be 01       	movw	r22, r28
    4814:	71 5d       	subi	r23, 0xD1	; 209
    4816:	07 2e       	mov	r0, r23
    4818:	00 0c       	add	r0, r0
    481a:	88 0b       	sbc	r24, r24
    481c:	99 0b       	sbc	r25, r25
    481e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4822:	90 e0       	ldi	r25, 0x00	; 0
    4824:	28 c0       	rjmp	.+80     	; 0x4876 <getsockopt+0x198>
         break;
   #endif      
      case SO_SENDBUF:
         *(uint16_t*) arg = getSn_TX_FSR(sn);
    4826:	8c 2f       	mov	r24, r28
    4828:	0e 94 5e 2a 	call	0x54bc	; 0x54bc <getSn_TX_FSR>
    482c:	24 c0       	rjmp	.+72     	; 0x4876 <getsockopt+0x198>
         break;
      case SO_RECVBUF:
         *(uint16_t*) arg = getSn_RX_RSR(sn);
         break;
      case SO_STATUS:
         *(uint8_t*) arg = getSn_SR(sn);
    482e:	f0 e2       	ldi	r31, 0x20	; 32
    4830:	cf 9f       	mul	r28, r31
    4832:	e0 01       	movw	r28, r0
    4834:	11 24       	eor	r1, r1
    4836:	c8 5f       	subi	r28, 0xF8	; 248
    4838:	dc 4f       	sbci	r29, 0xFC	; 252
    483a:	86 cf       	rjmp	.-244    	; 0x4748 <getsockopt+0x6a>
         break;
      case SO_REMAINSIZE:
         if(getSn_MR(sn) & Sn_MR_TCP)
    483c:	ec 2e       	mov	r14, r28
    483e:	f1 2c       	mov	r15, r1
    4840:	b7 01       	movw	r22, r14
    4842:	25 e0       	ldi	r18, 0x05	; 5
    4844:	66 0f       	add	r22, r22
    4846:	77 1f       	adc	r23, r23
    4848:	2a 95       	dec	r18
    484a:	e1 f7       	brne	.-8      	; 0x4844 <getsockopt+0x166>
    484c:	68 5f       	subi	r22, 0xF8	; 248
    484e:	7f 4f       	sbci	r23, 0xFF	; 255
    4850:	07 2e       	mov	r0, r23
    4852:	00 0c       	add	r0, r0
    4854:	88 0b       	sbc	r24, r24
    4856:	99 0b       	sbc	r25, r25
    4858:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    485c:	80 ff       	sbrs	r24, 0
    485e:	04 c0       	rjmp	.+8      	; 0x4868 <getsockopt+0x18a>
            *(uint16_t*)arg = getSn_RX_RSR(sn);
    4860:	8c 2f       	mov	r24, r28
    4862:	0e 94 b6 2a 	call	0x556c	; 0x556c <getSn_RX_RSR>
    4866:	07 c0       	rjmp	.+14     	; 0x4876 <getsockopt+0x198>
         else
            *(uint16_t*)arg = sock_remained_size[sn];
    4868:	f7 01       	movw	r30, r14
    486a:	ee 0f       	add	r30, r30
    486c:	ff 1f       	adc	r31, r31
    486e:	e6 52       	subi	r30, 0x26	; 38
    4870:	f9 4f       	sbci	r31, 0xF9	; 249
    4872:	80 81       	ld	r24, Z
    4874:	91 81       	ldd	r25, Z+1	; 0x01
    4876:	f8 01       	movw	r30, r16
    4878:	91 83       	std	Z+1, r25	; 0x01
    487a:	80 83       	st	Z, r24
    487c:	17 c0       	rjmp	.+46     	; 0x48ac <getsockopt+0x1ce>
         break;
      case SO_PACKINFO:
         //CHECK_SOCKMODE(Sn_MR_TCP);
#if _WIZCHIP_ != 5300
         if((getSn_MR(sn) == Sn_MR_TCP))
    487e:	d0 e0       	ldi	r29, 0x00	; 0
    4880:	be 01       	movw	r22, r28
    4882:	85 e0       	ldi	r24, 0x05	; 5
    4884:	66 0f       	add	r22, r22
    4886:	77 1f       	adc	r23, r23
    4888:	8a 95       	dec	r24
    488a:	e1 f7       	brne	.-8      	; 0x4884 <getsockopt+0x1a6>
    488c:	68 5f       	subi	r22, 0xF8	; 248
    488e:	7f 4f       	sbci	r23, 0xFF	; 255
    4890:	07 2e       	mov	r0, r23
    4892:	00 0c       	add	r0, r0
    4894:	88 0b       	sbc	r24, r24
    4896:	99 0b       	sbc	r25, r25
    4898:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    489c:	81 30       	cpi	r24, 0x01	; 1
    489e:	09 f4       	brne	.+2      	; 0x48a2 <getsockopt+0x1c4>
    48a0:	b6 cf       	rjmp	.-148    	; 0x480e <getsockopt+0x130>
             return SOCKERR_SOCKMODE;
#endif
         *(uint8_t*)arg = sock_pack_info[sn];
    48a2:	ce 52       	subi	r28, 0x2E	; 46
    48a4:	d9 4f       	sbci	r29, 0xF9	; 249
    48a6:	88 81       	ld	r24, Y
    48a8:	f8 01       	movw	r30, r16
    48aa:	80 83       	st	Z, r24
         break;
      default:
         return SOCKERR_SOCKOPT;
   }
   return SOCK_OK;
    48ac:	81 e0       	ldi	r24, 0x01	; 1
#if _WIZCHIP_ != 5300
         if((getSn_MR(sn) == Sn_MR_TCP))
             return SOCKERR_SOCKMODE;
#endif
         *(uint8_t*)arg = sock_pack_info[sn];
         break;
    48ae:	03 c0       	rjmp	.+6      	; 0x48b6 <getsockopt+0x1d8>
   return SOCK_OK;
}

int8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
   CHECK_SOCKNUM();
    48b0:	8f ef       	ldi	r24, 0xFF	; 255
    48b2:	01 c0       	rjmp	.+2      	; 0x48b6 <getsockopt+0x1d8>
             return SOCKERR_SOCKMODE;
#endif
         *(uint8_t*)arg = sock_pack_info[sn];
         break;
      default:
         return SOCKERR_SOCKOPT;
    48b4:	8e ef       	ldi	r24, 0xFE	; 254
   }
   return SOCK_OK;
}
    48b6:	df 91       	pop	r29
    48b8:	cf 91       	pop	r28
    48ba:	1f 91       	pop	r17
    48bc:	0f 91       	pop	r16
    48be:	ff 90       	pop	r15
    48c0:	ef 90       	pop	r14
    48c2:	08 95       	ret

000048c4 <wizchip_cris_exit>:
 * @brief Default function to disable interrupt.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	  wizchip_cris_exit(void)          {};
void 	  wizchip_cris_exit(void)          {}
    48c4:	08 95       	ret

000048c6 <wizchip_cs_select>:
 * null function is called.
 */
//void 	wizchip_cs_select(void)            {};
void 	wizchip_cs_select(void)
{
    PORTB &= ~(1 << PB6); //pull SS low
    48c6:	2e 98       	cbi	0x05, 6	; 5
    48c8:	08 95       	ret

000048ca <wizchip_cs_deselect>:
 * null function is called.
 */
//void 	wizchip_cs_deselect(void)          {};
void 	wizchip_cs_deselect(void)
{
    PORTB |= (1 << PB6); //pull SS high 
    48ca:	2e 9a       	sbi	0x05, 6	; 5
    48cc:	08 95       	ret

000048ce <wizchip_bus_readdata>:
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
 //M20150601 : Rename the function for integrating with W5300
//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); }
iodata_t wizchip_bus_readdata(uint32_t AddrSel) { return * ((volatile iodata_t *)((ptrdiff_t) AddrSel)); }
    48ce:	fb 01       	movw	r30, r22
    48d0:	80 81       	ld	r24, Z
    48d2:	08 95       	ret

000048d4 <wizchip_bus_writedata>:
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//M20150601 : Rename the function for integrating with W5300
//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; }
void 	wizchip_bus_writedata(uint32_t AddrSel, iodata_t wb)  { *((volatile iodata_t*)((ptrdiff_t)AddrSel)) = wb; }
    48d4:	fb 01       	movw	r30, r22
    48d6:	40 83       	st	Z, r20
    48d8:	08 95       	ret

000048da <wizchip_spi_readbyte>:
 * null function is called.
 */
//uint8_t wizchip_spi_readbyte(void)        {return 0;};
uint8_t wizchip_spi_readbyte(void)        
{
    SPDR = 0x00; //get it to talk
    48da:	1e bc       	out	0x2e, r1	; 46
    while(bit_is_clear(SPSR, SPIF)) {} //spin until transfer complete
    48dc:	0d b4       	in	r0, 0x2d	; 45
    48de:	07 fe       	sbrs	r0, 7
    48e0:	fd cf       	rjmp	.-6      	; 0x48dc <wizchip_spi_readbyte+0x2>
    return SPDR;
    48e2:	8e b5       	in	r24, 0x2e	; 46
}
    48e4:	08 95       	ret

000048e6 <wizchip_spi_writebyte>:
 * null function is called.
 */
//void 	wizchip_spi_writebyte(uint8_t wb) {};
void 	wizchip_spi_writebyte(uint8_t wb) 
{
    SPDR = wb;
    48e6:	8e bd       	out	0x2e, r24	; 46
    while(bit_is_clear(SPSR, SPIF)) {} //spin until transfer complete
    48e8:	0d b4       	in	r0, 0x2d	; 45
    48ea:	07 fe       	sbrs	r0, 7
    48ec:	fd cf       	rjmp	.-6      	; 0x48e8 <wizchip_spi_writebyte+0x2>
}
    48ee:	08 95       	ret

000048f0 <wizchip_spi_writeburst>:
 * @brief Default function to burst write in SPI interface.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {};
void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {}
    48f0:	08 95       	ret

000048f2 <wizchip_spi_readburst>:
    48f2:	08 95       	ret

000048f4 <wizchip_cris_enter>:
    48f4:	08 95       	ret

000048f6 <reg_wizchip_cris_cbfunc>:
static uint8_t    _DNS_[4];      // DNS server ip address
static dhcp_mode  _DHCP_;        // DHCP mode

void reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void))
{
   if(!cris_en || !cris_ex)
    48f6:	00 97       	sbiw	r24, 0x00	; 0
    48f8:	19 f0       	breq	.+6      	; 0x4900 <reg_wizchip_cris_cbfunc+0xa>
    48fa:	61 15       	cp	r22, r1
    48fc:	71 05       	cpc	r23, r1
    48fe:	69 f4       	brne	.+26     	; 0x491a <reg_wizchip_cris_cbfunc+0x24>
   {
      WIZCHIP.CRIS._enter = wizchip_cris_enter;
    4900:	8a e7       	ldi	r24, 0x7A	; 122
    4902:	94 e2       	ldi	r25, 0x24	; 36
    4904:	90 93 0e 01 	sts	0x010E, r25	; 0x80010e <WIZCHIP+0xa>
    4908:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <WIZCHIP+0x9>
      WIZCHIP.CRIS._exit  = wizchip_cris_exit;
    490c:	82 e6       	ldi	r24, 0x62	; 98
    490e:	94 e2       	ldi	r25, 0x24	; 36
    4910:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <WIZCHIP+0xc>
    4914:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <WIZCHIP+0xb>
    4918:	08 95       	ret
   }
   else
   {
      WIZCHIP.CRIS._enter = cris_en;
    491a:	90 93 0e 01 	sts	0x010E, r25	; 0x80010e <WIZCHIP+0xa>
    491e:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <WIZCHIP+0x9>
      WIZCHIP.CRIS._exit  = cris_ex;
    4922:	70 93 10 01 	sts	0x0110, r23	; 0x800110 <WIZCHIP+0xc>
    4926:	60 93 0f 01 	sts	0x010F, r22	; 0x80010f <WIZCHIP+0xb>
    492a:	08 95       	ret

0000492c <reg_wizchip_cs_cbfunc>:
   }
}

void reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void))
{
   if(!cs_sel || !cs_desel)
    492c:	00 97       	sbiw	r24, 0x00	; 0
    492e:	19 f0       	breq	.+6      	; 0x4936 <reg_wizchip_cs_cbfunc+0xa>
    4930:	61 15       	cp	r22, r1
    4932:	71 05       	cpc	r23, r1
    4934:	69 f4       	brne	.+26     	; 0x4950 <reg_wizchip_cs_cbfunc+0x24>
   {
      WIZCHIP.CS._select   = wizchip_cs_select;
    4936:	83 e6       	ldi	r24, 0x63	; 99
    4938:	94 e2       	ldi	r25, 0x24	; 36
    493a:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <WIZCHIP+0xe>
    493e:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <WIZCHIP+0xd>
      WIZCHIP.CS._deselect = wizchip_cs_deselect;
    4942:	85 e6       	ldi	r24, 0x65	; 101
    4944:	94 e2       	ldi	r25, 0x24	; 36
    4946:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <WIZCHIP+0x10>
    494a:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <WIZCHIP+0xf>
    494e:	08 95       	ret
   }
   else
   {
      WIZCHIP.CS._select   = cs_sel;
    4950:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <WIZCHIP+0xe>
    4954:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <WIZCHIP+0xd>
      WIZCHIP.CS._deselect = cs_desel;
    4958:	70 93 14 01 	sts	0x0114, r23	; 0x800114 <WIZCHIP+0x10>
    495c:	60 93 13 01 	sts	0x0113, r22	; 0x800113 <WIZCHIP+0xf>
    4960:	08 95       	ret

00004962 <reg_wizchip_bus_cbfunc>:

//M20150515 : For integrating with W5300
//void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb))
void reg_wizchip_bus_cbfunc(iodata_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, iodata_t wb))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_BUS_));
    4962:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <WIZCHIP>
    4966:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <WIZCHIP+0x1>
    496a:	22 27       	eor	r18, r18
    496c:	31 70       	andi	r19, 0x01	; 1
    496e:	21 15       	cp	r18, r1
    4970:	31 05       	cpc	r19, r1
    4972:	e9 f3       	breq	.-6      	; 0x496e <reg_wizchip_bus_cbfunc+0xc>
   {
      WIZCHIP.IF.BUS._read_byte   = bus_rb;
      WIZCHIP.IF.BUS._write_byte  = bus_wb;
   }
   */
   if(!bus_rb || !bus_wb)
    4974:	00 97       	sbiw	r24, 0x00	; 0
    4976:	19 f0       	breq	.+6      	; 0x497e <reg_wizchip_bus_cbfunc+0x1c>
    4978:	61 15       	cp	r22, r1
    497a:	71 05       	cpc	r23, r1
    497c:	69 f4       	brne	.+26     	; 0x4998 <reg_wizchip_bus_cbfunc+0x36>
   {
      WIZCHIP.IF.BUS._read_data   = wizchip_bus_readdata;
    497e:	87 e6       	ldi	r24, 0x67	; 103
    4980:	94 e2       	ldi	r25, 0x24	; 36
    4982:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    4986:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.BUS._write_data  = wizchip_bus_writedata;
    498a:	8a e6       	ldi	r24, 0x6A	; 106
    498c:	94 e2       	ldi	r25, 0x24	; 36
    498e:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <WIZCHIP+0x14>
    4992:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <WIZCHIP+0x13>
    4996:	08 95       	ret
   }
   else
   {
      WIZCHIP.IF.BUS._read_data   = bus_rb;
    4998:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    499c:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.BUS._write_data  = bus_wb;
    49a0:	70 93 18 01 	sts	0x0118, r23	; 0x800118 <WIZCHIP+0x14>
    49a4:	60 93 17 01 	sts	0x0117, r22	; 0x800117 <WIZCHIP+0x13>
    49a8:	08 95       	ret

000049aa <reg_wizchip_spi_cbfunc>:
   }
}

void reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
    49aa:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <WIZCHIP>
    49ae:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <WIZCHIP+0x1>
    49b2:	22 27       	eor	r18, r18
    49b4:	32 70       	andi	r19, 0x02	; 2
    49b6:	21 15       	cp	r18, r1
    49b8:	31 05       	cpc	r19, r1
    49ba:	e9 f3       	breq	.-6      	; 0x49b6 <reg_wizchip_spi_cbfunc+0xc>
   
   if(!spi_rb || !spi_wb)
    49bc:	00 97       	sbiw	r24, 0x00	; 0
    49be:	19 f0       	breq	.+6      	; 0x49c6 <reg_wizchip_spi_cbfunc+0x1c>
    49c0:	61 15       	cp	r22, r1
    49c2:	71 05       	cpc	r23, r1
    49c4:	69 f4       	brne	.+26     	; 0x49e0 <reg_wizchip_spi_cbfunc+0x36>
   {
      WIZCHIP.IF.SPI._read_byte   = wizchip_spi_readbyte;
    49c6:	8d e6       	ldi	r24, 0x6D	; 109
    49c8:	94 e2       	ldi	r25, 0x24	; 36
    49ca:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    49ce:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.SPI._write_byte  = wizchip_spi_writebyte;
    49d2:	83 e7       	ldi	r24, 0x73	; 115
    49d4:	94 e2       	ldi	r25, 0x24	; 36
    49d6:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <WIZCHIP+0x14>
    49da:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <WIZCHIP+0x13>
    49de:	08 95       	ret
   }
   else
   {
      WIZCHIP.IF.SPI._read_byte   = spi_rb;
    49e0:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    49e4:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.SPI._write_byte  = spi_wb;
    49e8:	70 93 18 01 	sts	0x0118, r23	; 0x800118 <WIZCHIP+0x14>
    49ec:	60 93 17 01 	sts	0x0117, r22	; 0x800117 <WIZCHIP+0x13>
    49f0:	08 95       	ret

000049f2 <reg_wizchip_spiburst_cbfunc>:
}

// 20140626 Eric Added for SPI burst operations
void reg_wizchip_spiburst_cbfunc(void (*spi_rb)(uint8_t* pBuf, uint16_t len), void (*spi_wb)(uint8_t* pBuf, uint16_t len))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
    49f2:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <WIZCHIP>
    49f6:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <WIZCHIP+0x1>
    49fa:	22 27       	eor	r18, r18
    49fc:	32 70       	andi	r19, 0x02	; 2
    49fe:	21 15       	cp	r18, r1
    4a00:	31 05       	cpc	r19, r1
    4a02:	e9 f3       	breq	.-6      	; 0x49fe <reg_wizchip_spiburst_cbfunc+0xc>

   if(!spi_rb || !spi_wb)
    4a04:	00 97       	sbiw	r24, 0x00	; 0
    4a06:	19 f0       	breq	.+6      	; 0x4a0e <reg_wizchip_spiburst_cbfunc+0x1c>
    4a08:	61 15       	cp	r22, r1
    4a0a:	71 05       	cpc	r23, r1
    4a0c:	69 f4       	brne	.+26     	; 0x4a28 <reg_wizchip_spiburst_cbfunc+0x36>
   {
      WIZCHIP.IF.SPI._read_burst   = wizchip_spi_readburst;
    4a0e:	89 e7       	ldi	r24, 0x79	; 121
    4a10:	94 e2       	ldi	r25, 0x24	; 36
    4a12:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <WIZCHIP+0x16>
    4a16:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <WIZCHIP+0x15>
      WIZCHIP.IF.SPI._write_burst  = wizchip_spi_writeburst;
    4a1a:	88 e7       	ldi	r24, 0x78	; 120
    4a1c:	94 e2       	ldi	r25, 0x24	; 36
    4a1e:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <WIZCHIP+0x18>
    4a22:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <WIZCHIP+0x17>
    4a26:	08 95       	ret
   }
   else
   {
      WIZCHIP.IF.SPI._read_burst   = spi_rb;
    4a28:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <WIZCHIP+0x16>
    4a2c:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <WIZCHIP+0x15>
      WIZCHIP.IF.SPI._write_burst  = spi_wb;
    4a30:	70 93 1c 01 	sts	0x011C, r23	; 0x80011c <WIZCHIP+0x18>
    4a34:	60 93 1b 01 	sts	0x011B, r22	; 0x80011b <WIZCHIP+0x17>
    4a38:	08 95       	ret

00004a3a <wizchip_sw_reset>:
   }
   return 0;
}

void wizchip_sw_reset(void)
{
    4a3a:	cf 93       	push	r28
    4a3c:	df 93       	push	r29
    4a3e:	cd b7       	in	r28, 0x3d	; 61
    4a40:	de b7       	in	r29, 0x3e	; 62
    4a42:	62 97       	sbiw	r28, 0x12	; 18
    4a44:	0f b6       	in	r0, 0x3f	; 63
    4a46:	f8 94       	cli
    4a48:	de bf       	out	0x3e, r29	; 62
    4a4a:	0f be       	out	0x3f, r0	; 63
    4a4c:	cd bf       	out	0x3d, r28	; 61
#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
   uint16_t mr = (uint16_t)getMR();
   setMR(mr | MR_IND);
#endif
//
   getSHAR(mac);
    4a4e:	26 e0       	ldi	r18, 0x06	; 6
    4a50:	30 e0       	ldi	r19, 0x00	; 0
    4a52:	ae 01       	movw	r20, r28
    4a54:	4f 5f       	subi	r20, 0xFF	; 255
    4a56:	5f 4f       	sbci	r21, 0xFF	; 255
    4a58:	60 e0       	ldi	r22, 0x00	; 0
    4a5a:	79 e0       	ldi	r23, 0x09	; 9
    4a5c:	80 e0       	ldi	r24, 0x00	; 0
    4a5e:	90 e0       	ldi	r25, 0x00	; 0
    4a60:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
   getGAR(gw);  getSUBR(sn);  getSIPR(sip);
    4a64:	24 e0       	ldi	r18, 0x04	; 4
    4a66:	30 e0       	ldi	r19, 0x00	; 0
    4a68:	ae 01       	movw	r20, r28
    4a6a:	41 5f       	subi	r20, 0xF1	; 241
    4a6c:	5f 4f       	sbci	r21, 0xFF	; 255
    4a6e:	60 e0       	ldi	r22, 0x00	; 0
    4a70:	71 e0       	ldi	r23, 0x01	; 1
    4a72:	80 e0       	ldi	r24, 0x00	; 0
    4a74:	90 e0       	ldi	r25, 0x00	; 0
    4a76:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
    4a7a:	24 e0       	ldi	r18, 0x04	; 4
    4a7c:	30 e0       	ldi	r19, 0x00	; 0
    4a7e:	ae 01       	movw	r20, r28
    4a80:	45 5f       	subi	r20, 0xF5	; 245
    4a82:	5f 4f       	sbci	r21, 0xFF	; 255
    4a84:	60 e0       	ldi	r22, 0x00	; 0
    4a86:	75 e0       	ldi	r23, 0x05	; 5
    4a88:	80 e0       	ldi	r24, 0x00	; 0
    4a8a:	90 e0       	ldi	r25, 0x00	; 0
    4a8c:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
    4a90:	24 e0       	ldi	r18, 0x04	; 4
    4a92:	30 e0       	ldi	r19, 0x00	; 0
    4a94:	ae 01       	movw	r20, r28
    4a96:	49 5f       	subi	r20, 0xF9	; 249
    4a98:	5f 4f       	sbci	r21, 0xFF	; 255
    4a9a:	60 e0       	ldi	r22, 0x00	; 0
    4a9c:	7f e0       	ldi	r23, 0x0F	; 15
    4a9e:	80 e0       	ldi	r24, 0x00	; 0
    4aa0:	90 e0       	ldi	r25, 0x00	; 0
    4aa2:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
   setMR(MR_RST);
    4aa6:	40 e8       	ldi	r20, 0x80	; 128
    4aa8:	60 e0       	ldi	r22, 0x00	; 0
    4aaa:	70 e0       	ldi	r23, 0x00	; 0
    4aac:	cb 01       	movw	r24, r22
    4aae:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   getMR(); // for delay
    4ab2:	60 e0       	ldi	r22, 0x00	; 0
    4ab4:	70 e0       	ldi	r23, 0x00	; 0
    4ab6:	cb 01       	movw	r24, r22
    4ab8:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
//A2015051 : For indirect bus mode 
#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
   setMR(mr | MR_IND);
#endif
//
   setSHAR(mac);
    4abc:	26 e0       	ldi	r18, 0x06	; 6
    4abe:	30 e0       	ldi	r19, 0x00	; 0
    4ac0:	ae 01       	movw	r20, r28
    4ac2:	4f 5f       	subi	r20, 0xFF	; 255
    4ac4:	5f 4f       	sbci	r21, 0xFF	; 255
    4ac6:	60 e0       	ldi	r22, 0x00	; 0
    4ac8:	79 e0       	ldi	r23, 0x09	; 9
    4aca:	80 e0       	ldi	r24, 0x00	; 0
    4acc:	90 e0       	ldi	r25, 0x00	; 0
    4ace:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   setGAR(gw);
    4ad2:	24 e0       	ldi	r18, 0x04	; 4
    4ad4:	30 e0       	ldi	r19, 0x00	; 0
    4ad6:	ae 01       	movw	r20, r28
    4ad8:	41 5f       	subi	r20, 0xF1	; 241
    4ada:	5f 4f       	sbci	r21, 0xFF	; 255
    4adc:	60 e0       	ldi	r22, 0x00	; 0
    4ade:	71 e0       	ldi	r23, 0x01	; 1
    4ae0:	80 e0       	ldi	r24, 0x00	; 0
    4ae2:	90 e0       	ldi	r25, 0x00	; 0
    4ae4:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   setSUBR(sn);
    4ae8:	24 e0       	ldi	r18, 0x04	; 4
    4aea:	30 e0       	ldi	r19, 0x00	; 0
    4aec:	ae 01       	movw	r20, r28
    4aee:	45 5f       	subi	r20, 0xF5	; 245
    4af0:	5f 4f       	sbci	r21, 0xFF	; 255
    4af2:	60 e0       	ldi	r22, 0x00	; 0
    4af4:	75 e0       	ldi	r23, 0x05	; 5
    4af6:	80 e0       	ldi	r24, 0x00	; 0
    4af8:	90 e0       	ldi	r25, 0x00	; 0
    4afa:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   setSIPR(sip);
    4afe:	24 e0       	ldi	r18, 0x04	; 4
    4b00:	30 e0       	ldi	r19, 0x00	; 0
    4b02:	ae 01       	movw	r20, r28
    4b04:	49 5f       	subi	r20, 0xF9	; 249
    4b06:	5f 4f       	sbci	r21, 0xFF	; 255
    4b08:	60 e0       	ldi	r22, 0x00	; 0
    4b0a:	7f e0       	ldi	r23, 0x0F	; 15
    4b0c:	80 e0       	ldi	r24, 0x00	; 0
    4b0e:	90 e0       	ldi	r25, 0x00	; 0
    4b10:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
}
    4b14:	62 96       	adiw	r28, 0x12	; 18
    4b16:	0f b6       	in	r0, 0x3f	; 63
    4b18:	f8 94       	cli
    4b1a:	de bf       	out	0x3e, r29	; 62
    4b1c:	0f be       	out	0x3f, r0	; 63
    4b1e:	cd bf       	out	0x3d, r28	; 61
    4b20:	df 91       	pop	r29
    4b22:	cf 91       	pop	r28
    4b24:	08 95       	ret

00004b26 <wizchip_init>:

int8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize)
{
    4b26:	ef 92       	push	r14
    4b28:	ff 92       	push	r15
    4b2a:	0f 93       	push	r16
    4b2c:	1f 93       	push	r17
    4b2e:	cf 93       	push	r28
    4b30:	df 93       	push	r29
    4b32:	ec 01       	movw	r28, r24
    4b34:	7b 01       	movw	r14, r22
   int8_t i;
#if _WIZCHIP_ < W5200
   int8_t j;
#endif
   int8_t tmp = 0;
   wizchip_sw_reset();
    4b36:	0e 94 1d 25 	call	0x4a3a	; 0x4a3a <wizchip_sw_reset>
   if(txsize)
    4b3a:	20 97       	sbiw	r28, 0x00	; 0
    4b3c:	21 f4       	brne	.+8      	; 0x4b46 <wizchip_init+0x20>
		}

	#endif
   }

   if(rxsize)
    4b3e:	e1 14       	cp	r14, r1
    4b40:	f1 04       	cpc	r15, r1
    4b42:	29 f5       	brne	.+74     	; 0x4b8e <wizchip_init+0x68>
    4b44:	46 c0       	rjmp	.+140    	; 0x4bd2 <wizchip_init+0xac>
    4b46:	9e 01       	movw	r18, r28
    4b48:	28 5f       	subi	r18, 0xF8	; 248
    4b4a:	3f 4f       	sbci	r19, 0xFF	; 255
#if _WIZCHIP_ < W5200
   int8_t j;
#endif
   int8_t tmp = 0;
   wizchip_sw_reset();
   if(txsize)
    4b4c:	fe 01       	movw	r30, r28
    4b4e:	80 e0       	ldi	r24, 0x00	; 0
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
		{
			tmp += txsize[i];
    4b50:	91 91       	ld	r25, Z+
    4b52:	89 0f       	add	r24, r25

		#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100 and w5100s
			if(tmp > 8) return -1;
		#else
			if(tmp > 16) return -1;
    4b54:	81 31       	cpi	r24, 0x11	; 17
    4b56:	14 f0       	brlt	.+4      	; 0x4b5c <wizchip_init+0x36>
    4b58:	8f ef       	ldi	r24, 0xFF	; 255
    4b5a:	3c c0       	rjmp	.+120    	; 0x4bd4 <wizchip_init+0xae>
			tmp += txsize[i];
			if(tmp > 128) return -1;
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    4b5c:	e2 17       	cp	r30, r18
    4b5e:	f3 07       	cpc	r31, r19
    4b60:	b9 f7       	brne	.-18     	; 0x4b50 <wizchip_init+0x2a>
    4b62:	01 e0       	ldi	r16, 0x01	; 1
    4b64:	10 e0       	ldi	r17, 0x00	; 0
		#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100
			j = 0;
			while((txsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
			setSn_TXBUF_SIZE(i, j);
		#else
			setSn_TXBUF_SIZE(i, txsize[i]);
    4b66:	49 91       	ld	r20, Y+
    4b68:	b8 01       	movw	r22, r16
    4b6a:	93 e0       	ldi	r25, 0x03	; 3
    4b6c:	66 0f       	add	r22, r22
    4b6e:	77 1f       	adc	r23, r23
    4b70:	9a 95       	dec	r25
    4b72:	e1 f7       	brne	.-8      	; 0x4b6c <wizchip_init+0x46>
    4b74:	71 5e       	subi	r23, 0xE1	; 225
    4b76:	07 2e       	mov	r0, r23
    4b78:	00 0c       	add	r0, r0
    4b7a:	88 0b       	sbc	r24, r24
    4b7c:	99 0b       	sbc	r25, r25
    4b7e:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    4b82:	0c 5f       	subi	r16, 0xFC	; 252
    4b84:	1f 4f       	sbci	r17, 0xFF	; 255
			if(tmp > 8) return -1;
		#else
			if(tmp > 16) return -1;
		#endif
		}
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    4b86:	01 32       	cpi	r16, 0x21	; 33
    4b88:	11 05       	cpc	r17, r1
    4b8a:	69 f7       	brne	.-38     	; 0x4b66 <wizchip_init+0x40>
    4b8c:	d8 cf       	rjmp	.-80     	; 0x4b3e <wizchip_init+0x18>
    4b8e:	e7 01       	movw	r28, r14
    4b90:	97 01       	movw	r18, r14
    4b92:	28 5f       	subi	r18, 0xF8	; 248
    4b94:	3f 4f       	sbci	r19, 0xFF	; 255
		}

	#endif
   }

   if(rxsize)
    4b96:	f7 01       	movw	r30, r14
    4b98:	80 e0       	ldi	r24, 0x00	; 0
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
		{
			tmp += rxsize[i];
    4b9a:	91 91       	ld	r25, Z+
    4b9c:	89 0f       	add	r24, r25
		#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100 and w5100s
			if(tmp > 8) return -1;
		#else
			if(tmp > 16) return -1;
    4b9e:	81 31       	cpi	r24, 0x11	; 17
    4ba0:	dc f6       	brge	.-74     	; 0x4b58 <wizchip_init+0x32>
			tmp += rxsize[i];
			if(tmp > 128) return -1;
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    4ba2:	e2 17       	cp	r30, r18
    4ba4:	f3 07       	cpc	r31, r19
    4ba6:	c9 f7       	brne	.-14     	; 0x4b9a <wizchip_init+0x74>
    4ba8:	01 e0       	ldi	r16, 0x01	; 1
    4baa:	10 e0       	ldi	r17, 0x00	; 0
		#if _WIZCHIP_ < W5200	// add condition for w5100
			j = 0;
			while((rxsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
			setSn_RXBUF_SIZE(i, j);
		#else
			setSn_RXBUF_SIZE(i, rxsize[i]);
    4bac:	49 91       	ld	r20, Y+
    4bae:	b8 01       	movw	r22, r16
    4bb0:	83 e0       	ldi	r24, 0x03	; 3
    4bb2:	66 0f       	add	r22, r22
    4bb4:	77 1f       	adc	r23, r23
    4bb6:	8a 95       	dec	r24
    4bb8:	e1 f7       	brne	.-8      	; 0x4bb2 <wizchip_init+0x8c>
    4bba:	72 5e       	subi	r23, 0xE2	; 226
    4bbc:	07 2e       	mov	r0, r23
    4bbe:	00 0c       	add	r0, r0
    4bc0:	88 0b       	sbc	r24, r24
    4bc2:	99 0b       	sbc	r25, r25
    4bc4:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    4bc8:	0c 5f       	subi	r16, 0xFC	; 252
    4bca:	1f 4f       	sbci	r17, 0xFF	; 255
		#else
			if(tmp > 16) return -1;
		#endif
		}

		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    4bcc:	01 32       	cpi	r16, 0x21	; 33
    4bce:	11 05       	cpc	r17, r1
    4bd0:	69 f7       	brne	.-38     	; 0x4bac <wizchip_init+0x86>
			setSn_RXBUF_SIZE(i, rxsize[i]);
		#endif
		}
	#endif
   }
   return 0;
    4bd2:	80 e0       	ldi	r24, 0x00	; 0
}
    4bd4:	df 91       	pop	r29
    4bd6:	cf 91       	pop	r28
    4bd8:	1f 91       	pop	r17
    4bda:	0f 91       	pop	r16
    4bdc:	ff 90       	pop	r15
    4bde:	ef 90       	pop	r14
    4be0:	08 95       	ret

00004be2 <wizchip_clrinterrupt>:

void wizchip_clrinterrupt(intr_kind intr)
{
    4be2:	cf 93       	push	r28
    4be4:	c9 2f       	mov	r28, r25
   setIR(ir);
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIR( ((((uint16_t)ir) << 8) | (((uint16_t)sir) & 0x00FF)) );
#else
   setIR(ir);
    4be6:	48 2f       	mov	r20, r24
    4be8:	40 7f       	andi	r20, 0xF0	; 240
    4bea:	60 e0       	ldi	r22, 0x00	; 0
    4bec:	75 e1       	ldi	r23, 0x15	; 21
    4bee:	80 e0       	ldi	r24, 0x00	; 0
    4bf0:	90 e0       	ldi	r25, 0x00	; 0
    4bf2:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   setSIR(sir);
    4bf6:	4c 2f       	mov	r20, r28
    4bf8:	60 e0       	ldi	r22, 0x00	; 0
    4bfa:	77 e1       	ldi	r23, 0x17	; 23
    4bfc:	80 e0       	ldi	r24, 0x00	; 0
    4bfe:	90 e0       	ldi	r25, 0x00	; 0
#endif   
}
    4c00:	cf 91       	pop	r28
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIR( ((((uint16_t)ir) << 8) | (((uint16_t)sir) & 0x00FF)) );
#else
   setIR(ir);
   setSIR(sir);
    4c02:	0c 94 ef 28 	jmp	0x51de	; 0x51de <WIZCHIP_WRITE>

00004c06 <wizchip_getinterrupt>:
#endif   
}

intr_kind wizchip_getinterrupt(void)
{
    4c06:	cf 93       	push	r28
#elif _WIZCHIP_  == W5300
   ret = getIR();
   ir = (uint8_t)(ret >> 8);
   sir = (uint8_t)ret;
#else
   ir  = getIR();
    4c08:	60 e0       	ldi	r22, 0x00	; 0
    4c0a:	75 e1       	ldi	r23, 0x15	; 21
    4c0c:	80 e0       	ldi	r24, 0x00	; 0
    4c0e:	90 e0       	ldi	r25, 0x00	; 0
    4c10:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4c14:	c8 2f       	mov	r28, r24
   sir = getSIR();
    4c16:	60 e0       	ldi	r22, 0x00	; 0
    4c18:	77 e1       	ldi	r23, 0x17	; 23
    4c1a:	80 e0       	ldi	r24, 0x00	; 0
    4c1c:	90 e0       	ldi	r25, 0x00	; 0
    4c1e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
#endif
#if _WIZCHIP_ == W5200
   ir &= ~(1 << 6);
#endif
  ret = sir;
  ret = (ret << 8) + ir;
    4c22:	90 e0       	ldi	r25, 0x00	; 0
    4c24:	98 2f       	mov	r25, r24
    4c26:	88 27       	eor	r24, r24
  return (intr_kind)ret;
    4c28:	c0 7f       	andi	r28, 0xF0	; 240
}
    4c2a:	8c 0f       	add	r24, r28
    4c2c:	91 1d       	adc	r25, r1
    4c2e:	cf 91       	pop	r28
    4c30:	08 95       	ret

00004c32 <wizchip_setinterruptmask>:

void wizchip_setinterruptmask(intr_kind intr)
{
    4c32:	cf 93       	push	r28
    4c34:	c9 2f       	mov	r28, r25
   setIMR(imr);
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIMR( ((((uint16_t)imr) << 8) | (((uint16_t)simr) & 0x00FF)) );
#else
   setIMR(imr);
    4c36:	48 2f       	mov	r20, r24
    4c38:	60 e0       	ldi	r22, 0x00	; 0
    4c3a:	76 e1       	ldi	r23, 0x16	; 22
    4c3c:	80 e0       	ldi	r24, 0x00	; 0
    4c3e:	90 e0       	ldi	r25, 0x00	; 0
    4c40:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   setSIMR(simr);
    4c44:	4c 2f       	mov	r20, r28
    4c46:	60 e0       	ldi	r22, 0x00	; 0
    4c48:	78 e1       	ldi	r23, 0x18	; 24
    4c4a:	80 e0       	ldi	r24, 0x00	; 0
    4c4c:	90 e0       	ldi	r25, 0x00	; 0
#endif   
}
    4c4e:	cf 91       	pop	r28
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIMR( ((((uint16_t)imr) << 8) | (((uint16_t)simr) & 0x00FF)) );
#else
   setIMR(imr);
   setSIMR(simr);
    4c50:	0c 94 ef 28 	jmp	0x51de	; 0x51de <WIZCHIP_WRITE>

00004c54 <wizchip_getinterruptmask>:
#endif   
}

intr_kind wizchip_getinterruptmask(void)
{
    4c54:	cf 93       	push	r28
#elif _WIZCHIP_ == W5300
   ret = getIMR();
   imr = (uint8_t)(ret >> 8);
   simr = (uint8_t)ret;
#else
   imr  = getIMR();
    4c56:	60 e0       	ldi	r22, 0x00	; 0
    4c58:	76 e1       	ldi	r23, 0x16	; 22
    4c5a:	80 e0       	ldi	r24, 0x00	; 0
    4c5c:	90 e0       	ldi	r25, 0x00	; 0
    4c5e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4c62:	c8 2f       	mov	r28, r24
   simr = getSIMR();
    4c64:	60 e0       	ldi	r22, 0x00	; 0
    4c66:	78 e1       	ldi	r23, 0x18	; 24
    4c68:	80 e0       	ldi	r24, 0x00	; 0
    4c6a:	90 e0       	ldi	r25, 0x00	; 0
    4c6c:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
#endif
#if _WIZCHIP_ == W5200
   imr &= ~(1 << 6);  // IK_DEST_UNREACH
#endif
  ret = simr;
  ret = (ret << 8) + imr;
    4c70:	90 e0       	ldi	r25, 0x00	; 0
    4c72:	98 2f       	mov	r25, r24
    4c74:	88 27       	eor	r24, r24
  return (intr_kind)ret;
}
    4c76:	8c 0f       	add	r24, r28
    4c78:	91 1d       	adc	r25, r1
    4c7a:	cf 91       	pop	r28
    4c7c:	08 95       	ret

00004c7e <wizphy_getphylink>:
	   tmp = PHY_LINK_ON;
#elif   _WIZCHIP_ == W5200
   if(getPHYSTATUS() & PHYSTATUS_LINK)
      tmp = PHY_LINK_ON;
#elif _WIZCHIP_ == W5500
   if(getPHYCFGR() & PHYCFGR_LNK_ON)
    4c7e:	60 e0       	ldi	r22, 0x00	; 0
    4c80:	7e e2       	ldi	r23, 0x2E	; 46
    4c82:	80 e0       	ldi	r24, 0x00	; 0
    4c84:	90 e0       	ldi	r25, 0x00	; 0
    4c86:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>

#else
   tmp = -1;
#endif
   return tmp;
}
    4c8a:	81 70       	andi	r24, 0x01	; 1
    4c8c:	08 95       	ret

00004c8e <wizphy_getphypmode>:
      if(getPHYSTATUS() & PHYSTATUS_POWERDOWN)
         tmp = PHY_POWER_DOWN;
      else          
         tmp = PHY_POWER_NORM;
   #elif _WIZCHIP_ == 5500
      if((getPHYCFGR() & PHYCFGR_OPMDC_ALLA) == PHYCFGR_OPMDC_PDOWN)
    4c8e:	60 e0       	ldi	r22, 0x00	; 0
    4c90:	7e e2       	ldi	r23, 0x2E	; 46
    4c92:	80 e0       	ldi	r24, 0x00	; 0
    4c94:	90 e0       	ldi	r25, 0x00	; 0
    4c96:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
      else 
         tmp = PHY_POWER_NORM;
   #else
      tmp = -1;
   #endif
   return tmp;
    4c9a:	98 2f       	mov	r25, r24
    4c9c:	98 73       	andi	r25, 0x38	; 56
    4c9e:	81 e0       	ldi	r24, 0x01	; 1
    4ca0:	90 33       	cpi	r25, 0x30	; 48
    4ca2:	09 f0       	breq	.+2      	; 0x4ca6 <wizphy_getphypmode+0x18>
    4ca4:	80 e0       	ldi	r24, 0x00	; 0
}
    4ca6:	08 95       	ret

00004ca8 <wizphy_reset>:

#endif
#if _WIZCHIP_ == W5500
void wizphy_reset(void)
{
   uint8_t tmp = getPHYCFGR();
    4ca8:	60 e0       	ldi	r22, 0x00	; 0
    4caa:	7e e2       	ldi	r23, 0x2E	; 46
    4cac:	80 e0       	ldi	r24, 0x00	; 0
    4cae:	90 e0       	ldi	r25, 0x00	; 0
    4cb0:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   tmp &= PHYCFGR_RST;
   setPHYCFGR(tmp);
    4cb4:	48 2f       	mov	r20, r24
    4cb6:	4f 77       	andi	r20, 0x7F	; 127
    4cb8:	60 e0       	ldi	r22, 0x00	; 0
    4cba:	7e e2       	ldi	r23, 0x2E	; 46
    4cbc:	80 e0       	ldi	r24, 0x00	; 0
    4cbe:	90 e0       	ldi	r25, 0x00	; 0
    4cc0:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   tmp = getPHYCFGR();
    4cc4:	60 e0       	ldi	r22, 0x00	; 0
    4cc6:	7e e2       	ldi	r23, 0x2E	; 46
    4cc8:	80 e0       	ldi	r24, 0x00	; 0
    4cca:	90 e0       	ldi	r25, 0x00	; 0
    4ccc:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   tmp |= ~PHYCFGR_RST;
   setPHYCFGR(tmp);
    4cd0:	48 2f       	mov	r20, r24
    4cd2:	40 68       	ori	r20, 0x80	; 128
    4cd4:	60 e0       	ldi	r22, 0x00	; 0
    4cd6:	7e e2       	ldi	r23, 0x2E	; 46
    4cd8:	80 e0       	ldi	r24, 0x00	; 0
    4cda:	90 e0       	ldi	r25, 0x00	; 0
    4cdc:	0c 94 ef 28 	jmp	0x51de	; 0x51de <WIZCHIP_WRITE>

00004ce0 <wizphy_setphyconf>:
}

void wizphy_setphyconf(wiz_PhyConf* phyconf)
{
    4ce0:	fc 01       	movw	r30, r24
   uint8_t tmp = 0;
   if(phyconf->by == PHY_CONFBY_SW)
    4ce2:	80 81       	ld	r24, Z
    4ce4:	81 30       	cpi	r24, 0x01	; 1
    4ce6:	11 f0       	breq	.+4      	; 0x4cec <wizphy_setphyconf+0xc>
      tmp |= PHYCFGR_OPMD;
   else
      tmp &= ~PHYCFGR_OPMD;
    4ce8:	40 e0       	ldi	r20, 0x00	; 0
    4cea:	01 c0       	rjmp	.+2      	; 0x4cee <wizphy_setphyconf+0xe>

void wizphy_setphyconf(wiz_PhyConf* phyconf)
{
   uint8_t tmp = 0;
   if(phyconf->by == PHY_CONFBY_SW)
      tmp |= PHYCFGR_OPMD;
    4cec:	40 e4       	ldi	r20, 0x40	; 64
   else
      tmp &= ~PHYCFGR_OPMD;
   if(phyconf->mode == PHY_MODE_AUTONEGO)
    4cee:	81 81       	ldd	r24, Z+1	; 0x01
    4cf0:	81 30       	cpi	r24, 0x01	; 1
    4cf2:	11 f4       	brne	.+4      	; 0x4cf8 <wizphy_setphyconf+0x18>
      tmp |= PHYCFGR_OPMDC_ALLA;
    4cf4:	48 63       	ori	r20, 0x38	; 56
    4cf6:	0d c0       	rjmp	.+26     	; 0x4d12 <wizphy_setphyconf+0x32>
   else
   {
      if(phyconf->duplex == PHY_DUPLEX_FULL)
    4cf8:	93 81       	ldd	r25, Z+3	; 0x03
    4cfa:	82 81       	ldd	r24, Z+2	; 0x02
    4cfc:	91 30       	cpi	r25, 0x01	; 1
    4cfe:	31 f4       	brne	.+12     	; 0x4d0c <wizphy_setphyconf+0x2c>
      {
         if(phyconf->speed == PHY_SPEED_100)
    4d00:	81 30       	cpi	r24, 0x01	; 1
    4d02:	11 f4       	brne	.+4      	; 0x4d08 <wizphy_setphyconf+0x28>
            tmp |= PHYCFGR_OPMDC_100F;
    4d04:	48 61       	ori	r20, 0x18	; 24
    4d06:	05 c0       	rjmp	.+10     	; 0x4d12 <wizphy_setphyconf+0x32>
         else
            tmp |= PHYCFGR_OPMDC_10F;
    4d08:	48 60       	ori	r20, 0x08	; 8
    4d0a:	03 c0       	rjmp	.+6      	; 0x4d12 <wizphy_setphyconf+0x32>
      }   
      else
      {
         if(phyconf->speed == PHY_SPEED_100)
    4d0c:	81 30       	cpi	r24, 0x01	; 1
    4d0e:	09 f4       	brne	.+2      	; 0x4d12 <wizphy_setphyconf+0x32>
            tmp |= PHYCFGR_OPMDC_100H;
    4d10:	40 61       	ori	r20, 0x10	; 16
         else
            tmp |= PHYCFGR_OPMDC_10H;
      }
   }
   setPHYCFGR(tmp);
    4d12:	60 e0       	ldi	r22, 0x00	; 0
    4d14:	7e e2       	ldi	r23, 0x2E	; 46
    4d16:	80 e0       	ldi	r24, 0x00	; 0
    4d18:	90 e0       	ldi	r25, 0x00	; 0
    4d1a:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   wizphy_reset();
    4d1e:	0c 94 54 26 	jmp	0x4ca8	; 0x4ca8 <wizphy_reset>

00004d22 <wizphy_getphyconf>:
}

void wizphy_getphyconf(wiz_PhyConf* phyconf)
{
    4d22:	cf 93       	push	r28
    4d24:	df 93       	push	r29
    4d26:	ec 01       	movw	r28, r24
   uint8_t tmp = 0;
   tmp = getPHYCFGR();
    4d28:	60 e0       	ldi	r22, 0x00	; 0
    4d2a:	7e e2       	ldi	r23, 0x2E	; 46
    4d2c:	80 e0       	ldi	r24, 0x00	; 0
    4d2e:	90 e0       	ldi	r25, 0x00	; 0
    4d30:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   phyconf->by   = (tmp & PHYCFGR_OPMD) ? PHY_CONFBY_SW : PHY_CONFBY_HW;
    4d34:	86 fb       	bst	r24, 6
    4d36:	99 27       	eor	r25, r25
    4d38:	90 f9       	bld	r25, 0
    4d3a:	98 83       	st	Y, r25
    4d3c:	88 73       	andi	r24, 0x38	; 56
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    4d3e:	80 32       	cpi	r24, 0x20	; 32
    4d40:	11 f0       	breq	.+4      	; 0x4d46 <wizphy_getphyconf+0x24>
    4d42:	88 33       	cpi	r24, 0x38	; 56
    4d44:	19 f4       	brne	.+6      	; 0x4d4c <wizphy_getphyconf+0x2a>
   {
      case PHYCFGR_OPMDC_ALLA:
      case PHYCFGR_OPMDC_100FA: 
         phyconf->mode = PHY_MODE_AUTONEGO;
    4d46:	91 e0       	ldi	r25, 0x01	; 1
    4d48:	99 83       	std	Y+1, r25	; 0x01
         break;
    4d4a:	01 c0       	rjmp	.+2      	; 0x4d4e <wizphy_getphyconf+0x2c>
      default:
         phyconf->mode = PHY_MODE_MANUAL;
    4d4c:	19 82       	std	Y+1, r1	; 0x01
         break;
   }
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    4d4e:	88 31       	cpi	r24, 0x18	; 24
    4d50:	21 f0       	breq	.+8      	; 0x4d5a <wizphy_getphyconf+0x38>
    4d52:	80 32       	cpi	r24, 0x20	; 32
    4d54:	11 f0       	breq	.+4      	; 0x4d5a <wizphy_getphyconf+0x38>
    4d56:	80 31       	cpi	r24, 0x10	; 16
    4d58:	19 f4       	brne	.+6      	; 0x4d60 <wizphy_getphyconf+0x3e>
   {
      case PHYCFGR_OPMDC_100FA:
      case PHYCFGR_OPMDC_100F:
      case PHYCFGR_OPMDC_100H:
         phyconf->speed = PHY_SPEED_100;
    4d5a:	91 e0       	ldi	r25, 0x01	; 1
    4d5c:	9a 83       	std	Y+2, r25	; 0x02
         break;
    4d5e:	01 c0       	rjmp	.+2      	; 0x4d62 <wizphy_getphyconf+0x40>
      default:
         phyconf->speed = PHY_SPEED_10;
    4d60:	1a 82       	std	Y+2, r1	; 0x02
         break;
   }
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    4d62:	88 31       	cpi	r24, 0x18	; 24
    4d64:	21 f0       	breq	.+8      	; 0x4d6e <wizphy_getphyconf+0x4c>
    4d66:	80 32       	cpi	r24, 0x20	; 32
    4d68:	11 f0       	breq	.+4      	; 0x4d6e <wizphy_getphyconf+0x4c>
    4d6a:	88 30       	cpi	r24, 0x08	; 8
    4d6c:	19 f4       	brne	.+6      	; 0x4d74 <wizphy_getphyconf+0x52>
   {
      case PHYCFGR_OPMDC_100FA:
      case PHYCFGR_OPMDC_100F:
      case PHYCFGR_OPMDC_10F:
         phyconf->duplex = PHY_DUPLEX_FULL;
    4d6e:	81 e0       	ldi	r24, 0x01	; 1
    4d70:	8b 83       	std	Y+3, r24	; 0x03
         break;
    4d72:	01 c0       	rjmp	.+2      	; 0x4d76 <wizphy_getphyconf+0x54>
      default:
         phyconf->duplex = PHY_DUPLEX_HALF;
    4d74:	1b 82       	std	Y+3, r1	; 0x03
         break;
   }
}
    4d76:	df 91       	pop	r29
    4d78:	cf 91       	pop	r28
    4d7a:	08 95       	ret

00004d7c <wizphy_getphystat>:

void wizphy_getphystat(wiz_PhyConf* phyconf)
{
    4d7c:	cf 93       	push	r28
    4d7e:	df 93       	push	r29
    4d80:	ec 01       	movw	r28, r24
   uint8_t tmp = getPHYCFGR();
    4d82:	60 e0       	ldi	r22, 0x00	; 0
    4d84:	7e e2       	ldi	r23, 0x2E	; 46
    4d86:	80 e0       	ldi	r24, 0x00	; 0
    4d88:	90 e0       	ldi	r25, 0x00	; 0
    4d8a:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   phyconf->duplex = (tmp & PHYCFGR_DPX_FULL) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
    4d8e:	82 fb       	bst	r24, 2
    4d90:	99 27       	eor	r25, r25
    4d92:	90 f9       	bld	r25, 0
    4d94:	9b 83       	std	Y+3, r25	; 0x03
   phyconf->speed  = (tmp & PHYCFGR_SPD_100) ? PHY_SPEED_100 : PHY_SPEED_10;
    4d96:	86 95       	lsr	r24
    4d98:	81 70       	andi	r24, 0x01	; 1
    4d9a:	8a 83       	std	Y+2, r24	; 0x02
}
    4d9c:	df 91       	pop	r29
    4d9e:	cf 91       	pop	r28
    4da0:	08 95       	ret

00004da2 <wizphy_setphypmode>:

int8_t wizphy_setphypmode(uint8_t pmode)
{
    4da2:	cf 93       	push	r28
    4da4:	c8 2f       	mov	r28, r24
   uint8_t tmp = 0;
   tmp = getPHYCFGR();
    4da6:	60 e0       	ldi	r22, 0x00	; 0
    4da8:	7e e2       	ldi	r23, 0x2E	; 46
    4daa:	80 e0       	ldi	r24, 0x00	; 0
    4dac:	90 e0       	ldi	r25, 0x00	; 0
    4dae:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   if((tmp & PHYCFGR_OPMD)== 0) return -1;
    4db2:	86 ff       	sbrs	r24, 6
    4db4:	1c c0       	rjmp	.+56     	; 0x4dee <wizphy_setphypmode+0x4c>
   tmp &= ~PHYCFGR_OPMDC_ALLA;         
    4db6:	48 2f       	mov	r20, r24
    4db8:	47 7c       	andi	r20, 0xC7	; 199
   if( pmode == PHY_POWER_DOWN)
    4dba:	c1 30       	cpi	r28, 0x01	; 1
    4dbc:	11 f4       	brne	.+4      	; 0x4dc2 <wizphy_setphypmode+0x20>
      tmp |= PHYCFGR_OPMDC_PDOWN;
    4dbe:	40 63       	ori	r20, 0x30	; 48
    4dc0:	01 c0       	rjmp	.+2      	; 0x4dc4 <wizphy_setphypmode+0x22>
   else
      tmp |= PHYCFGR_OPMDC_ALLA;
    4dc2:	48 63       	ori	r20, 0x38	; 56
   setPHYCFGR(tmp);
    4dc4:	60 e0       	ldi	r22, 0x00	; 0
    4dc6:	7e e2       	ldi	r23, 0x2E	; 46
    4dc8:	80 e0       	ldi	r24, 0x00	; 0
    4dca:	90 e0       	ldi	r25, 0x00	; 0
    4dcc:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   wizphy_reset();
    4dd0:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <wizphy_reset>
   tmp = getPHYCFGR();
    4dd4:	60 e0       	ldi	r22, 0x00	; 0
    4dd6:	7e e2       	ldi	r23, 0x2E	; 46
    4dd8:	80 e0       	ldi	r24, 0x00	; 0
    4dda:	90 e0       	ldi	r25, 0x00	; 0
    4ddc:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   if( pmode == PHY_POWER_DOWN)
    4de0:	c1 30       	cpi	r28, 0x01	; 1
    4de2:	11 f4       	brne	.+4      	; 0x4de8 <wizphy_setphypmode+0x46>
   {
      if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
    4de4:	80 73       	andi	r24, 0x30	; 48
    4de6:	01 c0       	rjmp	.+2      	; 0x4dea <wizphy_setphypmode+0x48>
   }
   else
   {
      if(tmp & PHYCFGR_OPMDC_ALLA) return 0;
    4de8:	88 73       	andi	r24, 0x38	; 56
    4dea:	81 11       	cpse	r24, r1
    4dec:	02 c0       	rjmp	.+4      	; 0x4df2 <wizphy_setphypmode+0x50>
   }
   return -1;
    4dee:	8f ef       	ldi	r24, 0xFF	; 255
    4df0:	01 c0       	rjmp	.+2      	; 0x4df4 <wizphy_setphypmode+0x52>
   setPHYCFGR(tmp);
   wizphy_reset();
   tmp = getPHYCFGR();
   if( pmode == PHY_POWER_DOWN)
   {
      if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
    4df2:	80 e0       	ldi	r24, 0x00	; 0
   else
   {
      if(tmp & PHYCFGR_OPMDC_ALLA) return 0;
   }
   return -1;
}
    4df4:	cf 91       	pop	r28
    4df6:	08 95       	ret

00004df8 <ctlwizchip>:
      WIZCHIP.IF.SPI._write_burst  = spi_wb;
   }
}

int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
{
    4df8:	1f 93       	push	r17
    4dfa:	cf 93       	push	r28
    4dfc:	df 93       	push	r29
#if	_WIZCHIP_ == W5100S || _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
   uint8_t tmp = 0;
#endif
   uint8_t* ptmp[2] = {0,0};
   switch(cwtype)
    4dfe:	90 e0       	ldi	r25, 0x00	; 0
    4e00:	80 31       	cpi	r24, 0x10	; 16
    4e02:	91 05       	cpc	r25, r1
    4e04:	08 f0       	brcs	.+2      	; 0x4e08 <ctlwizchip+0x10>
    4e06:	79 c0       	rjmp	.+242    	; 0x4efa <ctlwizchip+0x102>
    4e08:	eb 01       	movw	r28, r22
    4e0a:	fc 01       	movw	r30, r24
    4e0c:	e0 5b       	subi	r30, 0xB0	; 176
    4e0e:	ff 4f       	sbci	r31, 0xFF	; 255
    4e10:	0c 94 d9 2c 	jmp	0x59b2	; 0x59b2 <__tablejump2__>
   {
      case CW_RESET_WIZCHIP:
         wizchip_sw_reset();
    4e14:	0e 94 1d 25 	call	0x4a3a	; 0x4a3a <wizchip_sw_reset>
    4e18:	19 c0       	rjmp	.+50     	; 0x4e4c <ctlwizchip+0x54>
         break;
      case CW_INIT_WIZCHIP:
         if(arg != 0) 
    4e1a:	20 97       	sbiw	r28, 0x00	; 0
    4e1c:	19 f0       	breq	.+6      	; 0x4e24 <ctlwizchip+0x2c>
         {
            ptmp[0] = (uint8_t*)arg;
            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
    4e1e:	68 5f       	subi	r22, 0xF8	; 248
    4e20:	7f 4f       	sbci	r23, 0xFF	; 255
    4e22:	02 c0       	rjmp	.+4      	; 0x4e28 <ctlwizchip+0x30>
int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
{
#if	_WIZCHIP_ == W5100S || _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
   uint8_t tmp = 0;
#endif
   uint8_t* ptmp[2] = {0,0};
    4e24:	60 e0       	ldi	r22, 0x00	; 0
    4e26:	70 e0       	ldi	r23, 0x00	; 0
         if(arg != 0) 
         {
            ptmp[0] = (uint8_t*)arg;
            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
         }
         return wizchip_init(ptmp[0], ptmp[1]);
    4e28:	ce 01       	movw	r24, r28
   #endif      
      default:
         return -1;
   }
   return 0;
}
    4e2a:	df 91       	pop	r29
    4e2c:	cf 91       	pop	r28
    4e2e:	1f 91       	pop	r17
         if(arg != 0) 
         {
            ptmp[0] = (uint8_t*)arg;
            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
         }
         return wizchip_init(ptmp[0], ptmp[1]);
    4e30:	0c 94 93 25 	jmp	0x4b26	; 0x4b26 <wizchip_init>
      case CW_CLR_INTERRUPT:
         wizchip_clrinterrupt(*((intr_kind*)arg));
    4e34:	88 81       	ld	r24, Y
    4e36:	99 81       	ldd	r25, Y+1	; 0x01
    4e38:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <wizchip_clrinterrupt>
    4e3c:	07 c0       	rjmp	.+14     	; 0x4e4c <ctlwizchip+0x54>
         break;
      case CW_GET_INTERRUPT:
        *((intr_kind*)arg) = wizchip_getinterrupt();
    4e3e:	0e 94 03 26 	call	0x4c06	; 0x4c06 <wizchip_getinterrupt>
    4e42:	08 c0       	rjmp	.+16     	; 0x4e54 <ctlwizchip+0x5c>
         break;
      case CW_SET_INTRMASK:
         wizchip_setinterruptmask(*((intr_kind*)arg));
    4e44:	88 81       	ld	r24, Y
    4e46:	99 81       	ldd	r25, Y+1	; 0x01
    4e48:	0e 94 19 26 	call	0x4c32	; 0x4c32 <wizchip_setinterruptmask>
         break;
   #endif      
      default:
         return -1;
   }
   return 0;
    4e4c:	80 e0       	ldi	r24, 0x00	; 0
      case CW_GET_INTERRUPT:
        *((intr_kind*)arg) = wizchip_getinterrupt();
         break;
      case CW_SET_INTRMASK:
         wizchip_setinterruptmask(*((intr_kind*)arg));
         break;         
    4e4e:	56 c0       	rjmp	.+172    	; 0x4efc <ctlwizchip+0x104>
      case CW_GET_INTRMASK:
         *((intr_kind*)arg) = wizchip_getinterruptmask();
    4e50:	0e 94 2a 26 	call	0x4c54	; 0x4c54 <wizchip_getinterruptmask>
    4e54:	99 83       	std	Y+1, r25	; 0x01
    4e56:	88 83       	st	Y, r24
    4e58:	f9 cf       	rjmp	.-14     	; 0x4e4c <ctlwizchip+0x54>
         break;
   //M20150601 : This can be supported by W5200, W5500
   //#if _WIZCHIP_ > W5100
   #if (_WIZCHIP_ == W5200 || _WIZCHIP_ == W5500)
      case CW_SET_INTRTIME:
         setINTLEVEL(*(uint16_t*)arg);
    4e5a:	49 81       	ldd	r20, Y+1	; 0x01
    4e5c:	60 e0       	ldi	r22, 0x00	; 0
    4e5e:	73 e1       	ldi	r23, 0x13	; 19
    4e60:	80 e0       	ldi	r24, 0x00	; 0
    4e62:	90 e0       	ldi	r25, 0x00	; 0
    4e64:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    4e68:	48 81       	ld	r20, Y
    4e6a:	60 e0       	ldi	r22, 0x00	; 0
    4e6c:	74 e1       	ldi	r23, 0x14	; 20
    4e6e:	80 e0       	ldi	r24, 0x00	; 0
    4e70:	90 e0       	ldi	r25, 0x00	; 0
    4e72:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    4e76:	ea cf       	rjmp	.-44     	; 0x4e4c <ctlwizchip+0x54>
         break;
      case CW_GET_INTRTIME:
         *(uint16_t*)arg = getINTLEVEL();
    4e78:	60 e0       	ldi	r22, 0x00	; 0
    4e7a:	73 e1       	ldi	r23, 0x13	; 19
    4e7c:	80 e0       	ldi	r24, 0x00	; 0
    4e7e:	90 e0       	ldi	r25, 0x00	; 0
    4e80:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4e84:	18 2f       	mov	r17, r24
    4e86:	60 e0       	ldi	r22, 0x00	; 0
    4e88:	74 e1       	ldi	r23, 0x14	; 20
    4e8a:	80 e0       	ldi	r24, 0x00	; 0
    4e8c:	90 e0       	ldi	r25, 0x00	; 0
    4e8e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    4e92:	21 2f       	mov	r18, r17
    4e94:	30 e0       	ldi	r19, 0x00	; 0
    4e96:	32 2f       	mov	r19, r18
    4e98:	22 27       	eor	r18, r18
    4e9a:	28 0f       	add	r18, r24
    4e9c:	31 1d       	adc	r19, r1
    4e9e:	39 83       	std	Y+1, r19	; 0x01
    4ea0:	28 83       	st	Y, r18
    4ea2:	d4 cf       	rjmp	.-88     	; 0x4e4c <ctlwizchip+0x54>
         break;
   #endif
      case CW_GET_ID:
         ((uint8_t*)arg)[0] = WIZCHIP.id[0];
    4ea4:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <WIZCHIP+0x2>
    4ea8:	88 83       	st	Y, r24
         ((uint8_t*)arg)[1] = WIZCHIP.id[1];
    4eaa:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <WIZCHIP+0x3>
    4eae:	89 83       	std	Y+1, r24	; 0x01
         ((uint8_t*)arg)[2] = WIZCHIP.id[2];
    4eb0:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <WIZCHIP+0x4>
    4eb4:	8a 83       	std	Y+2, r24	; 0x02
         ((uint8_t*)arg)[3] = WIZCHIP.id[3];
    4eb6:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <WIZCHIP+0x5>
    4eba:	8b 83       	std	Y+3, r24	; 0x03
         ((uint8_t*)arg)[4] = WIZCHIP.id[4];
    4ebc:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <WIZCHIP+0x6>
    4ec0:	8c 83       	std	Y+4, r24	; 0x04
         ((uint8_t*)arg)[5] = 0;
    4ec2:	1d 82       	std	Y+5, r1	; 0x05
    4ec4:	c3 cf       	rjmp	.-122    	; 0x4e4c <ctlwizchip+0x54>
         break;
   #if _WIZCHIP_ == W5100S || _WIZCHIP_ == W5500
      case CW_RESET_PHY:
         wizphy_reset();
    4ec6:	0e 94 54 26 	call	0x4ca8	; 0x4ca8 <wizphy_reset>
    4eca:	c0 cf       	rjmp	.-128    	; 0x4e4c <ctlwizchip+0x54>
         break;
      case CW_SET_PHYCONF:
         wizphy_setphyconf((wiz_PhyConf*)arg);
    4ecc:	cb 01       	movw	r24, r22
    4ece:	0e 94 70 26 	call	0x4ce0	; 0x4ce0 <wizphy_setphyconf>
    4ed2:	bc cf       	rjmp	.-136    	; 0x4e4c <ctlwizchip+0x54>
         break;
      case CW_GET_PHYCONF:
         wizphy_getphyconf((wiz_PhyConf*)arg);
    4ed4:	cb 01       	movw	r24, r22
    4ed6:	0e 94 91 26 	call	0x4d22	; 0x4d22 <wizphy_getphyconf>
    4eda:	b8 cf       	rjmp	.-144    	; 0x4e4c <ctlwizchip+0x54>
         break;
      case CW_GET_PHYSTATUS:
         break;
      case CW_SET_PHYPOWMODE:
         return wizphy_setphypmode(*(uint8_t*)arg);
    4edc:	88 81       	ld	r24, Y
   #endif      
      default:
         return -1;
   }
   return 0;
}
    4ede:	df 91       	pop	r29
    4ee0:	cf 91       	pop	r28
    4ee2:	1f 91       	pop	r17
         wizphy_getphyconf((wiz_PhyConf*)arg);
         break;
      case CW_GET_PHYSTATUS:
         break;
      case CW_SET_PHYPOWMODE:
         return wizphy_setphypmode(*(uint8_t*)arg);
    4ee4:	0c 94 d1 26 	jmp	0x4da2	; 0x4da2 <wizphy_setphypmode>
   #endif
   #if _WIZCHIP_ == W5100S || _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
      case CW_GET_PHYPOWMODE:
         tmp = wizphy_getphypmode();
    4ee8:	0e 94 47 26 	call	0x4c8e	; 0x4c8e <wizphy_getphypmode>
    4eec:	02 c0       	rjmp	.+4      	; 0x4ef2 <ctlwizchip+0xfa>
         if((int8_t)tmp == -1) return -1;
         *(uint8_t*)arg = tmp;
         break;
      case CW_GET_PHYLINK:
         tmp = wizphy_getphylink();
    4eee:	0e 94 3f 26 	call	0x4c7e	; 0x4c7e <wizphy_getphylink>
         if((int8_t)tmp == -1) return -1;
    4ef2:	8f 3f       	cpi	r24, 0xFF	; 255
    4ef4:	11 f0       	breq	.+4      	; 0x4efa <ctlwizchip+0x102>
         *(uint8_t*)arg = tmp;
    4ef6:	88 83       	st	Y, r24
    4ef8:	a9 cf       	rjmp	.-174    	; 0x4e4c <ctlwizchip+0x54>
         break;
   #endif      
      default:
         return -1;
    4efa:	8f ef       	ldi	r24, 0xFF	; 255
   }
   return 0;
}
    4efc:	df 91       	pop	r29
    4efe:	cf 91       	pop	r28
    4f00:	1f 91       	pop	r17
    4f02:	08 95       	ret

00004f04 <wizchip_setnetinfo>:
}
#endif


void wizchip_setnetinfo(wiz_NetInfo* pnetinfo)
{
    4f04:	cf 93       	push	r28
    4f06:	df 93       	push	r29
    4f08:	ec 01       	movw	r28, r24
   setSHAR(pnetinfo->mac);
    4f0a:	26 e0       	ldi	r18, 0x06	; 6
    4f0c:	30 e0       	ldi	r19, 0x00	; 0
    4f0e:	ac 01       	movw	r20, r24
    4f10:	60 e0       	ldi	r22, 0x00	; 0
    4f12:	79 e0       	ldi	r23, 0x09	; 9
    4f14:	80 e0       	ldi	r24, 0x00	; 0
    4f16:	90 e0       	ldi	r25, 0x00	; 0
    4f18:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   setGAR(pnetinfo->gw);
    4f1c:	ae 01       	movw	r20, r28
    4f1e:	42 5f       	subi	r20, 0xF2	; 242
    4f20:	5f 4f       	sbci	r21, 0xFF	; 255
    4f22:	24 e0       	ldi	r18, 0x04	; 4
    4f24:	30 e0       	ldi	r19, 0x00	; 0
    4f26:	60 e0       	ldi	r22, 0x00	; 0
    4f28:	71 e0       	ldi	r23, 0x01	; 1
    4f2a:	80 e0       	ldi	r24, 0x00	; 0
    4f2c:	90 e0       	ldi	r25, 0x00	; 0
    4f2e:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   setSUBR(pnetinfo->sn);
    4f32:	ae 01       	movw	r20, r28
    4f34:	46 5f       	subi	r20, 0xF6	; 246
    4f36:	5f 4f       	sbci	r21, 0xFF	; 255
    4f38:	24 e0       	ldi	r18, 0x04	; 4
    4f3a:	30 e0       	ldi	r19, 0x00	; 0
    4f3c:	60 e0       	ldi	r22, 0x00	; 0
    4f3e:	75 e0       	ldi	r23, 0x05	; 5
    4f40:	80 e0       	ldi	r24, 0x00	; 0
    4f42:	90 e0       	ldi	r25, 0x00	; 0
    4f44:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   setSIPR(pnetinfo->ip);
    4f48:	ae 01       	movw	r20, r28
    4f4a:	4a 5f       	subi	r20, 0xFA	; 250
    4f4c:	5f 4f       	sbci	r21, 0xFF	; 255
    4f4e:	24 e0       	ldi	r18, 0x04	; 4
    4f50:	30 e0       	ldi	r19, 0x00	; 0
    4f52:	60 e0       	ldi	r22, 0x00	; 0
    4f54:	7f e0       	ldi	r23, 0x0F	; 15
    4f56:	80 e0       	ldi	r24, 0x00	; 0
    4f58:	90 e0       	ldi	r25, 0x00	; 0
    4f5a:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   _DNS_[0] = pnetinfo->dns[0];
    4f5e:	ef ee       	ldi	r30, 0xEF	; 239
    4f60:	f6 e0       	ldi	r31, 0x06	; 6
    4f62:	8a 89       	ldd	r24, Y+18	; 0x12
    4f64:	80 83       	st	Z, r24
   _DNS_[1] = pnetinfo->dns[1];
    4f66:	8b 89       	ldd	r24, Y+19	; 0x13
    4f68:	81 83       	std	Z+1, r24	; 0x01
   _DNS_[2] = pnetinfo->dns[2];
    4f6a:	8c 89       	ldd	r24, Y+20	; 0x14
    4f6c:	82 83       	std	Z+2, r24	; 0x02
   _DNS_[3] = pnetinfo->dns[3];
    4f6e:	8d 89       	ldd	r24, Y+21	; 0x15
    4f70:	83 83       	std	Z+3, r24	; 0x03
   _DHCP_   = pnetinfo->dhcp;
    4f72:	8e 89       	ldd	r24, Y+22	; 0x16
    4f74:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <_DHCP_>
}
    4f78:	df 91       	pop	r29
    4f7a:	cf 91       	pop	r28
    4f7c:	08 95       	ret

00004f7e <wizchip_getnetinfo>:

void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
{
    4f7e:	cf 93       	push	r28
    4f80:	df 93       	push	r29
    4f82:	ec 01       	movw	r28, r24
   getSHAR(pnetinfo->mac);
    4f84:	26 e0       	ldi	r18, 0x06	; 6
    4f86:	30 e0       	ldi	r19, 0x00	; 0
    4f88:	ac 01       	movw	r20, r24
    4f8a:	60 e0       	ldi	r22, 0x00	; 0
    4f8c:	79 e0       	ldi	r23, 0x09	; 9
    4f8e:	80 e0       	ldi	r24, 0x00	; 0
    4f90:	90 e0       	ldi	r25, 0x00	; 0
    4f92:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
   getGAR(pnetinfo->gw);
    4f96:	ae 01       	movw	r20, r28
    4f98:	42 5f       	subi	r20, 0xF2	; 242
    4f9a:	5f 4f       	sbci	r21, 0xFF	; 255
    4f9c:	24 e0       	ldi	r18, 0x04	; 4
    4f9e:	30 e0       	ldi	r19, 0x00	; 0
    4fa0:	60 e0       	ldi	r22, 0x00	; 0
    4fa2:	71 e0       	ldi	r23, 0x01	; 1
    4fa4:	80 e0       	ldi	r24, 0x00	; 0
    4fa6:	90 e0       	ldi	r25, 0x00	; 0
    4fa8:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
   getSUBR(pnetinfo->sn);
    4fac:	ae 01       	movw	r20, r28
    4fae:	46 5f       	subi	r20, 0xF6	; 246
    4fb0:	5f 4f       	sbci	r21, 0xFF	; 255
    4fb2:	24 e0       	ldi	r18, 0x04	; 4
    4fb4:	30 e0       	ldi	r19, 0x00	; 0
    4fb6:	60 e0       	ldi	r22, 0x00	; 0
    4fb8:	75 e0       	ldi	r23, 0x05	; 5
    4fba:	80 e0       	ldi	r24, 0x00	; 0
    4fbc:	90 e0       	ldi	r25, 0x00	; 0
    4fbe:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
   getSIPR(pnetinfo->ip);
    4fc2:	ae 01       	movw	r20, r28
    4fc4:	4a 5f       	subi	r20, 0xFA	; 250
    4fc6:	5f 4f       	sbci	r21, 0xFF	; 255
    4fc8:	24 e0       	ldi	r18, 0x04	; 4
    4fca:	30 e0       	ldi	r19, 0x00	; 0
    4fcc:	60 e0       	ldi	r22, 0x00	; 0
    4fce:	7f e0       	ldi	r23, 0x0F	; 15
    4fd0:	80 e0       	ldi	r24, 0x00	; 0
    4fd2:	90 e0       	ldi	r25, 0x00	; 0
    4fd4:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
   pnetinfo->dns[0]= _DNS_[0];
    4fd8:	ef ee       	ldi	r30, 0xEF	; 239
    4fda:	f6 e0       	ldi	r31, 0x06	; 6
    4fdc:	80 81       	ld	r24, Z
    4fde:	8a 8b       	std	Y+18, r24	; 0x12
   pnetinfo->dns[1]= _DNS_[1];
    4fe0:	81 81       	ldd	r24, Z+1	; 0x01
    4fe2:	8b 8b       	std	Y+19, r24	; 0x13
   pnetinfo->dns[2]= _DNS_[2];
    4fe4:	82 81       	ldd	r24, Z+2	; 0x02
    4fe6:	8c 8b       	std	Y+20, r24	; 0x14
   pnetinfo->dns[3]= _DNS_[3];
    4fe8:	83 81       	ldd	r24, Z+3	; 0x03
    4fea:	8d 8b       	std	Y+21, r24	; 0x15
   pnetinfo->dhcp  = _DHCP_;
    4fec:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <_DHCP_>
    4ff0:	8e 8b       	std	Y+22, r24	; 0x16
}
    4ff2:	df 91       	pop	r29
    4ff4:	cf 91       	pop	r28
    4ff6:	08 95       	ret

00004ff8 <wizchip_setnetmode>:

int8_t wizchip_setnetmode(netmode_type netmode)
{
    4ff8:	cf 93       	push	r28
   uint8_t tmp = 0;
#if _WIZCHIP_ != W5500
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
#else
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
    4ffa:	98 2f       	mov	r25, r24
    4ffc:	95 7c       	andi	r25, 0xC5	; 197
    4ffe:	79 f4       	brne	.+30     	; 0x501e <wizchip_setnetmode+0x26>
    5000:	c8 2f       	mov	r28, r24
#endif      
   tmp = getMR();
    5002:	60 e0       	ldi	r22, 0x00	; 0
    5004:	70 e0       	ldi	r23, 0x00	; 0
    5006:	cb 01       	movw	r24, r22
    5008:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
   tmp |= (uint8_t)netmode;
   setMR(tmp);
    500c:	4c 2f       	mov	r20, r28
    500e:	48 2b       	or	r20, r24
    5010:	60 e0       	ldi	r22, 0x00	; 0
    5012:	70 e0       	ldi	r23, 0x00	; 0
    5014:	cb 01       	movw	r24, r22
    5016:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   return 0;
    501a:	80 e0       	ldi	r24, 0x00	; 0
    501c:	01 c0       	rjmp	.+2      	; 0x5020 <wizchip_setnetmode+0x28>
{
   uint8_t tmp = 0;
#if _WIZCHIP_ != W5500
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
#else
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
    501e:	8f ef       	ldi	r24, 0xFF	; 255
#endif      
   tmp = getMR();
   tmp |= (uint8_t)netmode;
   setMR(tmp);
   return 0;
}
    5020:	cf 91       	pop	r28
    5022:	08 95       	ret

00005024 <wizchip_getnetmode>:

netmode_type wizchip_getnetmode(void)
{
   return (netmode_type) getMR();
    5024:	60 e0       	ldi	r22, 0x00	; 0
    5026:	70 e0       	ldi	r23, 0x00	; 0
    5028:	cb 01       	movw	r24, r22
    502a:	0c 94 86 28 	jmp	0x510c	; 0x510c <WIZCHIP_READ>

0000502e <wizchip_settimeout>:
}

void wizchip_settimeout(wiz_NetTimeout* nettime)
{
    502e:	cf 93       	push	r28
    5030:	df 93       	push	r29
    5032:	ec 01       	movw	r28, r24
   setRCR(nettime->retry_cnt);
    5034:	48 81       	ld	r20, Y
    5036:	60 e0       	ldi	r22, 0x00	; 0
    5038:	7b e1       	ldi	r23, 0x1B	; 27
    503a:	80 e0       	ldi	r24, 0x00	; 0
    503c:	90 e0       	ldi	r25, 0x00	; 0
    503e:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
   setRTR(nettime->time_100us);
    5042:	4a 81       	ldd	r20, Y+2	; 0x02
    5044:	60 e0       	ldi	r22, 0x00	; 0
    5046:	79 e1       	ldi	r23, 0x19	; 25
    5048:	80 e0       	ldi	r24, 0x00	; 0
    504a:	90 e0       	ldi	r25, 0x00	; 0
    504c:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    5050:	49 81       	ldd	r20, Y+1	; 0x01
    5052:	60 e0       	ldi	r22, 0x00	; 0
    5054:	7a e1       	ldi	r23, 0x1A	; 26
    5056:	80 e0       	ldi	r24, 0x00	; 0
    5058:	90 e0       	ldi	r25, 0x00	; 0
}
    505a:	df 91       	pop	r29
    505c:	cf 91       	pop	r28
}

void wizchip_settimeout(wiz_NetTimeout* nettime)
{
   setRCR(nettime->retry_cnt);
   setRTR(nettime->time_100us);
    505e:	0c 94 ef 28 	jmp	0x51de	; 0x51de <WIZCHIP_WRITE>

00005062 <wizchip_gettimeout>:
}

void wizchip_gettimeout(wiz_NetTimeout* nettime)
{
    5062:	0f 93       	push	r16
    5064:	1f 93       	push	r17
    5066:	cf 93       	push	r28
    5068:	8c 01       	movw	r16, r24
   nettime->retry_cnt = getRCR();
    506a:	60 e0       	ldi	r22, 0x00	; 0
    506c:	7b e1       	ldi	r23, 0x1B	; 27
    506e:	80 e0       	ldi	r24, 0x00	; 0
    5070:	90 e0       	ldi	r25, 0x00	; 0
    5072:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    5076:	f8 01       	movw	r30, r16
    5078:	80 83       	st	Z, r24
   nettime->time_100us = getRTR();
    507a:	60 e0       	ldi	r22, 0x00	; 0
    507c:	79 e1       	ldi	r23, 0x19	; 25
    507e:	80 e0       	ldi	r24, 0x00	; 0
    5080:	90 e0       	ldi	r25, 0x00	; 0
    5082:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    5086:	c8 2f       	mov	r28, r24
    5088:	60 e0       	ldi	r22, 0x00	; 0
    508a:	7a e1       	ldi	r23, 0x1A	; 26
    508c:	80 e0       	ldi	r24, 0x00	; 0
    508e:	90 e0       	ldi	r25, 0x00	; 0
    5090:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    5094:	2c 2f       	mov	r18, r28
    5096:	30 e0       	ldi	r19, 0x00	; 0
    5098:	32 2f       	mov	r19, r18
    509a:	22 27       	eor	r18, r18
    509c:	28 0f       	add	r18, r24
    509e:	31 1d       	adc	r19, r1
    50a0:	f8 01       	movw	r30, r16
    50a2:	32 83       	std	Z+2, r19	; 0x02
    50a4:	21 83       	std	Z+1, r18	; 0x01
}
    50a6:	cf 91       	pop	r28
    50a8:	1f 91       	pop	r17
    50aa:	0f 91       	pop	r16
    50ac:	08 95       	ret

000050ae <ctlnetwork>:
   return 0;
}


int8_t ctlnetwork(ctlnetwork_type cntype, void* arg)
{
    50ae:	cf 93       	push	r28
    50b0:	df 93       	push	r29
   
   switch(cntype)
    50b2:	82 30       	cpi	r24, 0x02	; 2
    50b4:	c1 f0       	breq	.+48     	; 0x50e6 <ctlnetwork+0x38>
    50b6:	eb 01       	movw	r28, r22
    50b8:	83 30       	cpi	r24, 0x03	; 3
    50ba:	40 f4       	brcc	.+16     	; 0x50cc <ctlnetwork+0x1e>
    50bc:	88 23       	and	r24, r24
    50be:	79 f0       	breq	.+30     	; 0x50de <ctlnetwork+0x30>
    50c0:	81 30       	cpi	r24, 0x01	; 1
    50c2:	01 f5       	brne	.+64     	; 0x5104 <ctlnetwork+0x56>
   {
      case CN_SET_NETINFO:
         wizchip_setnetinfo((wiz_NetInfo*)arg);
         break;
      case CN_GET_NETINFO:
         wizchip_getnetinfo((wiz_NetInfo*)arg);
    50c4:	cb 01       	movw	r24, r22
    50c6:	0e 94 bf 27 	call	0x4f7e	; 0x4f7e <wizchip_getnetinfo>
    50ca:	1a c0       	rjmp	.+52     	; 0x5100 <ctlnetwork+0x52>


int8_t ctlnetwork(ctlnetwork_type cntype, void* arg)
{
   
   switch(cntype)
    50cc:	84 30       	cpi	r24, 0x04	; 4
    50ce:	a9 f0       	breq	.+42     	; 0x50fa <ctlnetwork+0x4c>
    50d0:	80 f0       	brcs	.+32     	; 0x50f2 <ctlnetwork+0x44>
    50d2:	85 30       	cpi	r24, 0x05	; 5
    50d4:	b9 f4       	brne	.+46     	; 0x5104 <ctlnetwork+0x56>
         break;
      case CN_SET_TIMEOUT:
         wizchip_settimeout((wiz_NetTimeout*)arg);
         break;
      case CN_GET_TIMEOUT:
         wizchip_gettimeout((wiz_NetTimeout*)arg);
    50d6:	cb 01       	movw	r24, r22
    50d8:	0e 94 31 28 	call	0x5062	; 0x5062 <wizchip_gettimeout>
    50dc:	11 c0       	rjmp	.+34     	; 0x5100 <ctlnetwork+0x52>
{
   
   switch(cntype)
   {
      case CN_SET_NETINFO:
         wizchip_setnetinfo((wiz_NetInfo*)arg);
    50de:	cb 01       	movw	r24, r22
    50e0:	0e 94 82 27 	call	0x4f04	; 0x4f04 <wizchip_setnetinfo>
    50e4:	0d c0       	rjmp	.+26     	; 0x5100 <ctlnetwork+0x52>
         break;
      case CN_GET_NETINFO:
         wizchip_getnetinfo((wiz_NetInfo*)arg);
         break;
      case CN_SET_NETMODE:
         return wizchip_setnetmode(*(netmode_type*)arg);
    50e6:	fb 01       	movw	r30, r22
    50e8:	80 81       	ld	r24, Z
         break;
      default:
         return -1;
   }
   return 0;
}
    50ea:	df 91       	pop	r29
    50ec:	cf 91       	pop	r28
         break;
      case CN_GET_NETINFO:
         wizchip_getnetinfo((wiz_NetInfo*)arg);
         break;
      case CN_SET_NETMODE:
         return wizchip_setnetmode(*(netmode_type*)arg);
    50ee:	0c 94 fc 27 	jmp	0x4ff8	; 0x4ff8 <wizchip_setnetmode>
      case CN_GET_NETMODE:
         *(netmode_type*)arg = wizchip_getnetmode();
    50f2:	0e 94 12 28 	call	0x5024	; 0x5024 <wizchip_getnetmode>
    50f6:	88 83       	st	Y, r24
    50f8:	03 c0       	rjmp	.+6      	; 0x5100 <ctlnetwork+0x52>
         break;
      case CN_SET_TIMEOUT:
         wizchip_settimeout((wiz_NetTimeout*)arg);
    50fa:	cb 01       	movw	r24, r22
    50fc:	0e 94 17 28 	call	0x502e	; 0x502e <wizchip_settimeout>
         wizchip_gettimeout((wiz_NetTimeout*)arg);
         break;
      default:
         return -1;
   }
   return 0;
    5100:	80 e0       	ldi	r24, 0x00	; 0
      case CN_GET_NETMODE:
         *(netmode_type*)arg = wizchip_getnetmode();
         break;
      case CN_SET_TIMEOUT:
         wizchip_settimeout((wiz_NetTimeout*)arg);
         break;
    5102:	01 c0       	rjmp	.+2      	; 0x5106 <ctlnetwork+0x58>
      case CN_GET_TIMEOUT:
         wizchip_gettimeout((wiz_NetTimeout*)arg);
         break;
      default:
         return -1;
    5104:	8f ef       	ldi	r24, 0xFF	; 255
   }
   return 0;
}
    5106:	df 91       	pop	r29
    5108:	cf 91       	pop	r28
    510a:	08 95       	ret

0000510c <WIZCHIP_READ>:

#if   (_WIZCHIP_ == 5500)
////////////////////////////////////////////////////

uint8_t  WIZCHIP_READ(uint32_t AddrSel)
{
    510c:	8f 92       	push	r8
    510e:	9f 92       	push	r9
    5110:	af 92       	push	r10
    5112:	bf 92       	push	r11
    5114:	cf 92       	push	r12
    5116:	df 92       	push	r13
    5118:	ef 92       	push	r14
    511a:	ff 92       	push	r15
    511c:	cf 93       	push	r28
    511e:	df 93       	push	r29
    5120:	00 d0       	rcall	.+0      	; 0x5122 <WIZCHIP_READ+0x16>
    5122:	1f 92       	push	r1
    5124:	cd b7       	in	r28, 0x3d	; 61
    5126:	de b7       	in	r29, 0x3e	; 62
    5128:	6b 01       	movw	r12, r22
    512a:	7c 01       	movw	r14, r24
   uint8_t ret;
   uint8_t spi_data[3];

   WIZCHIP_CRITICAL_ENTER();
    512c:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    5130:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    5134:	09 95       	icall
   WIZCHIP.CS._select();
    5136:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    513a:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    513e:	09 95       	icall

   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);

   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
    5140:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <WIZCHIP+0x15>
    5144:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <WIZCHIP+0x16>
    5148:	c7 01       	movw	r24, r14
    514a:	b6 01       	movw	r22, r12
    514c:	66 27       	eor	r22, r22
    514e:	77 27       	eor	r23, r23
    5150:	99 27       	eor	r25, r25
    5152:	46 01       	movw	r8, r12
    5154:	57 01       	movw	r10, r14
    5156:	88 24       	eor	r8, r8
    5158:	aa 24       	eor	r10, r10
    515a:	bb 24       	eor	r11, r11
    515c:	23 2b       	or	r18, r19
    515e:	31 f0       	breq	.+12     	; 0x516c <WIZCHIP_READ+0x60>
    5160:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    5164:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    5168:	30 97       	sbiw	r30, 0x00	; 0
    516a:	91 f4       	brne	.+36     	; 0x5190 <WIZCHIP_READ+0x84>
   {
	   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    516c:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5170:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5174:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    5176:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    517a:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    517e:	89 2d       	mov	r24, r9
    5180:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    5182:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5186:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    518a:	8c 2d       	mov	r24, r12
    518c:	09 95       	icall
    518e:	08 c0       	rjmp	.+16     	; 0x51a0 <WIZCHIP_READ+0x94>
   }
   else																// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    5190:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    5192:	9a 82       	std	Y+2, r9	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    5194:	cb 82       	std	Y+3, r12	; 0x03
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    5196:	63 e0       	ldi	r22, 0x03	; 3
    5198:	70 e0       	ldi	r23, 0x00	; 0
    519a:	ce 01       	movw	r24, r28
    519c:	01 96       	adiw	r24, 0x01	; 1
    519e:	09 95       	icall
   }
   ret = WIZCHIP.IF.SPI._read_byte();
    51a0:	e0 91 15 01 	lds	r30, 0x0115	; 0x800115 <WIZCHIP+0x11>
    51a4:	f0 91 16 01 	lds	r31, 0x0116	; 0x800116 <WIZCHIP+0x12>
    51a8:	09 95       	icall
    51aa:	f8 2e       	mov	r15, r24

   WIZCHIP.CS._deselect();
    51ac:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    51b0:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    51b4:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    51b6:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    51ba:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    51be:	09 95       	icall
   return ret;
}
    51c0:	8f 2d       	mov	r24, r15
    51c2:	0f 90       	pop	r0
    51c4:	0f 90       	pop	r0
    51c6:	0f 90       	pop	r0
    51c8:	df 91       	pop	r29
    51ca:	cf 91       	pop	r28
    51cc:	ff 90       	pop	r15
    51ce:	ef 90       	pop	r14
    51d0:	df 90       	pop	r13
    51d2:	cf 90       	pop	r12
    51d4:	bf 90       	pop	r11
    51d6:	af 90       	pop	r10
    51d8:	9f 90       	pop	r9
    51da:	8f 90       	pop	r8
    51dc:	08 95       	ret

000051de <WIZCHIP_WRITE>:

void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
{
    51de:	8f 92       	push	r8
    51e0:	9f 92       	push	r9
    51e2:	af 92       	push	r10
    51e4:	bf 92       	push	r11
    51e6:	cf 92       	push	r12
    51e8:	df 92       	push	r13
    51ea:	ef 92       	push	r14
    51ec:	ff 92       	push	r15
    51ee:	1f 93       	push	r17
    51f0:	cf 93       	push	r28
    51f2:	df 93       	push	r29
    51f4:	00 d0       	rcall	.+0      	; 0x51f6 <WIZCHIP_WRITE+0x18>
    51f6:	00 d0       	rcall	.+0      	; 0x51f8 <WIZCHIP_WRITE+0x1a>
    51f8:	cd b7       	in	r28, 0x3d	; 61
    51fa:	de b7       	in	r29, 0x3e	; 62
    51fc:	6b 01       	movw	r12, r22
    51fe:	7c 01       	movw	r14, r24
    5200:	14 2f       	mov	r17, r20
   uint8_t spi_data[4];

   WIZCHIP_CRITICAL_ENTER();
    5202:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    5206:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    520a:	09 95       	icall
   WIZCHIP.CS._select();
    520c:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    5210:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    5214:	09 95       	icall

   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
    5216:	46 01       	movw	r8, r12
    5218:	57 01       	movw	r10, r14
    521a:	68 94       	set
    521c:	82 f8       	bld	r8, 2

   //if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
    521e:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    5222:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    5226:	c7 01       	movw	r24, r14
    5228:	b6 01       	movw	r22, r12
    522a:	66 27       	eor	r22, r22
    522c:	77 27       	eor	r23, r23
    522e:	99 27       	eor	r25, r25
    5230:	cc 24       	eor	r12, r12
    5232:	ee 24       	eor	r14, r14
    5234:	ff 24       	eor	r15, r15
    5236:	30 97       	sbiw	r30, 0x00	; 0
    5238:	c1 f4       	brne	.+48     	; 0x526a <WIZCHIP_WRITE+0x8c>
   {
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    523a:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    523e:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5242:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    5244:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5248:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    524c:	8d 2d       	mov	r24, r13
    524e:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    5250:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5254:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5258:	88 2d       	mov	r24, r8
    525a:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte(wb);
    525c:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5260:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5264:	81 2f       	mov	r24, r17
    5266:	09 95       	icall
    5268:	09 c0       	rjmp	.+18     	; 0x527c <WIZCHIP_WRITE+0x9e>
   }
   else									// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    526a:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    526c:	da 82       	std	Y+2, r13	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    526e:	8b 82       	std	Y+3, r8	; 0x03
		spi_data[3] = wb;
    5270:	1c 83       	std	Y+4, r17	; 0x04
		WIZCHIP.IF.SPI._write_burst(spi_data, 4);
    5272:	64 e0       	ldi	r22, 0x04	; 4
    5274:	70 e0       	ldi	r23, 0x00	; 0
    5276:	ce 01       	movw	r24, r28
    5278:	01 96       	adiw	r24, 0x01	; 1
    527a:	09 95       	icall
   }

   WIZCHIP.CS._deselect();
    527c:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    5280:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    5284:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    5286:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    528a:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    528e:	09 95       	icall
}
    5290:	0f 90       	pop	r0
    5292:	0f 90       	pop	r0
    5294:	0f 90       	pop	r0
    5296:	0f 90       	pop	r0
    5298:	df 91       	pop	r29
    529a:	cf 91       	pop	r28
    529c:	1f 91       	pop	r17
    529e:	ff 90       	pop	r15
    52a0:	ef 90       	pop	r14
    52a2:	df 90       	pop	r13
    52a4:	cf 90       	pop	r12
    52a6:	bf 90       	pop	r11
    52a8:	af 90       	pop	r10
    52aa:	9f 90       	pop	r9
    52ac:	8f 90       	pop	r8
    52ae:	08 95       	ret

000052b0 <WIZCHIP_READ_BUF>:
         
void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
{
    52b0:	4f 92       	push	r4
    52b2:	5f 92       	push	r5
    52b4:	6f 92       	push	r6
    52b6:	7f 92       	push	r7
    52b8:	8f 92       	push	r8
    52ba:	9f 92       	push	r9
    52bc:	af 92       	push	r10
    52be:	bf 92       	push	r11
    52c0:	cf 92       	push	r12
    52c2:	df 92       	push	r13
    52c4:	ef 92       	push	r14
    52c6:	ff 92       	push	r15
    52c8:	0f 93       	push	r16
    52ca:	1f 93       	push	r17
    52cc:	cf 93       	push	r28
    52ce:	df 93       	push	r29
    52d0:	00 d0       	rcall	.+0      	; 0x52d2 <WIZCHIP_READ_BUF+0x22>
    52d2:	1f 92       	push	r1
    52d4:	cd b7       	in	r28, 0x3d	; 61
    52d6:	de b7       	in	r29, 0x3e	; 62
    52d8:	4b 01       	movw	r8, r22
    52da:	5c 01       	movw	r10, r24
    52dc:	6a 01       	movw	r12, r20
    52de:	79 01       	movw	r14, r18
   uint8_t spi_data[3];
   uint16_t i;

   WIZCHIP_CRITICAL_ENTER();
    52e0:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    52e4:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    52e8:	09 95       	icall
   WIZCHIP.CS._select();
    52ea:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    52ee:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    52f2:	09 95       	icall

   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);

   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
    52f4:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <WIZCHIP+0x15>
    52f8:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <WIZCHIP+0x16>
    52fc:	c5 01       	movw	r24, r10
    52fe:	b4 01       	movw	r22, r8
    5300:	66 27       	eor	r22, r22
    5302:	77 27       	eor	r23, r23
    5304:	99 27       	eor	r25, r25
    5306:	24 01       	movw	r4, r8
    5308:	35 01       	movw	r6, r10
    530a:	44 24       	eor	r4, r4
    530c:	66 24       	eor	r6, r6
    530e:	77 24       	eor	r7, r7
    5310:	23 2b       	or	r18, r19
    5312:	31 f0       	breq	.+12     	; 0x5320 <WIZCHIP_READ_BUF+0x70>
    5314:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    5318:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    531c:	30 97       	sbiw	r30, 0x00	; 0
    531e:	01 f5       	brne	.+64     	; 0x5360 <WIZCHIP_READ_BUF+0xb0>
   {
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    5320:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5324:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5328:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    532a:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    532e:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5332:	85 2d       	mov	r24, r5
    5334:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    5336:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    533a:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    533e:	88 2d       	mov	r24, r8
    5340:	09 95       	icall
    5342:	86 01       	movw	r16, r12
    5344:	ec 0c       	add	r14, r12
    5346:	fd 1c       	adc	r15, r13
		for(i = 0; i < len; i++)
    5348:	0e 15       	cp	r16, r14
    534a:	1f 05       	cpc	r17, r15
    534c:	c1 f0       	breq	.+48     	; 0x537e <WIZCHIP_READ_BUF+0xce>
		   pBuf[i] = WIZCHIP.IF.SPI._read_byte();
    534e:	e0 91 15 01 	lds	r30, 0x0115	; 0x800115 <WIZCHIP+0x11>
    5352:	f0 91 16 01 	lds	r31, 0x0116	; 0x800116 <WIZCHIP+0x12>
    5356:	09 95       	icall
    5358:	f8 01       	movw	r30, r16
    535a:	81 93       	st	Z+, r24
    535c:	8f 01       	movw	r16, r30
    535e:	f4 cf       	rjmp	.-24     	; 0x5348 <WIZCHIP_READ_BUF+0x98>
   }
   else																// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    5360:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    5362:	5a 82       	std	Y+2, r5	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    5364:	8b 82       	std	Y+3, r8	; 0x03
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    5366:	63 e0       	ldi	r22, 0x03	; 3
    5368:	70 e0       	ldi	r23, 0x00	; 0
    536a:	ce 01       	movw	r24, r28
    536c:	01 96       	adiw	r24, 0x01	; 1
    536e:	09 95       	icall
		WIZCHIP.IF.SPI._read_burst(pBuf, len);
    5370:	e0 91 19 01 	lds	r30, 0x0119	; 0x800119 <WIZCHIP+0x15>
    5374:	f0 91 1a 01 	lds	r31, 0x011A	; 0x80011a <WIZCHIP+0x16>
    5378:	b7 01       	movw	r22, r14
    537a:	c6 01       	movw	r24, r12
    537c:	09 95       	icall
   }

   WIZCHIP.CS._deselect();
    537e:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    5382:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    5386:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    5388:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    538c:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    5390:	09 95       	icall
}
    5392:	0f 90       	pop	r0
    5394:	0f 90       	pop	r0
    5396:	0f 90       	pop	r0
    5398:	df 91       	pop	r29
    539a:	cf 91       	pop	r28
    539c:	1f 91       	pop	r17
    539e:	0f 91       	pop	r16
    53a0:	ff 90       	pop	r15
    53a2:	ef 90       	pop	r14
    53a4:	df 90       	pop	r13
    53a6:	cf 90       	pop	r12
    53a8:	bf 90       	pop	r11
    53aa:	af 90       	pop	r10
    53ac:	9f 90       	pop	r9
    53ae:	8f 90       	pop	r8
    53b0:	7f 90       	pop	r7
    53b2:	6f 90       	pop	r6
    53b4:	5f 90       	pop	r5
    53b6:	4f 90       	pop	r4
    53b8:	08 95       	ret

000053ba <WIZCHIP_WRITE_BUF>:

void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
{
    53ba:	4f 92       	push	r4
    53bc:	5f 92       	push	r5
    53be:	6f 92       	push	r6
    53c0:	7f 92       	push	r7
    53c2:	8f 92       	push	r8
    53c4:	9f 92       	push	r9
    53c6:	af 92       	push	r10
    53c8:	bf 92       	push	r11
    53ca:	cf 92       	push	r12
    53cc:	df 92       	push	r13
    53ce:	ef 92       	push	r14
    53d0:	ff 92       	push	r15
    53d2:	0f 93       	push	r16
    53d4:	1f 93       	push	r17
    53d6:	cf 93       	push	r28
    53d8:	df 93       	push	r29
    53da:	00 d0       	rcall	.+0      	; 0x53dc <WIZCHIP_WRITE_BUF+0x22>
    53dc:	1f 92       	push	r1
    53de:	cd b7       	in	r28, 0x3d	; 61
    53e0:	de b7       	in	r29, 0x3e	; 62
    53e2:	6b 01       	movw	r12, r22
    53e4:	7c 01       	movw	r14, r24
    53e6:	4a 01       	movw	r8, r20
    53e8:	59 01       	movw	r10, r18
   uint8_t spi_data[3];
   uint16_t i;

   WIZCHIP_CRITICAL_ENTER();
    53ea:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    53ee:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    53f2:	09 95       	icall
   WIZCHIP.CS._select();
    53f4:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    53f8:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    53fc:	09 95       	icall

   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
    53fe:	26 01       	movw	r4, r12
    5400:	37 01       	movw	r6, r14
    5402:	68 94       	set
    5404:	42 f8       	bld	r4, 2

   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
    5406:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    540a:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    540e:	c7 01       	movw	r24, r14
    5410:	b6 01       	movw	r22, r12
    5412:	66 27       	eor	r22, r22
    5414:	77 27       	eor	r23, r23
    5416:	99 27       	eor	r25, r25
    5418:	cc 24       	eor	r12, r12
    541a:	ee 24       	eor	r14, r14
    541c:	ff 24       	eor	r15, r15
    541e:	30 97       	sbiw	r30, 0x00	; 0
    5420:	01 f5       	brne	.+64     	; 0x5462 <WIZCHIP_WRITE_BUF+0xa8>
   {
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    5422:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5426:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    542a:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    542c:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5430:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5434:	8d 2d       	mov	r24, r13
    5436:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    5438:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    543c:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5440:	84 2d       	mov	r24, r4
    5442:	09 95       	icall
    5444:	84 01       	movw	r16, r8
    5446:	a8 0c       	add	r10, r8
    5448:	b9 1c       	adc	r11, r9
		for(i = 0; i < len; i++)
    544a:	0a 15       	cp	r16, r10
    544c:	1b 05       	cpc	r17, r11
    544e:	c1 f0       	breq	.+48     	; 0x5480 <WIZCHIP_WRITE_BUF+0xc6>
			WIZCHIP.IF.SPI._write_byte(pBuf[i]);
    5450:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    5454:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    5458:	d8 01       	movw	r26, r16
    545a:	8d 91       	ld	r24, X+
    545c:	8d 01       	movw	r16, r26
    545e:	09 95       	icall
    5460:	f4 cf       	rjmp	.-24     	; 0x544a <WIZCHIP_WRITE_BUF+0x90>
   }
   else									// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    5462:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    5464:	da 82       	std	Y+2, r13	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    5466:	4b 82       	std	Y+3, r4	; 0x03
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    5468:	63 e0       	ldi	r22, 0x03	; 3
    546a:	70 e0       	ldi	r23, 0x00	; 0
    546c:	ce 01       	movw	r24, r28
    546e:	01 96       	adiw	r24, 0x01	; 1
    5470:	09 95       	icall
		WIZCHIP.IF.SPI._write_burst(pBuf, len);
    5472:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    5476:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    547a:	b5 01       	movw	r22, r10
    547c:	c4 01       	movw	r24, r8
    547e:	09 95       	icall
   }

   WIZCHIP.CS._deselect();
    5480:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    5484:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    5488:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    548a:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    548e:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    5492:	09 95       	icall
}
    5494:	0f 90       	pop	r0
    5496:	0f 90       	pop	r0
    5498:	0f 90       	pop	r0
    549a:	df 91       	pop	r29
    549c:	cf 91       	pop	r28
    549e:	1f 91       	pop	r17
    54a0:	0f 91       	pop	r16
    54a2:	ff 90       	pop	r15
    54a4:	ef 90       	pop	r14
    54a6:	df 90       	pop	r13
    54a8:	cf 90       	pop	r12
    54aa:	bf 90       	pop	r11
    54ac:	af 90       	pop	r10
    54ae:	9f 90       	pop	r9
    54b0:	8f 90       	pop	r8
    54b2:	7f 90       	pop	r7
    54b4:	6f 90       	pop	r6
    54b6:	5f 90       	pop	r5
    54b8:	4f 90       	pop	r4
    54ba:	08 95       	ret

000054bc <getSn_TX_FSR>:


uint16_t getSn_TX_FSR(uint8_t sn)
{
    54bc:	8f 92       	push	r8
    54be:	9f 92       	push	r9
    54c0:	af 92       	push	r10
    54c2:	bf 92       	push	r11
    54c4:	cf 92       	push	r12
    54c6:	df 92       	push	r13
    54c8:	ef 92       	push	r14
    54ca:	ff 92       	push	r15
    54cc:	0f 93       	push	r16
    54ce:	1f 93       	push	r17
    54d0:	cf 93       	push	r28
    54d2:	df 93       	push	r29
   uint16_t val=0,val1=0;

   do
   {
      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
    54d4:	24 e0       	ldi	r18, 0x04	; 4
    54d6:	82 9f       	mul	r24, r18
    54d8:	c0 01       	movw	r24, r0
    54da:	11 24       	eor	r1, r1
    54dc:	6c 01       	movw	r12, r24
    54de:	2f ef       	ldi	r18, 0xFF	; 255
    54e0:	c2 1a       	sub	r12, r18
    54e2:	d2 0a       	sbc	r13, r18
    54e4:	23 e0       	ldi	r18, 0x03	; 3
    54e6:	cc 0c       	add	r12, r12
    54e8:	dd 1c       	adc	r13, r13
    54ea:	2a 95       	dec	r18
    54ec:	e1 f7       	brne	.-8      	; 0x54e6 <getSn_TX_FSR+0x2a>
    54ee:	46 01       	movw	r8, r12
    54f0:	80 ee       	ldi	r24, 0xE0	; 224
    54f2:	98 1a       	sub	r9, r24
    54f4:	09 2c       	mov	r0, r9
    54f6:	00 0c       	add	r0, r0
    54f8:	aa 08       	sbc	r10, r10
    54fa:	bb 08       	sbc	r11, r11
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    54fc:	2f ed       	ldi	r18, 0xDF	; 223
    54fe:	d2 1a       	sub	r13, r18
    5500:	0d 2c       	mov	r0, r13
    5502:	00 0c       	add	r0, r0
    5504:	ee 08       	sbc	r14, r14
    5506:	ff 08       	sbc	r15, r15
}


uint16_t getSn_TX_FSR(uint8_t sn)
{
   uint16_t val=0,val1=0;
    5508:	c0 e0       	ldi	r28, 0x00	; 0
    550a:	d0 e0       	ldi	r29, 0x00	; 0

   do
   {
      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
    550c:	c5 01       	movw	r24, r10
    550e:	b4 01       	movw	r22, r8
    5510:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    5514:	08 2f       	mov	r16, r24
    5516:	10 e0       	ldi	r17, 0x00	; 0
    5518:	10 2f       	mov	r17, r16
    551a:	00 27       	eor	r16, r16
    551c:	c7 01       	movw	r24, r14
    551e:	b6 01       	movw	r22, r12
    5520:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    5524:	08 0f       	add	r16, r24
    5526:	11 1d       	adc	r17, r1
      if (val1 != 0)
    5528:	01 15       	cp	r16, r1
    552a:	11 05       	cpc	r17, r1
    552c:	71 f0       	breq	.+28     	; 0x554a <getSn_TX_FSR+0x8e>
      {
        val = WIZCHIP_READ(Sn_TX_FSR(sn));
    552e:	c5 01       	movw	r24, r10
    5530:	b4 01       	movw	r22, r8
    5532:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    5536:	c8 2f       	mov	r28, r24
    5538:	d0 e0       	ldi	r29, 0x00	; 0
    553a:	dc 2f       	mov	r29, r28
    553c:	cc 27       	eor	r28, r28
    553e:	c7 01       	movw	r24, r14
    5540:	b6 01       	movw	r22, r12
    5542:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    5546:	c8 0f       	add	r28, r24
    5548:	d1 1d       	adc	r29, r1
      }
   }while (val != val1);
    554a:	c0 17       	cp	r28, r16
    554c:	d1 07       	cpc	r29, r17
    554e:	f1 f6       	brne	.-68     	; 0x550c <getSn_TX_FSR+0x50>
   return val;
}
    5550:	ce 01       	movw	r24, r28
    5552:	df 91       	pop	r29
    5554:	cf 91       	pop	r28
    5556:	1f 91       	pop	r17
    5558:	0f 91       	pop	r16
    555a:	ff 90       	pop	r15
    555c:	ef 90       	pop	r14
    555e:	df 90       	pop	r13
    5560:	cf 90       	pop	r12
    5562:	bf 90       	pop	r11
    5564:	af 90       	pop	r10
    5566:	9f 90       	pop	r9
    5568:	8f 90       	pop	r8
    556a:	08 95       	ret

0000556c <getSn_RX_RSR>:


uint16_t getSn_RX_RSR(uint8_t sn)
{
    556c:	8f 92       	push	r8
    556e:	9f 92       	push	r9
    5570:	af 92       	push	r10
    5572:	bf 92       	push	r11
    5574:	cf 92       	push	r12
    5576:	df 92       	push	r13
    5578:	ef 92       	push	r14
    557a:	ff 92       	push	r15
    557c:	0f 93       	push	r16
    557e:	1f 93       	push	r17
    5580:	cf 93       	push	r28
    5582:	df 93       	push	r29
   uint16_t val=0,val1=0;

   do
   {
      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
    5584:	24 e0       	ldi	r18, 0x04	; 4
    5586:	82 9f       	mul	r24, r18
    5588:	c0 01       	movw	r24, r0
    558a:	11 24       	eor	r1, r1
    558c:	6c 01       	movw	r12, r24
    558e:	2f ef       	ldi	r18, 0xFF	; 255
    5590:	c2 1a       	sub	r12, r18
    5592:	d2 0a       	sbc	r13, r18
    5594:	23 e0       	ldi	r18, 0x03	; 3
    5596:	cc 0c       	add	r12, r12
    5598:	dd 1c       	adc	r13, r13
    559a:	2a 95       	dec	r18
    559c:	e1 f7       	brne	.-8      	; 0x5596 <getSn_RX_RSR+0x2a>
    559e:	46 01       	movw	r8, r12
    55a0:	8a ed       	ldi	r24, 0xDA	; 218
    55a2:	98 1a       	sub	r9, r24
    55a4:	09 2c       	mov	r0, r9
    55a6:	00 0c       	add	r0, r0
    55a8:	aa 08       	sbc	r10, r10
    55aa:	bb 08       	sbc	r11, r11
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    55ac:	29 ed       	ldi	r18, 0xD9	; 217
    55ae:	d2 1a       	sub	r13, r18
    55b0:	0d 2c       	mov	r0, r13
    55b2:	00 0c       	add	r0, r0
    55b4:	ee 08       	sbc	r14, r14
    55b6:	ff 08       	sbc	r15, r15
}


uint16_t getSn_RX_RSR(uint8_t sn)
{
   uint16_t val=0,val1=0;
    55b8:	c0 e0       	ldi	r28, 0x00	; 0
    55ba:	d0 e0       	ldi	r29, 0x00	; 0

   do
   {
      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
    55bc:	c5 01       	movw	r24, r10
    55be:	b4 01       	movw	r22, r8
    55c0:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    55c4:	08 2f       	mov	r16, r24
    55c6:	10 e0       	ldi	r17, 0x00	; 0
    55c8:	10 2f       	mov	r17, r16
    55ca:	00 27       	eor	r16, r16
    55cc:	c7 01       	movw	r24, r14
    55ce:	b6 01       	movw	r22, r12
    55d0:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    55d4:	08 0f       	add	r16, r24
    55d6:	11 1d       	adc	r17, r1
      if (val1 != 0)
    55d8:	01 15       	cp	r16, r1
    55da:	11 05       	cpc	r17, r1
    55dc:	71 f0       	breq	.+28     	; 0x55fa <getSn_RX_RSR+0x8e>
      {
        val = WIZCHIP_READ(Sn_RX_RSR(sn));
    55de:	c5 01       	movw	r24, r10
    55e0:	b4 01       	movw	r22, r8
    55e2:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    55e6:	c8 2f       	mov	r28, r24
    55e8:	d0 e0       	ldi	r29, 0x00	; 0
    55ea:	dc 2f       	mov	r29, r28
    55ec:	cc 27       	eor	r28, r28
    55ee:	c7 01       	movw	r24, r14
    55f0:	b6 01       	movw	r22, r12
    55f2:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    55f6:	c8 0f       	add	r28, r24
    55f8:	d1 1d       	adc	r29, r1
      }
   }while (val != val1);
    55fa:	c0 17       	cp	r28, r16
    55fc:	d1 07       	cpc	r29, r17
    55fe:	f1 f6       	brne	.-68     	; 0x55bc <getSn_RX_RSR+0x50>
   return val;
}
    5600:	ce 01       	movw	r24, r28
    5602:	df 91       	pop	r29
    5604:	cf 91       	pop	r28
    5606:	1f 91       	pop	r17
    5608:	0f 91       	pop	r16
    560a:	ff 90       	pop	r15
    560c:	ef 90       	pop	r14
    560e:	df 90       	pop	r13
    5610:	cf 90       	pop	r12
    5612:	bf 90       	pop	r11
    5614:	af 90       	pop	r10
    5616:	9f 90       	pop	r9
    5618:	8f 90       	pop	r8
    561a:	08 95       	ret

0000561c <wiz_send_data>:

void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
{
    561c:	2f 92       	push	r2
    561e:	3f 92       	push	r3
    5620:	4f 92       	push	r4
    5622:	5f 92       	push	r5
    5624:	6f 92       	push	r6
    5626:	7f 92       	push	r7
    5628:	8f 92       	push	r8
    562a:	9f 92       	push	r9
    562c:	af 92       	push	r10
    562e:	bf 92       	push	r11
    5630:	cf 92       	push	r12
    5632:	df 92       	push	r13
    5634:	ef 92       	push	r14
    5636:	ff 92       	push	r15
    5638:	0f 93       	push	r16
    563a:	1f 93       	push	r17
    563c:	cf 93       	push	r28
    563e:	df 93       	push	r29
   uint16_t ptr = 0;
   uint32_t addrsel = 0;

   if(len == 0)  return;
    5640:	41 15       	cp	r20, r1
    5642:	51 05       	cpc	r21, r1
    5644:	09 f4       	brne	.+2      	; 0x5648 <wiz_send_data+0x2c>
    5646:	67 c0       	rjmp	.+206    	; 0x5716 <wiz_send_data+0xfa>
    5648:	5a 01       	movw	r10, r20
    564a:	4b 01       	movw	r8, r22
   ptr = getSn_TX_WR(sn);
    564c:	04 e0       	ldi	r16, 0x04	; 4
    564e:	80 9f       	mul	r24, r16
    5650:	e0 01       	movw	r28, r0
    5652:	11 24       	eor	r1, r1
    5654:	6e 01       	movw	r12, r28
    5656:	1f ef       	ldi	r17, 0xFF	; 255
    5658:	c1 1a       	sub	r12, r17
    565a:	d1 0a       	sbc	r13, r17
    565c:	83 e0       	ldi	r24, 0x03	; 3
    565e:	cc 0c       	add	r12, r12
    5660:	dd 1c       	adc	r13, r13
    5662:	8a 95       	dec	r24
    5664:	e1 f7       	brne	.-8      	; 0x565e <wiz_send_data+0x42>
    5666:	26 01       	movw	r4, r12
    5668:	2c ed       	ldi	r18, 0xDC	; 220
    566a:	52 1a       	sub	r5, r18
    566c:	05 2c       	mov	r0, r5
    566e:	00 0c       	add	r0, r0
    5670:	66 08       	sbc	r6, r6
    5672:	77 08       	sbc	r7, r7
    5674:	c3 01       	movw	r24, r6
    5676:	b2 01       	movw	r22, r4
    5678:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    567c:	08 2f       	mov	r16, r24
    567e:	3b ed       	ldi	r19, 0xDB	; 219
    5680:	d3 1a       	sub	r13, r19
    5682:	0d 2c       	mov	r0, r13
    5684:	00 0c       	add	r0, r0
    5686:	ee 08       	sbc	r14, r14
    5688:	ff 08       	sbc	r15, r15
    568a:	c7 01       	movw	r24, r14
    568c:	b6 01       	movw	r22, r12
    568e:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    5692:	10 e0       	ldi	r17, 0x00	; 0
    5694:	10 2f       	mov	r17, r16
    5696:	00 27       	eor	r16, r16
    5698:	18 01       	movw	r2, r16
    569a:	28 0e       	add	r2, r24
    569c:	31 1c       	adc	r3, r1
   //M20140501 : implict type casting -> explict type casting
   //addrsel = (ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
    569e:	22 96       	adiw	r28, 0x02	; 2
    56a0:	23 e0       	ldi	r18, 0x03	; 3
    56a2:	cc 0f       	add	r28, r28
    56a4:	dd 1f       	adc	r29, r29
    56a6:	2a 95       	dec	r18
    56a8:	e1 f7       	brne	.-8      	; 0x56a2 <wiz_send_data+0x86>
    56aa:	ce 01       	movw	r24, r28
    56ac:	dd 0f       	add	r29, r29
    56ae:	aa 0b       	sbc	r26, r26
    56b0:	bb 0b       	sbc	r27, r27
    56b2:	a1 01       	movw	r20, r2
    56b4:	60 e0       	ldi	r22, 0x00	; 0
    56b6:	70 e0       	ldi	r23, 0x00	; 0
    56b8:	76 2f       	mov	r23, r22
    56ba:	65 2f       	mov	r22, r21
    56bc:	54 2f       	mov	r21, r20
    56be:	44 27       	eor	r20, r20
    56c0:	8c 01       	movw	r16, r24
    56c2:	9d 01       	movw	r18, r26
    56c4:	04 0f       	add	r16, r20
    56c6:	15 1f       	adc	r17, r21
    56c8:	26 1f       	adc	r18, r22
    56ca:	37 1f       	adc	r19, r23
    56cc:	c9 01       	movw	r24, r18
    56ce:	b8 01       	movw	r22, r16
    56d0:	95 01       	movw	r18, r10
    56d2:	a4 01       	movw	r20, r8
    56d4:	0e 94 dd 29 	call	0x53ba	; 0x53ba <WIZCHIP_WRITE_BUF>
   
   ptr += len;
    56d8:	81 01       	movw	r16, r2
    56da:	0a 0d       	add	r16, r10
    56dc:	1b 1d       	adc	r17, r11
   setSn_TX_WR(sn,ptr);
    56de:	41 2f       	mov	r20, r17
    56e0:	c3 01       	movw	r24, r6
    56e2:	b2 01       	movw	r22, r4
    56e4:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    56e8:	40 2f       	mov	r20, r16
    56ea:	c7 01       	movw	r24, r14
    56ec:	b6 01       	movw	r22, r12
}
    56ee:	df 91       	pop	r29
    56f0:	cf 91       	pop	r28
    56f2:	1f 91       	pop	r17
    56f4:	0f 91       	pop	r16
    56f6:	ff 90       	pop	r15
    56f8:	ef 90       	pop	r14
    56fa:	df 90       	pop	r13
    56fc:	cf 90       	pop	r12
    56fe:	bf 90       	pop	r11
    5700:	af 90       	pop	r10
    5702:	9f 90       	pop	r9
    5704:	8f 90       	pop	r8
    5706:	7f 90       	pop	r7
    5708:	6f 90       	pop	r6
    570a:	5f 90       	pop	r5
    570c:	4f 90       	pop	r4
    570e:	3f 90       	pop	r3
    5710:	2f 90       	pop	r2
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
   
   ptr += len;
   setSn_TX_WR(sn,ptr);
    5712:	0c 94 ef 28 	jmp	0x51de	; 0x51de <WIZCHIP_WRITE>
}
    5716:	df 91       	pop	r29
    5718:	cf 91       	pop	r28
    571a:	1f 91       	pop	r17
    571c:	0f 91       	pop	r16
    571e:	ff 90       	pop	r15
    5720:	ef 90       	pop	r14
    5722:	df 90       	pop	r13
    5724:	cf 90       	pop	r12
    5726:	bf 90       	pop	r11
    5728:	af 90       	pop	r10
    572a:	9f 90       	pop	r9
    572c:	8f 90       	pop	r8
    572e:	7f 90       	pop	r7
    5730:	6f 90       	pop	r6
    5732:	5f 90       	pop	r5
    5734:	4f 90       	pop	r4
    5736:	3f 90       	pop	r3
    5738:	2f 90       	pop	r2
    573a:	08 95       	ret

0000573c <wiz_recv_data>:

void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
{
    573c:	2f 92       	push	r2
    573e:	3f 92       	push	r3
    5740:	4f 92       	push	r4
    5742:	5f 92       	push	r5
    5744:	6f 92       	push	r6
    5746:	7f 92       	push	r7
    5748:	8f 92       	push	r8
    574a:	9f 92       	push	r9
    574c:	af 92       	push	r10
    574e:	bf 92       	push	r11
    5750:	cf 92       	push	r12
    5752:	df 92       	push	r13
    5754:	ef 92       	push	r14
    5756:	ff 92       	push	r15
    5758:	0f 93       	push	r16
    575a:	1f 93       	push	r17
    575c:	cf 93       	push	r28
    575e:	df 93       	push	r29
   uint16_t ptr = 0;
   uint32_t addrsel = 0;
   
   if(len == 0) return;
    5760:	41 15       	cp	r20, r1
    5762:	51 05       	cpc	r21, r1
    5764:	09 f4       	brne	.+2      	; 0x5768 <wiz_recv_data+0x2c>
    5766:	67 c0       	rjmp	.+206    	; 0x5836 <wiz_recv_data+0xfa>
    5768:	5a 01       	movw	r10, r20
    576a:	4b 01       	movw	r8, r22
   ptr = getSn_RX_RD(sn);
    576c:	04 e0       	ldi	r16, 0x04	; 4
    576e:	80 9f       	mul	r24, r16
    5770:	e0 01       	movw	r28, r0
    5772:	11 24       	eor	r1, r1
    5774:	6e 01       	movw	r12, r28
    5776:	1f ef       	ldi	r17, 0xFF	; 255
    5778:	c1 1a       	sub	r12, r17
    577a:	d1 0a       	sbc	r13, r17
    577c:	83 e0       	ldi	r24, 0x03	; 3
    577e:	cc 0c       	add	r12, r12
    5780:	dd 1c       	adc	r13, r13
    5782:	8a 95       	dec	r24
    5784:	e1 f7       	brne	.-8      	; 0x577e <wiz_recv_data+0x42>
    5786:	26 01       	movw	r4, r12
    5788:	28 ed       	ldi	r18, 0xD8	; 216
    578a:	52 1a       	sub	r5, r18
    578c:	05 2c       	mov	r0, r5
    578e:	00 0c       	add	r0, r0
    5790:	66 08       	sbc	r6, r6
    5792:	77 08       	sbc	r7, r7
    5794:	c3 01       	movw	r24, r6
    5796:	b2 01       	movw	r22, r4
    5798:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    579c:	08 2f       	mov	r16, r24
    579e:	37 ed       	ldi	r19, 0xD7	; 215
    57a0:	d3 1a       	sub	r13, r19
    57a2:	0d 2c       	mov	r0, r13
    57a4:	00 0c       	add	r0, r0
    57a6:	ee 08       	sbc	r14, r14
    57a8:	ff 08       	sbc	r15, r15
    57aa:	c7 01       	movw	r24, r14
    57ac:	b6 01       	movw	r22, r12
    57ae:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    57b2:	10 e0       	ldi	r17, 0x00	; 0
    57b4:	10 2f       	mov	r17, r16
    57b6:	00 27       	eor	r16, r16
    57b8:	18 01       	movw	r2, r16
    57ba:	28 0e       	add	r2, r24
    57bc:	31 1c       	adc	r3, r1
   //M20140501 : implict type casting -> explict type casting
   //addrsel = ((ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_READ_BUF(addrsel, wizdata, len);
    57be:	23 96       	adiw	r28, 0x03	; 3
    57c0:	23 e0       	ldi	r18, 0x03	; 3
    57c2:	cc 0f       	add	r28, r28
    57c4:	dd 1f       	adc	r29, r29
    57c6:	2a 95       	dec	r18
    57c8:	e1 f7       	brne	.-8      	; 0x57c2 <wiz_recv_data+0x86>
    57ca:	ce 01       	movw	r24, r28
    57cc:	dd 0f       	add	r29, r29
    57ce:	aa 0b       	sbc	r26, r26
    57d0:	bb 0b       	sbc	r27, r27
    57d2:	a1 01       	movw	r20, r2
    57d4:	60 e0       	ldi	r22, 0x00	; 0
    57d6:	70 e0       	ldi	r23, 0x00	; 0
    57d8:	76 2f       	mov	r23, r22
    57da:	65 2f       	mov	r22, r21
    57dc:	54 2f       	mov	r21, r20
    57de:	44 27       	eor	r20, r20
    57e0:	8c 01       	movw	r16, r24
    57e2:	9d 01       	movw	r18, r26
    57e4:	04 0f       	add	r16, r20
    57e6:	15 1f       	adc	r17, r21
    57e8:	26 1f       	adc	r18, r22
    57ea:	37 1f       	adc	r19, r23
    57ec:	c9 01       	movw	r24, r18
    57ee:	b8 01       	movw	r22, r16
    57f0:	95 01       	movw	r18, r10
    57f2:	a4 01       	movw	r20, r8
    57f4:	0e 94 58 29 	call	0x52b0	; 0x52b0 <WIZCHIP_READ_BUF>
   ptr += len;
    57f8:	81 01       	movw	r16, r2
    57fa:	0a 0d       	add	r16, r10
    57fc:	1b 1d       	adc	r17, r11
   
   setSn_RX_RD(sn,ptr);
    57fe:	41 2f       	mov	r20, r17
    5800:	c3 01       	movw	r24, r6
    5802:	b2 01       	movw	r22, r4
    5804:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    5808:	40 2f       	mov	r20, r16
    580a:	c7 01       	movw	r24, r14
    580c:	b6 01       	movw	r22, r12
}
    580e:	df 91       	pop	r29
    5810:	cf 91       	pop	r28
    5812:	1f 91       	pop	r17
    5814:	0f 91       	pop	r16
    5816:	ff 90       	pop	r15
    5818:	ef 90       	pop	r14
    581a:	df 90       	pop	r13
    581c:	cf 90       	pop	r12
    581e:	bf 90       	pop	r11
    5820:	af 90       	pop	r10
    5822:	9f 90       	pop	r9
    5824:	8f 90       	pop	r8
    5826:	7f 90       	pop	r7
    5828:	6f 90       	pop	r6
    582a:	5f 90       	pop	r5
    582c:	4f 90       	pop	r4
    582e:	3f 90       	pop	r3
    5830:	2f 90       	pop	r2
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_READ_BUF(addrsel, wizdata, len);
   ptr += len;
   
   setSn_RX_RD(sn,ptr);
    5832:	0c 94 ef 28 	jmp	0x51de	; 0x51de <WIZCHIP_WRITE>
}
    5836:	df 91       	pop	r29
    5838:	cf 91       	pop	r28
    583a:	1f 91       	pop	r17
    583c:	0f 91       	pop	r16
    583e:	ff 90       	pop	r15
    5840:	ef 90       	pop	r14
    5842:	df 90       	pop	r13
    5844:	cf 90       	pop	r12
    5846:	bf 90       	pop	r11
    5848:	af 90       	pop	r10
    584a:	9f 90       	pop	r9
    584c:	8f 90       	pop	r8
    584e:	7f 90       	pop	r7
    5850:	6f 90       	pop	r6
    5852:	5f 90       	pop	r5
    5854:	4f 90       	pop	r4
    5856:	3f 90       	pop	r3
    5858:	2f 90       	pop	r2
    585a:	08 95       	ret

0000585c <wiz_recv_ignore>:
    585c:	8f 92       	push	r8
    585e:	9f 92       	push	r9
    5860:	af 92       	push	r10
    5862:	bf 92       	push	r11
    5864:	cf 92       	push	r12
    5866:	df 92       	push	r13
    5868:	ef 92       	push	r14
    586a:	ff 92       	push	r15
    586c:	1f 93       	push	r17
    586e:	cf 93       	push	r28
    5870:	df 93       	push	r29
    5872:	eb 01       	movw	r28, r22
    5874:	24 e0       	ldi	r18, 0x04	; 4
    5876:	82 9f       	mul	r24, r18
    5878:	c0 01       	movw	r24, r0
    587a:	11 24       	eor	r1, r1
    587c:	6c 01       	movw	r12, r24
    587e:	2f ef       	ldi	r18, 0xFF	; 255
    5880:	c2 1a       	sub	r12, r18
    5882:	d2 0a       	sbc	r13, r18
    5884:	83 e0       	ldi	r24, 0x03	; 3
    5886:	cc 0c       	add	r12, r12
    5888:	dd 1c       	adc	r13, r13
    588a:	8a 95       	dec	r24
    588c:	e1 f7       	brne	.-8      	; 0x5886 <wiz_recv_ignore+0x2a>
    588e:	46 01       	movw	r8, r12
    5890:	88 ed       	ldi	r24, 0xD8	; 216
    5892:	98 1a       	sub	r9, r24
    5894:	09 2c       	mov	r0, r9
    5896:	00 0c       	add	r0, r0
    5898:	aa 08       	sbc	r10, r10
    589a:	bb 08       	sbc	r11, r11
    589c:	c5 01       	movw	r24, r10
    589e:	b4 01       	movw	r22, r8
    58a0:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    58a4:	18 2f       	mov	r17, r24
    58a6:	27 ed       	ldi	r18, 0xD7	; 215
    58a8:	d2 1a       	sub	r13, r18
    58aa:	0d 2c       	mov	r0, r13
    58ac:	00 0c       	add	r0, r0
    58ae:	ee 08       	sbc	r14, r14
    58b0:	ff 08       	sbc	r15, r15
    58b2:	c7 01       	movw	r24, r14
    58b4:	b6 01       	movw	r22, r12
    58b6:	0e 94 86 28 	call	0x510c	; 0x510c <WIZCHIP_READ>
    58ba:	21 2f       	mov	r18, r17
    58bc:	30 e0       	ldi	r19, 0x00	; 0
    58be:	32 2f       	mov	r19, r18
    58c0:	22 27       	eor	r18, r18
    58c2:	c8 0f       	add	r28, r24
    58c4:	d1 1d       	adc	r29, r1
    58c6:	c2 0f       	add	r28, r18
    58c8:	d3 1f       	adc	r29, r19
    58ca:	4d 2f       	mov	r20, r29
    58cc:	c5 01       	movw	r24, r10
    58ce:	b4 01       	movw	r22, r8
    58d0:	0e 94 ef 28 	call	0x51de	; 0x51de <WIZCHIP_WRITE>
    58d4:	4c 2f       	mov	r20, r28
    58d6:	c7 01       	movw	r24, r14
    58d8:	b6 01       	movw	r22, r12
    58da:	df 91       	pop	r29
    58dc:	cf 91       	pop	r28
    58de:	1f 91       	pop	r17
    58e0:	ff 90       	pop	r15
    58e2:	ef 90       	pop	r14
    58e4:	df 90       	pop	r13
    58e6:	cf 90       	pop	r12
    58e8:	bf 90       	pop	r11
    58ea:	af 90       	pop	r10
    58ec:	9f 90       	pop	r9
    58ee:	8f 90       	pop	r8
    58f0:	0c 94 ef 28 	jmp	0x51de	; 0x51de <WIZCHIP_WRITE>

000058f4 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/
int main( void )
{
    initUART();
    58f4:	0e 94 07 07 	call	0xe0e	; 0xe0e <initUART>
    DDRB |= 0x20;
    58f8:	25 9a       	sbi	0x04, 5	; 4
    
    /* Setup TCP server for communication */
    vStartTCPServerTask();
    58fa:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vStartTCPServerTask>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    58fe:	0e 94 9f 09 	call	0x133e	; 0x133e <vTaskStartScheduler>

	return 0;
}
    5902:	80 e0       	ldi	r24, 0x00	; 0
    5904:	90 e0       	ldi	r25, 0x00	; 0
    5906:	08 95       	ret

00005908 <__udivmodhi4>:
    5908:	aa 1b       	sub	r26, r26
    590a:	bb 1b       	sub	r27, r27
    590c:	51 e1       	ldi	r21, 0x11	; 17
    590e:	07 c0       	rjmp	.+14     	; 0x591e <__udivmodhi4_ep>

00005910 <__udivmodhi4_loop>:
    5910:	aa 1f       	adc	r26, r26
    5912:	bb 1f       	adc	r27, r27
    5914:	a6 17       	cp	r26, r22
    5916:	b7 07       	cpc	r27, r23
    5918:	10 f0       	brcs	.+4      	; 0x591e <__udivmodhi4_ep>
    591a:	a6 1b       	sub	r26, r22
    591c:	b7 0b       	sbc	r27, r23

0000591e <__udivmodhi4_ep>:
    591e:	88 1f       	adc	r24, r24
    5920:	99 1f       	adc	r25, r25
    5922:	5a 95       	dec	r21
    5924:	a9 f7       	brne	.-22     	; 0x5910 <__udivmodhi4_loop>
    5926:	80 95       	com	r24
    5928:	90 95       	com	r25
    592a:	bc 01       	movw	r22, r24
    592c:	cd 01       	movw	r24, r26
    592e:	08 95       	ret

00005930 <__udivmodsi4>:
    5930:	a1 e2       	ldi	r26, 0x21	; 33
    5932:	1a 2e       	mov	r1, r26
    5934:	aa 1b       	sub	r26, r26
    5936:	bb 1b       	sub	r27, r27
    5938:	fd 01       	movw	r30, r26
    593a:	0d c0       	rjmp	.+26     	; 0x5956 <__udivmodsi4_ep>

0000593c <__udivmodsi4_loop>:
    593c:	aa 1f       	adc	r26, r26
    593e:	bb 1f       	adc	r27, r27
    5940:	ee 1f       	adc	r30, r30
    5942:	ff 1f       	adc	r31, r31
    5944:	a2 17       	cp	r26, r18
    5946:	b3 07       	cpc	r27, r19
    5948:	e4 07       	cpc	r30, r20
    594a:	f5 07       	cpc	r31, r21
    594c:	20 f0       	brcs	.+8      	; 0x5956 <__udivmodsi4_ep>
    594e:	a2 1b       	sub	r26, r18
    5950:	b3 0b       	sbc	r27, r19
    5952:	e4 0b       	sbc	r30, r20
    5954:	f5 0b       	sbc	r31, r21

00005956 <__udivmodsi4_ep>:
    5956:	66 1f       	adc	r22, r22
    5958:	77 1f       	adc	r23, r23
    595a:	88 1f       	adc	r24, r24
    595c:	99 1f       	adc	r25, r25
    595e:	1a 94       	dec	r1
    5960:	69 f7       	brne	.-38     	; 0x593c <__udivmodsi4_loop>
    5962:	60 95       	com	r22
    5964:	70 95       	com	r23
    5966:	80 95       	com	r24
    5968:	90 95       	com	r25
    596a:	9b 01       	movw	r18, r22
    596c:	ac 01       	movw	r20, r24
    596e:	bd 01       	movw	r22, r26
    5970:	cf 01       	movw	r24, r30
    5972:	08 95       	ret

00005974 <__divmodsi4>:
    5974:	05 2e       	mov	r0, r21
    5976:	97 fb       	bst	r25, 7
    5978:	1e f4       	brtc	.+6      	; 0x5980 <__divmodsi4+0xc>
    597a:	00 94       	com	r0
    597c:	0e 94 d1 2c 	call	0x59a2	; 0x59a2 <__negsi2>
    5980:	57 fd       	sbrc	r21, 7
    5982:	07 d0       	rcall	.+14     	; 0x5992 <__divmodsi4_neg2>
    5984:	0e 94 98 2c 	call	0x5930	; 0x5930 <__udivmodsi4>
    5988:	07 fc       	sbrc	r0, 7
    598a:	03 d0       	rcall	.+6      	; 0x5992 <__divmodsi4_neg2>
    598c:	4e f4       	brtc	.+18     	; 0x59a0 <__divmodsi4_exit>
    598e:	0c 94 d1 2c 	jmp	0x59a2	; 0x59a2 <__negsi2>

00005992 <__divmodsi4_neg2>:
    5992:	50 95       	com	r21
    5994:	40 95       	com	r20
    5996:	30 95       	com	r19
    5998:	21 95       	neg	r18
    599a:	3f 4f       	sbci	r19, 0xFF	; 255
    599c:	4f 4f       	sbci	r20, 0xFF	; 255
    599e:	5f 4f       	sbci	r21, 0xFF	; 255

000059a0 <__divmodsi4_exit>:
    59a0:	08 95       	ret

000059a2 <__negsi2>:
    59a2:	90 95       	com	r25
    59a4:	80 95       	com	r24
    59a6:	70 95       	com	r23
    59a8:	61 95       	neg	r22
    59aa:	7f 4f       	sbci	r23, 0xFF	; 255
    59ac:	8f 4f       	sbci	r24, 0xFF	; 255
    59ae:	9f 4f       	sbci	r25, 0xFF	; 255
    59b0:	08 95       	ret

000059b2 <__tablejump2__>:
    59b2:	ee 0f       	add	r30, r30
    59b4:	ff 1f       	adc	r31, r31
    59b6:	05 90       	lpm	r0, Z+
    59b8:	f4 91       	lpm	r31, Z
    59ba:	e0 2d       	mov	r30, r0
    59bc:	09 94       	ijmp

000059be <__mulshisi3>:
    59be:	b7 ff       	sbrs	r27, 7
    59c0:	0c 94 e7 2c 	jmp	0x59ce	; 0x59ce <__muluhisi3>

000059c4 <__mulohisi3>:
    59c4:	0e 94 e7 2c 	call	0x59ce	; 0x59ce <__muluhisi3>
    59c8:	82 1b       	sub	r24, r18
    59ca:	93 0b       	sbc	r25, r19
    59cc:	08 95       	ret

000059ce <__muluhisi3>:
    59ce:	0e 94 f2 2c 	call	0x59e4	; 0x59e4 <__umulhisi3>
    59d2:	a5 9f       	mul	r26, r21
    59d4:	90 0d       	add	r25, r0
    59d6:	b4 9f       	mul	r27, r20
    59d8:	90 0d       	add	r25, r0
    59da:	a4 9f       	mul	r26, r20
    59dc:	80 0d       	add	r24, r0
    59de:	91 1d       	adc	r25, r1
    59e0:	11 24       	eor	r1, r1
    59e2:	08 95       	ret

000059e4 <__umulhisi3>:
    59e4:	a2 9f       	mul	r26, r18
    59e6:	b0 01       	movw	r22, r0
    59e8:	b3 9f       	mul	r27, r19
    59ea:	c0 01       	movw	r24, r0
    59ec:	a3 9f       	mul	r26, r19
    59ee:	70 0d       	add	r23, r0
    59f0:	81 1d       	adc	r24, r1
    59f2:	11 24       	eor	r1, r1
    59f4:	91 1d       	adc	r25, r1
    59f6:	b2 9f       	mul	r27, r18
    59f8:	70 0d       	add	r23, r0
    59fa:	81 1d       	adc	r24, r1
    59fc:	11 24       	eor	r1, r1
    59fe:	91 1d       	adc	r25, r1
    5a00:	08 95       	ret

00005a02 <memcpy>:
    5a02:	fb 01       	movw	r30, r22
    5a04:	dc 01       	movw	r26, r24
    5a06:	02 c0       	rjmp	.+4      	; 0x5a0c <memcpy+0xa>
    5a08:	01 90       	ld	r0, Z+
    5a0a:	0d 92       	st	X+, r0
    5a0c:	41 50       	subi	r20, 0x01	; 1
    5a0e:	50 40       	sbci	r21, 0x00	; 0
    5a10:	d8 f7       	brcc	.-10     	; 0x5a08 <memcpy+0x6>
    5a12:	08 95       	ret

00005a14 <itoa>:
    5a14:	45 32       	cpi	r20, 0x25	; 37
    5a16:	51 05       	cpc	r21, r1
    5a18:	20 f4       	brcc	.+8      	; 0x5a22 <itoa+0xe>
    5a1a:	42 30       	cpi	r20, 0x02	; 2
    5a1c:	10 f0       	brcs	.+4      	; 0x5a22 <itoa+0xe>
    5a1e:	0c 94 15 2d 	jmp	0x5a2a	; 0x5a2a <__itoa_ncheck>
    5a22:	fb 01       	movw	r30, r22
    5a24:	10 82       	st	Z, r1
    5a26:	cb 01       	movw	r24, r22
    5a28:	08 95       	ret

00005a2a <__itoa_ncheck>:
    5a2a:	bb 27       	eor	r27, r27
    5a2c:	4a 30       	cpi	r20, 0x0A	; 10
    5a2e:	31 f4       	brne	.+12     	; 0x5a3c <__itoa_ncheck+0x12>
    5a30:	99 23       	and	r25, r25
    5a32:	22 f4       	brpl	.+8      	; 0x5a3c <__itoa_ncheck+0x12>
    5a34:	bd e2       	ldi	r27, 0x2D	; 45
    5a36:	90 95       	com	r25
    5a38:	81 95       	neg	r24
    5a3a:	9f 4f       	sbci	r25, 0xFF	; 255
    5a3c:	0c 94 21 2d 	jmp	0x5a42	; 0x5a42 <__utoa_common>

00005a40 <__utoa_ncheck>:
    5a40:	bb 27       	eor	r27, r27

00005a42 <__utoa_common>:
    5a42:	fb 01       	movw	r30, r22
    5a44:	55 27       	eor	r21, r21
    5a46:	aa 27       	eor	r26, r26
    5a48:	88 0f       	add	r24, r24
    5a4a:	99 1f       	adc	r25, r25
    5a4c:	aa 1f       	adc	r26, r26
    5a4e:	a4 17       	cp	r26, r20
    5a50:	10 f0       	brcs	.+4      	; 0x5a56 <__utoa_common+0x14>
    5a52:	a4 1b       	sub	r26, r20
    5a54:	83 95       	inc	r24
    5a56:	50 51       	subi	r21, 0x10	; 16
    5a58:	b9 f7       	brne	.-18     	; 0x5a48 <__utoa_common+0x6>
    5a5a:	a0 5d       	subi	r26, 0xD0	; 208
    5a5c:	aa 33       	cpi	r26, 0x3A	; 58
    5a5e:	08 f0       	brcs	.+2      	; 0x5a62 <__utoa_common+0x20>
    5a60:	a9 5d       	subi	r26, 0xD9	; 217
    5a62:	a1 93       	st	Z+, r26
    5a64:	00 97       	sbiw	r24, 0x00	; 0
    5a66:	79 f7       	brne	.-34     	; 0x5a46 <__utoa_common+0x4>
    5a68:	b1 11       	cpse	r27, r1
    5a6a:	b1 93       	st	Z+, r27
    5a6c:	11 92       	st	Z+, r1
    5a6e:	cb 01       	movw	r24, r22
    5a70:	0c 94 3a 2d 	jmp	0x5a74	; 0x5a74 <strrev>

00005a74 <strrev>:
    5a74:	dc 01       	movw	r26, r24
    5a76:	fc 01       	movw	r30, r24
    5a78:	67 2f       	mov	r22, r23
    5a7a:	71 91       	ld	r23, Z+
    5a7c:	77 23       	and	r23, r23
    5a7e:	e1 f7       	brne	.-8      	; 0x5a78 <strrev+0x4>
    5a80:	32 97       	sbiw	r30, 0x02	; 2
    5a82:	04 c0       	rjmp	.+8      	; 0x5a8c <strrev+0x18>
    5a84:	7c 91       	ld	r23, X
    5a86:	6d 93       	st	X+, r22
    5a88:	70 83       	st	Z, r23
    5a8a:	62 91       	ld	r22, -Z
    5a8c:	ae 17       	cp	r26, r30
    5a8e:	bf 07       	cpc	r27, r31
    5a90:	c8 f3       	brcs	.-14     	; 0x5a84 <strrev+0x10>
    5a92:	08 95       	ret

00005a94 <_exit>:
    5a94:	f8 94       	cli

00005a96 <__stop_program>:
    5a96:	ff cf       	rjmp	.-2      	; 0x5a96 <__stop_program>
